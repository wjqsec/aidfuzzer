--------------------------------------------------------------------------------
Profile data file 'callgrind.out.138496' (creator: callgrind-3.18.1)
--------------------------------------------------------------------------------
I1 cache: 
D1 cache: 
LL cache: 
Timerange: Basic block 0 - 14618102606
Trigger: Program termination
Profiled target:  /root/fuzzer/xxfuzzer/framework/a.out (PID 138496, part 1)
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Thresholds:       99
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                      
--------------------------------------------------------------------------------
72,939,810,199 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                       file:function
--------------------------------------------------------------------------------
14,282,311,585 (19.58%)  ???:0x0000000058c5f000 [???]
13,040,219,455 (17.88%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cpu-exec.c:cpu_exec [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
 6,941,011,790 ( 9.52%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:cpu_get_tb_cpu_state [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
 5,187,316,049 ( 7.11%)  ???:arm_exec_bbl [/root/fuzzer/xxfuzzer/framework/a.out]
 4,077,996,591 ( 5.59%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:tlb_reset_dirty [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
 2,180,862,388 ( 2.99%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/qemu/bitops.h:cpu_get_tb_cpu_state
 2,146,323,336 ( 2.94%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cpu-exec.c:curr_cflags [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
 2,146,279,649 ( 2.94%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/tcg-runtime.c:helper_xx_bbl [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
 1,970,031,284 ( 2.70%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/tb-hash.h:cpu_exec
 1,073,161,668 ( 1.47%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/cpu.h:cpu_get_tb_cpu_state
 1,066,995,616 ( 1.46%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:helper_udiv [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
 1,055,585,940 ( 1.45%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:nvic_recompute_state [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   830,107,642 ( 1.14%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/tb-jmp-cache.h:cpu_exec
   815,818,380 ( 1.12%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/tcg/tcg.h:cpu_exec
   745,521,989 ( 1.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cpu-exec.c:helper_lookup_tb_ptr [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   708,229,120 ( 0.97%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/ptw.c:get_phys_addr_with_struct [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   561,664,810 ( 0.77%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:victim_tlb_hit [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   478,798,528 ( 0.66%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:flatview_do_translate.isra.0 [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   451,037,244 ( 0.62%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/exec/ram_addr.h:invalidate_and_set_dirty
   363,653,369 ( 0.50%)  ./elf/../sysdeps/x86_64/tls_get_addr.S:__tls_get_addr [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
   352,395,119 ( 0.48%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:address_space_translate_internal [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   331,785,828 ( 0.45%)  ???:g_hash_table_lookup [/usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.7200.1]
   329,966,960 ( 0.45%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:nvic_rettobase
   319,726,678 ( 0.44%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_is_ancestor [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   276,229,920 ( 0.38%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:flatview_translate [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   275,794,386 ( 0.38%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:full_le_ldul_mmu [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   267,216,456 ( 0.37%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qht.c:qht_lookup_custom [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   252,978,836 ( 0.35%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:probe_access_internal [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   242,361,230 ( 0.33%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_class_dynamic_cast [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   230,574,851 ( 0.32%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/bitops.c:find_next_zero_bit [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   209,199,848 ( 0.29%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/ptw.c:get_phys_addr [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   205,607,104 ( 0.28%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:access_with_adjusted_size [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   201,153,700 ( 0.28%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/ptw.c:get_phys_addr_with_secure [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   195,412,686 ( 0.27%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:v7m_stack_write [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   194,854,372 ( 0.27%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:qemu_ram_block_from_host [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   181,235,584 ( 0.25%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:v7m_stack_read [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   174,155,879 ( 0.24%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:full_le_stl_mmu [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   173,774,766 ( 0.24%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cpu-exec.c:tb_htable_lookup [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   169,193,236 ( 0.23%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/internals.h:get_phys_addr_with_struct
   161,607,886 ( 0.22%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/tb-hash.h:helper_lookup_tb_ptr
   161,081,022 ( 0.22%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/exec/exec-all.h:cpu_exec
   160,922,960 ( 0.22%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/ptw.c:regime_translation_disabled [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   157,608,564 ( 0.22%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:nvic_exec_prio [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   157,501,260 ( 0.22%)  ???:g_str_hash [/usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.7200.1]
   152,744,939 ( 0.21%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:get_page_addr_code_hostp [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   147,755,298 ( 0.20%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:arm_v7m_cpu_do_interrupt [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   147,556,518 ( 0.20%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/memory_ldst.c.inc:address_space_stl_le [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   147,445,256 ( 0.20%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/qemu/xxhash.h:tb_htable_lookup
   137,404,268 ( 0.19%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/memory_ldst.c.inc:address_space_ldl [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   137,035,602 ( 0.19%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:invalidate_and_set_dirty [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   123,689,298 ( 0.17%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_class_dynamic_cast_assert [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   121,584,666 ( 0.17%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/qemu/int128.h:address_space_translate_internal
   118,927,651 ( 0.16%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cpu-exec.c:tb_lookup_cmp [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   116,608,360 ( 0.16%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:qemu_mutex_lock_iothread_impl [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   114,115,477 ( 0.16%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:io_readx [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   109,149,805 ( 0.15%)  ./io/../sysdeps/unix/sysv/linux/read.c:read [/usr/lib/x86_64-linux-gnu/libc.so.6]
   108,503,781 ( 0.15%)  ./string/../sysdeps/x86_64/multiarch/strcmp-avx2.S:__strcmp_avx2 [/usr/lib/x86_64-linux-gnu/libc.so.6]
   103,383,924 ( 0.14%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:get_iothread_locked [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
   103,185,490 ( 0.14%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_dispatch_read [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    99,665,154 ( 0.14%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_get_dirty_log_mask [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    98,406,057 ( 0.13%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_access_valid [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    94,806,738 ( 0.13%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:qemu_ram_addr_from_host [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    92,775,689 ( 0.13%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_dispatch_write [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    84,804,278 ( 0.12%)  ./nptl/./nptl/cancellation.c:__pthread_enable_asynccancel [/usr/lib/x86_64-linux-gnu/libc.so.6]
    81,625,852 ( 0.11%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:set_iothread_locked [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    80,461,480 ( 0.11%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/ptw.c:get_phys_addr_pmsav7_default [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    80,315,275 ( 0.11%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:iotlb_to_section [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    79,169,645 ( 0.11%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:io_writex [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    70,922,622 ( 0.10%)  ???:mmio_read [/root/fuzzer/xxfuzzer/framework/a.out]
    70,636,762 ( 0.10%)  ???:0x00000000000540f0 [/usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.7200.1]
    69,965,016 ( 0.10%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:qemu_mutex_unlock_iothread [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    67,796,238 ( 0.09%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/exec/memory.h:address_space_stl_le
    67,363,248 ( 0.09%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:cpu_get_address_space [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    65,888,284 ( 0.09%)  ???:0x0000000058c63e62 [???]
    65,300,399 ( 0.09%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/tb-jmp-cache.h:helper_lookup_tb_ptr
    64,453,648 ( 0.09%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/exec/memory.h:flatview_do_translate.isra.0
    63,895,731 ( 0.09%)  ???:g_main_context_check [/usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.7200.1]
    63,269,490 ( 0.09%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/exec/cpu_ldst.h:probe_access_internal
    60,668,105 ( 0.08%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:phys_page_find [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    60,644,322 ( 0.08%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:arm_v7m_mmu_idx_for_secstate_and_priv [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    60,608,894 ( 0.08%)  ???:0x0000000004e3cc50 [???]
    59,944,820 ( 0.08%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:tlb_set_dirty [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    59,640,238 ( 0.08%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:qemu_map_ram_ptr [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    58,046,217 ( 0.08%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/exec/cpu_ldst.h:full_le_ldul_mmu
    57,621,148 ( 0.08%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/exec/memory.h:address_space_ldl
    56,758,392 ( 0.08%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_read_accessor [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    55,919,920 ( 0.08%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:v7m_push_stack [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    52,932,208 ( 0.07%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:timerlist_deadline_ns [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    51,120,204 ( 0.07%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/exec/ram_addr.h:qemu_map_ram_ptr
    50,536,935 ( 0.07%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:armv7m_nvic_neg_prio_requested [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    49,962,615 ( 0.07%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/cpu-sysemu.c:cpu_asidx_from_attrs [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    47,219,034 ( 0.06%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/exec/cpu_ldst.h:full_le_stl_mmu
    46,274,446 ( 0.06%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/qemu/range.h:address_space_translate_internal
    45,144,856 ( 0.06%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:armv7m_nvic_get_ready_status [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    44,603,594 ( 0.06%)  ???:g_main_context_prepare [/usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.7200.1]
    43,197,024 ( 0.06%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:timerlistgroup_deadline_ns [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    42,136,328 ( 0.06%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:qemu_ram_addr_from_host_nofail [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    42,069,021 ( 0.06%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/exec/cpu-all.h:full_le_ldul_mmu
    41,274,488 ( 0.06%)  ???:g_str_equal [/usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.7200.1]
    40,463,508 ( 0.06%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:arm_v7m_mmu_idx_all [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    40,230,740 ( 0.06%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/cpu.h:get_phys_addr_with_struct
    39,891,528 ( 0.05%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:v7m_exception_taken [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    39,612,282 ( 0.05%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:helper_v7m_mrs [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    39,198,330 ( 0.05%)  ???:0x0000000000053d50 [/usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.7200.1]
    39,140,436 ( 0.05%)  ./nptl/./nptl/cancellation.c:__pthread_disable_asynccancel [/usr/lib/x86_64-linux-gnu/libc.so.6]
    38,918,088 ( 0.05%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:qemu_clock_use_for_deadline [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    37,469,696 ( 0.05%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:access_with_adjusted_size'2 [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    36,948,680 ( 0.05%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/cpu_tcg.c:arm_v7m_cpu_exec_interrupt [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    36,861,314 ( 0.05%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/qemu/bitops.h:tb_htable_lookup
    36,722,605 ( 0.05%)  ./io/../sysdeps/unix/sysv/linux/write.c:write [/usr/lib/x86_64-linux-gnu/libc.so.6]
    36,688,376 ( 0.05%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:do_armv7m_nvic_set_pending [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    34,461,308 ( 0.05%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:qemu_mutex_iothread_locked [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    34,280,234 ( 0.05%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/cpu.c:arm_cpu_set_irq [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    34,049,970 ( 0.05%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:rebuild_hflags_common_32 [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    34,049,970 ( 0.05%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/qemu/bitops.h:rebuild_hflags_common_32
    34,049,964 ( 0.05%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:fp_exception_el [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    33,520,398 ( 0.05%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/cpu.h:helper_v7m_mrs
    33,478,789 ( 0.05%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_write_accessor [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    32,158,305 ( 0.04%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:rebuild_hflags_m32 [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    28,976,494 ( 0.04%)  ???:g_main_context_query [/usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.7200.1]
    28,405,574 ( 0.04%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:full_le_stl_mmu'2 [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    27,916,098 ( 0.04%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/cpu.h:v7m_stack_write
    27,449,725 ( 0.04%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:arm_rebuild_hflags [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    27,431,723 ( 0.04%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/exec/cpu-all.h:full_le_stl_mmu
    27,339,112 ( 0.04%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/hw/core/cpu.h:cpu_exec
    26,270,770 ( 0.04%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/exec/memopidx.h:full_le_ldul_mmu
    25,993,302 ( 0.04%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_get_ram_addr [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    25,754,982 ( 0.04%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_is_ram_device [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    25,679,135 ( 0.04%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:tlb_set_page_full [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    25,124,450 ( 0.03%)  ./nptl/./nptl/pthread_cleanup_upto.c:__pthread_cleanup_upto [/usr/lib/x86_64-linux-gnu/libc.so.6]
    25,124,375 ( 0.03%)  ./debug/../sysdeps/unix/sysv/linux/x86_64/____longjmp_chk.S:____longjmp_chk [/usr/lib/x86_64-linux-gnu/libc.so.6]
    24,624,400 ( 0.03%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:armv7m_nvic_complete_irq [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    23,797,963 ( 0.03%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:arm_v7m_mmu_idx_for_secstate [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    23,639,424 ( 0.03%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/cpu.h:arm_v7m_cpu_do_interrupt
    23,639,424 ( 0.03%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/cpu.h:v7m_stack_read
    23,578,821 ( 0.03%)  /usr/include/x86_64-linux-gnu/bits/string_fortified.h:xx_restore_arm_ctx_state
    23,410,576 ( 0.03%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_dispatch_read'2 [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    22,818,980 ( 0.03%)  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms [/usr/lib/x86_64-linux-gnu/libc.so.6]
    22,788,450 ( 0.03%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:adjust_endianness.isra.0 [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    21,673,860 ( 0.03%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/exec/ram_addr.h:notdirty_write.isra.0
    21,063,608 ( 0.03%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/qemu/seqlock.h:qht_lookup_custom
    19,964,438 ( 0.03%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/tcg/tcg.h:full_le_ldul_mmu
    19,934,536 ( 0.03%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/main-loop.c:main_loop_wait [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    19,800,466 ( 0.03%)  ???:restore_snapshot [/root/fuzzer/xxfuzzer/framework/a.out]
    19,699,520 ( 0.03%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:armv7m_nvic_acknowledge_irq [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    19,230,116 ( 0.03%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_read_with_attrs_accessor'2 [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    19,151,510 ( 0.03%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/bitops.c:find_next_bit [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    19,073,224 ( 0.03%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:arm_mmu_idx_el [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    18,714,544 ( 0.03%)  ???:arm_cpu_do_interrupt_hook [/root/fuzzer/xxfuzzer/framework/a.out]
    18,680,040 ( 0.03%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:flatview_access_valid [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    18,429,584 ( 0.03%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:armv7m_nvic_can_take_pending_exception [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    17,237,080 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/cpu.h:v7m_push_stack
    17,166,620 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:helper_v7m_msr [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    16,654,205 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/cpu.h:arm_asidx_from_attrs [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    16,286,950 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:tlb_flush_vtlb_page_mask_locked [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    16,079,600 ( 0.02%)  ./debug/../setjmp/longjmp.c:__longjmp_chk [/usr/lib/x86_64-linux-gnu/libc.so.6]
    15,969,778 ( 0.02%)  ???:g_source_ref [/usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.7200.1]
    15,611,730 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/cpu-common.c:cpu_reset_interrupt [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    15,455,814 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_get_class [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    15,192,300 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/exec/memory.h:adjust_endianness.isra.0
    14,700,800 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:helper_rebuild_hflags_m32 [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    14,691,626 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/exec/cpu-all.h:helper_lookup_tb_ptr
    14,489,680 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/hw/core/cpu.h:arm_v7m_cpu_exec_interrupt
    14,376,424 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:timerlist_run_timers [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    13,799,430 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/irq.c:qemu_set_irq [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    13,582,428 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/exec/memopidx.h:full_le_stl_mmu
    13,317,948 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:flatview_read_continue [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    13,241,655 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/internals.h:fp_exception_el
    13,058,502 ( 0.02%)  ???:g_mutex_lock [/usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.7200.1]
    13,058,502 ( 0.02%)  ???:g_mutex_unlock [/usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.7200.1]
    13,046,685 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/tcg/tcg.h:full_le_stl_mmu
    12,887,172 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_dynamic_cast_assert [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    12,823,492 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_mutex_lock_impl [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    12,823,492 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_mutex_unlock_impl [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    12,798,176 ( 0.02%)  ???:0x0000000058c84599 [???]
    12,656,684 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_read_with_attrs_accessor [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    12,602,176 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:memory_access_size [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    12,584,628 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:v7m_update_fpccr [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    12,579,152 ( 0.02%)  ./debug/./debug/read_chk.c:__read_chk [/usr/lib/x86_64-linux-gnu/libc.so.6]
    12,513,354 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/exec/exec-all.h:helper_lookup_tb_ptr
    12,412,341 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/aio-posix.c:aio_pending [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    12,366,854 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/exec/ram_addr.h:tlb_set_page_full
    12,312,200 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:armv7m_nvic_get_pending_irq_info [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    12,205,869 ( 0.02%)  ./malloc/./malloc/malloc.c:_int_malloc [/usr/lib/x86_64-linux-gnu/libc.so.6]
    12,088,320 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/bitmap.c:bitmap_set_atomic [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    11,892,020 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:flatview_write_continue [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    11,729,232 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/cpu.h:helper_v7m_msr
    11,719,260 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_dispatch_write'2 [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    11,349,990 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/cpu.h:rebuild_hflags_common_32
    11,076,370 ( 0.02%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:flatview_write [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    10,867,260 ( 0.01%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/cpu-qom.h:arm_v7m_cpu_exec_interrupt
    10,867,200 ( 0.01%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/lockcnt.c:qemu_lockcnt_inc [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    10,799,256 ( 0.01%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/qemu/timer.h:timerlistgroup_deadline_ns
    10,544,915 ( 0.01%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/exec/cpu-all.h:probe_access_internal
    10,534,082 ( 0.01%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/qemu/bitops.h:get_page_addr_code_hostp
    10,531,804 ( 0.01%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/exec/exec-all.h:tb_htable_lookup
    10,531,254 ( 0.01%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/exec/exec-all.h:tb_lookup_cmp
    10,508,308 ( 0.01%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:helper_le_ldul_mmu [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    10,434,398 ( 0.01%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/cpu.h:arm_rebuild_hflags
    10,370,468 ( 0.01%)  ???:0x0000000004e3bdd0 [???]
    10,318,872 ( 0.01%)  ???:0x0000000005f37710 [???]
    10,279,486 ( 0.01%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/xx-common-tcgloop.c:xx_get_dirty_pages [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
    10,186,821 ( 0.01%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:helper_le_stl_mmu [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
     9,961,600 ( 0.01%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:qemu_clock_run_all_timers [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
     9,765,916 ( 0.01%)  ???:0x0000000058c8c4a0 [???]
     9,491,276 ( 0.01%)  ???:0x0000000000109230 [???]
     9,458,325 ( 0.01%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/debug_helper.c:arm_singlestep_active [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
     9,418,256 ( 0.01%)  ???:g_array_set_size [/usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.7200.1]
     9,418,240 ( 0.01%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/async.c:aio_ctx_prepare [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
     9,388,104 ( 0.01%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:flatview_read [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
     9,325,894 ( 0.01%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/exec/memory.h:address_space_translate_internal
     9,056,075 ( 0.01%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/lockcnt.c:qemu_lockcnt_cmpxchg_or_wait [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
     8,985,225 ( 0.01%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/async.c:aio_ctx_check [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
     8,842,416 ( 0.01%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../replay/replay.c:replay_exception [/root/fuzzer/xxfuzzer/qemu-7.2.0/build/libqemu-system-arm.so]
     8,589,508 ( 0.01%)  /root/fuzzer/xxfuzzer/qemu-7.2.0/include/qemu/bitops.h:v7m_update_fpccr
     8,467,376 ( 0.01%)  ./malloc/./malloc/malloc.c:calloc [/usr/lib/x86_64-linux-gnu/libc.so.6]
     8,050,578 ( 0.01%)  ./malloc/./malloc/malloc.c:_int_free [/usr/lib/x86_64-linux-gnu/libc.so.6]

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/aio-posix.c
--------------------------------------------------------------------------------
Ir                 

-- line 48 ----------------------------------------
        .               node->poll_ready = true;
        .               QLIST_INSERT_HEAD(ready_list, node, node_ready);
        .           }
        .           
        .           static AioHandler *find_aio_handler(AioContext *ctx, int fd)
        .           {
        .               AioHandler *node;
        .           
       17 ( 0.00%)      QLIST_FOREACH(node, &ctx->aio_handlers, node) {
        2 ( 0.00%)          if (node->pfd.fd == fd) {
        .                       if (!QLIST_IS_INSERTED(node, node_deleted)) {
        .                           return node;
        .                       }
        .                   }
        .               }
        .           
        .               return NULL;
        .           }
-- line 65 ----------------------------------------
-- line 100 ----------------------------------------
        .           void aio_set_fd_handler(AioContext *ctx,
        .                                   int fd,
        .                                   bool is_external,
        .                                   IOHandler *io_read,
        .                                   IOHandler *io_write,
        .                                   AioPollFn *io_poll,
        .                                   IOHandler *io_poll_ready,
        .                                   void *opaque)
       51 ( 0.00%)  {
        .               AioHandler *node;
        .               AioHandler *new_node = NULL;
        .               bool is_new = false;
        .               bool deleted = false;
        .               int poll_disable_change;
        .           
        6 ( 0.00%)      if (io_poll && !io_poll_ready) {
        6 ( 0.00%)          io_poll = NULL; /* polling only makes sense if there is a handler */
        .               }
        .           
       12 ( 0.00%)      qemu_lockcnt_lock(&ctx->list_lock);
      183 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/lockcnt.c:qemu_lockcnt_lock (3x)
        .           
        .               node = find_aio_handler(ctx, fd);
        .           
        .               /* Are we deleting the fd handler? */
        9 ( 0.00%)      if (!io_read && !io_write && !io_poll) {
        .                   if (node == NULL) {
        .                       qemu_lockcnt_unlock(&ctx->list_lock);
        .                       return;
        .                   }
        .                   /* Clean events in order to unregister fd from the ctx epoll. */
        .                   node->pfd.events = 0;
        .           
        .                   poll_disable_change = -!node->io_poll;
        .               } else {
       12 ( 0.00%)          poll_disable_change = !io_poll - (node && !node->io_poll);
        3 ( 0.00%)          if (node == NULL) {
        .                       is_new = true;
        .                   }
        .                   /* Alloc and insert if it's not already there */
       15 ( 0.00%)          new_node = g_new0(AioHandler, 1);
      810 ( 0.00%)  => ???:0x0000000004e3cc20 (3x)
        .           
        .                   /* Update handler with latest information */
        3 ( 0.00%)          new_node->io_read = io_read;
        3 ( 0.00%)          new_node->io_write = io_write;
        3 ( 0.00%)          new_node->io_poll = io_poll;
        6 ( 0.00%)          new_node->io_poll_ready = io_poll_ready;
        6 ( 0.00%)          new_node->opaque = opaque;
        6 ( 0.00%)          new_node->is_external = is_external;
        .           
        .                   if (is_new) {
        6 ( 0.00%)              new_node->pfd.fd = fd;
        .                   } else {
        .                       new_node->pfd = node->pfd;
        .                   }
       12 ( 0.00%)          g_source_add_poll(&ctx->source, &new_node->pfd);
      824 ( 0.00%)  => ???:0x0000000004e3be60 (3x)
        .           
        9 ( 0.00%)          new_node->pfd.events = (io_read ? G_IO_IN | G_IO_HUP | G_IO_ERR : 0);
       18 ( 0.00%)          new_node->pfd.events |= (io_write ? G_IO_OUT | G_IO_ERR : 0);
        .           
       26 ( 0.00%)          QLIST_INSERT_HEAD_RCU(&ctx->aio_handlers, new_node, node);
        .               }
        .           
        .               /* No need to order poll_disable_cnt writes against other updates;
        .                * the counter is only used to avoid wasting time and latency on
        .                * iterated polling when the system call will be ultimately necessary.
        .                * Changing handlers is a rare event, and a little wasted polling until
        .                * the aio_notify below is not an issue.
        .                */
        9 ( 0.00%)      qatomic_set(&ctx->poll_disable_cnt,
        .                          qatomic_read(&ctx->poll_disable_cnt) + poll_disable_change);
        .           
       12 ( 0.00%)      ctx->fdmon_ops->update(ctx, node, new_node);
        6 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/fdmon-poll.c:fdmon_poll_update (3x)
        6 ( 0.00%)      if (node) {
        .                   deleted = aio_remove_fd_handler(ctx, node);
        .               }
        6 ( 0.00%)      qemu_lockcnt_unlock(&ctx->list_lock);
       42 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/lockcnt.c:qemu_lockcnt_unlock (3x)
        6 ( 0.00%)      aio_notify(ctx);
       21 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/async.c:aio_notify (3x)
        .           
        .               if (deleted) {
        .                   g_free(node);
        .               }
       21 ( 0.00%)  }
        .           
        .           void aio_set_fd_poll(AioContext *ctx, int fd,
        .                                IOHandler *io_poll_begin,
        .                                IOHandler *io_poll_end)
        .           {
        .               AioHandler *node = find_aio_handler(ctx, fd);
        .           
        .               if (!node) {
-- line 189 ----------------------------------------
-- line 195 ----------------------------------------
        .           }
        .           
        .           void aio_set_event_notifier(AioContext *ctx,
        .                                       EventNotifier *notifier,
        .                                       bool is_external,
        .                                       EventNotifierHandler *io_read,
        .                                       AioPollFn *io_poll,
        .                                       EventNotifierHandler *io_poll_ready)
       28 ( 0.00%)  {
       22 ( 0.00%)      aio_set_fd_handler(ctx, event_notifier_get_fd(notifier), is_external,
    1,556 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/aio-posix.c:aio_set_fd_handler (2x)
        6 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/event_notifier-posix.c:event_notifier_get_fd (2x)
        .                                  (IOHandler *)io_read, NULL, io_poll,
        .                                  (IOHandler *)io_poll_ready, notifier);
       16 ( 0.00%)  }
        .           
        .           void aio_set_event_notifier_poll(AioContext *ctx,
        .                                            EventNotifier *notifier,
        .                                            EventNotifierHandler *io_poll_begin,
        .                                            EventNotifierHandler *io_poll_end)
        .           {
        .               aio_set_fd_poll(ctx, event_notifier_get_fd(notifier),
        .                               (IOHandler *)io_poll_begin,
-- line 215 ----------------------------------------
-- line 217 ----------------------------------------
        .           }
        .           
        .           static bool poll_set_started(AioContext *ctx, AioHandlerList *ready_list,
        .                                        bool started)
        .           {
        .               AioHandler *node;
        .               bool progress = false;
        .           
  724,480 ( 0.00%)      if (started == ctx->poll_started) {
        .                   return false;
        .               }
        .           
        .               ctx->poll_started = started;
        .           
        .               qemu_lockcnt_inc(&ctx->list_lock);
        .               QLIST_FOREACH(node, &ctx->poll_aio_handlers, node_poll) {
        .                   IOHandler *fn;
-- line 233 ----------------------------------------
-- line 254 ----------------------------------------
        .               }
        .               qemu_lockcnt_dec(&ctx->list_lock);
        .           
        .               return progress;
        .           }
        .           
        .           
        .           bool aio_prepare(AioContext *ctx)
1,811,200 ( 0.00%)  {
  362,240 ( 0.00%)      AioHandlerList ready_list = QLIST_HEAD_INITIALIZER(ready_list);
        .           
        .               /* Poll mode cannot be used with glib's event loop, disable it. */
        .               poll_set_started(ctx, &ready_list, false);
        .               /* TODO what to do with this list? */
        .           
        .               return false;
2,173,440 ( 0.00%)  }
        .           
        .           bool aio_pending(AioContext *ctx)
1,797,045 ( 0.00%)  {
        .               AioHandler *node;
  718,818 ( 0.00%)      bool result = false;
        .           
        .               /*
        .                * We have to walk very carefully in case aio_set_fd_handler is
        .                * called while we're walking.
        .                */
1,078,227 ( 0.00%)      qemu_lockcnt_inc(&ctx->list_lock);
19,767,495 ( 0.03%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/lockcnt.c:qemu_lockcnt_inc (359,409x)
        .           
3,059,220 ( 0.00%)      QLIST_FOREACH_RCU(node, &ctx->aio_handlers, node) {
        .                   int revents;
        .           
        .                   /* TODO should this check poll ready? */
1,081,056 ( 0.00%)          revents = node->pfd.revents & node->pfd.events;
1,081,056 ( 0.00%)          if (revents & (G_IO_IN | G_IO_HUP | G_IO_ERR) && node->io_read &&
        .                       aio_node_check(ctx, node->is_external)) {
        .                       result = true;
        .                       break;
        .                   }
1,081,056 ( 0.00%)          if (revents & (G_IO_OUT | G_IO_ERR) && node->io_write &&
        .                       aio_node_check(ctx, node->is_external)) {
        .                       result = true;
        .                       break;
        .                   }
        .               }
  718,818 ( 0.00%)      qemu_lockcnt_dec(&ctx->list_lock);
1,078,227 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/lockcnt.c:qemu_lockcnt_dec (359,409x)
        .           
        .               return result;
1,797,045 ( 0.00%)  }
        .           
        .           static void aio_free_deleted_handlers(AioContext *ctx)
        .           {
        .               AioHandler *node;
        .           
   11,332 ( 0.00%)      if (QLIST_EMPTY_RCU(&ctx->deleted_aio_handlers)) {
        .                   return;
        .               }
        .               if (!qemu_lockcnt_dec_if_lock(&ctx->list_lock)) {
        .                   return; /* we are nested, let the parent do the freeing */
        .               }
        .           
        .               while ((node = QLIST_FIRST_RCU(&ctx->deleted_aio_handlers))) {
        .                   QLIST_REMOVE(node, node);
-- line 316 ----------------------------------------
-- line 318 ----------------------------------------
        .                   QLIST_SAFE_REMOVE(node, node_poll);
        .                   g_free(node);
        .               }
        .           
        .               qemu_lockcnt_inc_and_unlock(&ctx->list_lock);
        .           }
        .           
        .           static bool aio_dispatch_handler(AioContext *ctx, AioHandler *node)
   14,160 ( 0.00%)  {
        .               bool progress = false;
        .               bool poll_ready;
        .               int revents;
        .           
    5,664 ( 0.00%)      revents = node->pfd.revents & node->pfd.events;
    5,664 ( 0.00%)      node->pfd.revents = 0;
        .           
    2,832 ( 0.00%)      poll_ready = node->poll_ready;
    2,832 ( 0.00%)      node->poll_ready = false;
        .           
        .               /*
        .                * Start polling AioHandlers when they become ready because activity is
        .                * likely to continue.  Note that starvation is theoretically possible when
        .                * fdmon_supports_polling(), but only until the fd fires for the first
        .                * time.
        .                */
   14,160 ( 0.00%)      if (!QLIST_IS_INSERTED(node, node_deleted) &&
        6 ( 0.00%)          !QLIST_IS_INSERTED(node, node_poll) &&
        .                   node->io_poll) {
        .                   trace_poll_add(ctx, node, node->pfd.fd, revents);
        4 ( 0.00%)          if (ctx->poll_started && node->io_poll_begin) {
        .                       node->io_poll_begin(node->opaque);
        .                   }
       14 ( 0.00%)          QLIST_INSERT_HEAD(&ctx->poll_aio_handlers, node, node_poll);
        .               }
        4 ( 0.00%)      if (!QLIST_IS_INSERTED(node, node_deleted) &&
   11,328 ( 0.00%)          poll_ready && revents == 0 &&
        .                   aio_node_check(ctx, node->is_external) &&
        .                   node->io_poll_ready) {
        .                   node->io_poll_ready(node->opaque);
        .           
        .                   /*
        .                    * Return early since revents was zero. aio_notify() does not count as
        .                    * progress.
        .                    */
        .                   return node->opaque != &ctx->notifier;
        .               }
        .           
    5,664 ( 0.00%)      if (!QLIST_IS_INSERTED(node, node_deleted) &&
        .                   (revents & (G_IO_IN | G_IO_HUP | G_IO_ERR)) &&
        .                   aio_node_check(ctx, node->is_external) &&
        .                   node->io_read) {
        .                   node->io_read(node->opaque);
        .           
        .                   /* aio_notify() does not count as progress */
        .                   if (node->opaque != &ctx->notifier) {
        .                       progress = true;
        .                   }
        .               }
    5,664 ( 0.00%)      if (!QLIST_IS_INSERTED(node, node_deleted) &&
        .                   (revents & (G_IO_OUT | G_IO_ERR)) &&
        .                   aio_node_check(ctx, node->is_external) &&
        .                   node->io_write) {
        .                   node->io_write(node->opaque);
        .                   progress = true;
        .               }
        .           
        .               return progress;
   16,992 ( 0.00%)  }
        .           
        .           /*
        .            * If we have a list of ready handlers then this is more efficient than
        .            * scanning all handlers with aio_dispatch_handlers().
        .            */
        .           static bool aio_dispatch_ready_handlers(AioContext *ctx,
        .                                                   AioHandlerList *ready_list)
        .           {
-- line 393 ----------------------------------------
-- line 403 ----------------------------------------
        .           }
        .           
        .           /* Slower than aio_dispatch_ready_handlers() but only used via glib */
        .           static bool aio_dispatch_handlers(AioContext *ctx)
        .           {
        .               AioHandler *node, *tmp;
        .               bool progress = false;
        .           
   25,484 ( 0.00%)      QLIST_FOREACH_SAFE_RCU(node, &ctx->aio_handlers, node, tmp) {
    5,664 ( 0.00%)          progress = aio_dispatch_handler(ctx, node) || progress;
   84,988 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/aio-posix.c:aio_dispatch_handler (2,832x)
        .               }
        .           
        .               return progress;
        .           }
        .           
        .           void aio_dispatch(AioContext *ctx)
   14,155 ( 0.00%)  {
    8,493 ( 0.00%)      qemu_lockcnt_inc(&ctx->list_lock);
  155,705 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/lockcnt.c:qemu_lockcnt_inc (2,831x)
    5,662 ( 0.00%)      aio_bh_poll(ctx);
  241,221 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/async.c:aio_bh_poll (2,831x)
        .               aio_dispatch_handlers(ctx);
    5,662 ( 0.00%)      aio_free_deleted_handlers(ctx);
   11,324 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/aio-posix.c:aio_free_deleted_handlers (2,831x)
    5,662 ( 0.00%)      qemu_lockcnt_dec(&ctx->list_lock);
    8,493 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/lockcnt.c:qemu_lockcnt_dec (2,831x)
        .           
    5,662 ( 0.00%)      timerlistgroup_run_timers(&ctx->tlg);
  169,860 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:timerlistgroup_run_timers (2,831x)
    8,493 ( 0.00%)  }
        .           
        .           static bool run_poll_handlers_once(AioContext *ctx,
        .                                              AioHandlerList *ready_list,
        .                                              int64_t now,
        .                                              int64_t *timeout)
        .           {
        .               bool progress = false;
        .               AioHandler *node;
-- line 435 ----------------------------------------
-- line 717 ----------------------------------------
        .               qemu_lockcnt_dec(&ctx->list_lock);
        .           
        .               progress |= timerlistgroup_run_timers(&ctx->tlg);
        .           
        .               return progress;
        .           }
        .           
        .           void aio_context_setup(AioContext *ctx)
        2 ( 0.00%)  {
        4 ( 0.00%)      ctx->fdmon_ops = &fdmon_poll_ops;
        2 ( 0.00%)      ctx->epollfd = -1;
        .           
        .               /* Use the fastest fd monitoring implementation if available */
        .               if (fdmon_io_uring_setup(ctx)) {
        .                   return;
        .               }
        .           
        2 ( 0.00%)      fdmon_epoll_setup(ctx);
       36 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/fdmon-epoll.c:fdmon_epoll_setup (2x)
        .           }
        .           
        .           void aio_context_destroy(AioContext *ctx)
        .           {
        .               fdmon_io_uring_destroy(ctx);
        .               fdmon_epoll_disable(ctx);
        .               aio_free_deleted_handlers(ctx);
        .           }
        .           
        .           void aio_context_use_g_source(AioContext *ctx)
        2 ( 0.00%)  {
        .               /*
        .                * Disable io_uring when the glib main loop is used because it doesn't
        .                * support mixed glib/aio_poll() usage. It relies on aio_poll() being
        .                * called regularly so that changes to the monitored file descriptors are
        .                * submitted, otherwise a list of pending fd handlers builds up.
        .                */
        .               fdmon_io_uring_destroy(ctx);
        2 ( 0.00%)      aio_free_deleted_handlers(ctx);
        8 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/aio-posix.c:aio_free_deleted_handlers (2x)
        .           }
        .           
        .           void aio_context_set_poll_params(AioContext *ctx, int64_t max_ns,
        .                                            int64_t grow, int64_t shrink, Error **errp)
        .           {
        .               /* No thread synchronization here, it doesn't matter if an incorrect value
        .                * is used once.
        .                */
-- line 761 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/include/qemu/xxhash.h
--------------------------------------------------------------------------------
Ir                  

-- line 51 ----------------------------------------
         .           static inline uint32_t
         .           qemu_xxhash7(uint64_t ab, uint64_t cd, uint32_t e, uint32_t f, uint32_t g)
         .           {
         .               uint32_t v1 = QEMU_XXHASH_SEED + PRIME32_1 + PRIME32_2;
         .               uint32_t v2 = QEMU_XXHASH_SEED + PRIME32_2;
         .               uint32_t v3 = QEMU_XXHASH_SEED + 0;
         .               uint32_t v4 = QEMU_XXHASH_SEED - PRIME32_1;
         .               uint32_t a = ab;
 5,266,648 ( 0.01%)      uint32_t b = ab >> 32;
         .               uint32_t c = cd;
         .               uint32_t d = cd >> 32;
         .               uint32_t h32;
         .           
10,533,296 ( 0.01%)      v1 += a * PRIME32_2;
         .               v1 = rol32(v1, 13);
 5,266,648 ( 0.01%)      v1 *= PRIME32_1;
         .           
10,533,296 ( 0.01%)      v2 += b * PRIME32_2;
         .               v2 = rol32(v2, 13);
 5,266,648 ( 0.01%)      v2 *= PRIME32_1;
         .           
         .               v3 += c * PRIME32_2;
         .               v3 = rol32(v3, 13);
         .               v3 *= PRIME32_1;
         .           
         .               v4 += d * PRIME32_2;
         .               v4 = rol32(v4, 13);
         .               v4 *= PRIME32_1;
         .           
         .               h32 = rol32(v1, 1) + rol32(v2, 7) + rol32(v3, 12) + rol32(v4, 18);
         .               h32 += 28;
         .           
15,799,944 ( 0.02%)      h32 += e * PRIME32_3;
 5,266,648 ( 0.01%)      h32  = rol32(h32, 17) * PRIME32_4;
         .           
10,533,296 ( 0.01%)      h32 += f * PRIME32_3;
 5,266,648 ( 0.01%)      h32  = rol32(h32, 17) * PRIME32_4;
         .           
10,533,296 ( 0.01%)      h32 += g * PRIME32_3;
 5,266,648 ( 0.01%)      h32  = rol32(h32, 17) * PRIME32_4;
         .           
15,799,944 ( 0.02%)      h32 ^= h32 >> 15;
 5,266,648 ( 0.01%)      h32 *= PRIME32_2;
15,799,944 ( 0.02%)      h32 ^= h32 >> 13;
 5,266,648 ( 0.01%)      h32 *= PRIME32_3;
15,799,944 ( 0.02%)      h32 ^= h32 >> 16;
         .           
         .               return h32;
         .           }
         .           
         .           static inline uint32_t qemu_xxhash2(uint64_t ab)
         .           {
         .               return qemu_xxhash7(ab, 0, 0, 0, 0);
         .           }
-- line 104 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qht.c
--------------------------------------------------------------------------------
Ir                  

-- line 221 ----------------------------------------
         .           { }
         .           
         .           static inline void qht_map_debug__all_locked(struct qht_map *map)
         .           { }
         .           #endif /* QHT_DEBUG */
         .           
         .           static inline size_t qht_elems_to_buckets(size_t n_elems)
         .           {
         6 ( 0.00%)      return pow2ceil(n_elems / QHT_BUCKET_ENTRIES);
         .           }
         .           
         .           static inline void qht_head_init(struct qht_bucket *b)
         .           {
         .               memset(b, 0, sizeof(*b));
         .               qemu_spin_init(&b->lock);
         .               seqlock_init(&b->sequence);
         .           }
         .           
         .           static inline
         .           struct qht_bucket *qht_map_to_bucket(const struct qht_map *map, uint32_t hash)
         .           {
26,333,240 ( 0.04%)      return &map->buckets[hash & (map->n_buckets - 1)];
         .           }
         .           
         .           /* acquire all bucket locks from a map */
         .           static void qht_map_lock_buckets(struct qht_map *map)
         .           {
         .               size_t i;
         .           
         .               for (i = 0; i < map->n_buckets; i++) {
-- line 250 ----------------------------------------
-- line 267 ----------------------------------------
         .           
         .           /*
         .            * Call with at least a bucket lock held.
         .            * @map should be the value read before acquiring the lock (or locks).
         .            */
         .           static inline bool qht_map_is_stale__locked(const struct qht *ht,
         .                                                       const struct qht_map *map)
         .           {
       746 ( 0.00%)      return map != ht->map;
         .           }
         .           
         .           /*
         .            * Grab all bucket locks, and set @pmap after making sure the map isn't stale.
         .            *
         .            * Pairs with qht_map_unlock_buckets(), hence the pass-by-reference.
         .            *
         .            * Note: callers cannot have ht->lock held.
-- line 283 ----------------------------------------
-- line 314 ----------------------------------------
         .            */
         .           static inline
         .           struct qht_bucket *qht_bucket_lock__no_stale(struct qht *ht, uint32_t hash,
         .                                                        struct qht_map **pmap)
         .           {
         .               struct qht_bucket *b;
         .               struct qht_map *map;
         .           
       746 ( 0.00%)      map = qatomic_rcu_read(&ht->map);
         .               b = qht_map_to_bucket(map, hash);
         .           
         .               qemu_spin_lock(&b->lock);
     1,492 ( 0.00%)      if (likely(!qht_map_is_stale__locked(ht, map))) {
         .                   *pmap = map;
         .                   return b;
         .               }
         .               qemu_spin_unlock(&b->lock);
         .           
         .               /* we raced with a resize; acquire ht->lock to see the updated ht->map */
         .               qht_lock(ht);
         .               map = ht->map;
-- line 334 ----------------------------------------
-- line 366 ----------------------------------------
         .               for (i = 0; i < map->n_buckets; i++) {
         .                   qht_chain_destroy(&map->buckets[i]);
         .               }
         .               qemu_vfree(map->buckets);
         .               g_free(map);
         .           }
         .           
         .           static struct qht_map *qht_map_create(size_t n_buckets)
        12 ( 0.00%)  {
         .               struct qht_map *map;
         .               size_t i;
         .           
         6 ( 0.00%)      map = g_malloc(sizeof(*map));
       114 ( 0.00%)  => ???:0x0000000004e3b870 (2x)
         2 ( 0.00%)      map->n_buckets = n_buckets;
         .           
         2 ( 0.00%)      map->n_added_buckets = 0;
         .               map->n_added_buckets_threshold = n_buckets /
         .                   QHT_NR_ADDED_BUCKETS_THRESHOLD_DIV;
         .           
         .               /* let tiny hash tables to at least add one non-head bucket */
         6 ( 0.00%)      if (unlikely(map->n_added_buckets_threshold == 0)) {
         .                   map->n_added_buckets_threshold = 1;
         .               }
         .           
        11 ( 0.00%)      map->buckets = qemu_memalign(QHT_BUCKET_ALIGN,
     2,436 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/memalign.c:qemu_memalign (2x)
         .                                            sizeof(*map->buckets) * n_buckets);
    24,590 ( 0.00%)      for (i = 0; i < n_buckets; i++) {
    32,782 ( 0.00%)          qht_head_init(&map->buckets[i]);
         .               }
         .               return map;
        11 ( 0.00%)  }
         .           
         .           void qht_init(struct qht *ht, qht_cmp_func_t cmp, size_t n_elems,
         .                         unsigned int mode)
        12 ( 0.00%)  {
         .               struct qht_map *map;
         .               size_t n_buckets = qht_elems_to_buckets(n_elems);
         .           
         4 ( 0.00%)      g_assert(cmp);
         2 ( 0.00%)      ht->cmp = cmp;
         2 ( 0.00%)      ht->mode = mode;
         4 ( 0.00%)      qemu_mutex_init(&ht->lock);
        84 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_mutex_init (2x)
         4 ( 0.00%)      map = qht_map_create(n_buckets);
   109,148 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qht.c:qht_map_create (2x)
         2 ( 0.00%)      qatomic_rcu_set(&ht->map, map);
         8 ( 0.00%)  }
         .           
         .           /* call only when there are no readers/writers left */
         .           void qht_destroy(struct qht *ht)
         .           {
         .               qht_map_destroy(ht->map);
         .               memset(ht, 0, sizeof(*ht));
         .           }
         .           
-- line 418 ----------------------------------------
-- line 484 ----------------------------------------
         .           
         .               return !!new;
         .           }
         .           
         .           static inline
         .           void *qht_do_lookup(const struct qht_bucket *head, qht_lookup_func_t func,
         .                               const void *userp, uint32_t hash)
         .           {
 5,265,902 ( 0.01%)      const struct qht_bucket *b = head;
         .               int i;
         .           
         .               do {
20,169,806 ( 0.03%)          for (i = 0; i < QHT_BUCKET_ENTRIES; i++) {
19,073,622 ( 0.03%)              if (qatomic_read(&b->hashes[i]) == hash) {
         .                           /* The pointer is dereferenced before seqlock_read_retry,
         .                            * so (unlike qht_insert__locked) we need to use
         .                            * qatomic_rcu_read here.
         .                            */
 6,194,039 ( 0.01%)                  void *p = qatomic_rcu_read(&b->pointers[i]);
         .           
74,328,468 ( 0.10%)                  if (likely(p) && likely(func(p, userp))) {
129,519,200 ( 0.18%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cpu-exec.c:tb_lookup_cmp (6,194,039x)
         .                               return p;
         .                           }
         .                       }
         .                   }
     1,053 ( 0.00%)          b = qatomic_rcu_read(&b->next);
     2,106 ( 0.00%)      } while (b);
         .           
     2,106 ( 0.00%)      return NULL;
         .           }
         .           
         .           static __attribute__((noinline))
         .           void *qht_lookup__slowpath(const struct qht_bucket *b, qht_lookup_func_t func,
         .                                      const void *userp, uint32_t hash)
         .           {
         .               unsigned int version;
         .               void *ret;
-- line 520 ----------------------------------------
-- line 523 ----------------------------------------
         .                   version = seqlock_read_begin(&b->sequence);
         .                   ret = qht_do_lookup(b, func, userp, hash);
         .               } while (seqlock_read_retry(&b->sequence, version));
         .               return ret;
         .           }
         .           
         .           void *qht_lookup_custom(const struct qht *ht, const void *userp, uint32_t hash,
         .                                   qht_lookup_func_t func)
52,659,020 ( 0.07%)  {
         .               const struct qht_bucket *b;
         .               const struct qht_map *map;
         .               unsigned int version;
         .               void *ret;
         .           
 5,265,902 ( 0.01%)      map = qatomic_rcu_read(&ht->map);
         .               b = qht_map_to_bucket(map, hash);
         .           
         .               version = seqlock_read_begin(&b->sequence);
         .               ret = qht_do_lookup(b, func, userp, hash);
10,531,804 ( 0.01%)      if (likely(!seqlock_read_retry(&b->sequence, version))) {
         .                   return ret;
         .               }
         .               /*
         .                * Removing the do/while from the fastpath gives a 4% perf. increase when
         .                * running a 100%-lookup microbenchmark.
         .                */
         .               return qht_lookup__slowpath(b, func, userp, hash);
47,393,118 ( 0.06%)  }
         .           
         .           void *qht_lookup(const struct qht *ht, const void *userp, uint32_t hash)
         .           {
         .               return qht_lookup_custom(ht, userp, hash, ht->cmp);
         .           }
         .           
         .           /*
         .            * call with head->lock held
         .            * @ht is const since it is only used for ht->cmp()
         .            */
         .           static void *qht_insert__locked(const struct qht *ht, struct qht_map *map,
         .                                           struct qht_bucket *head, void *p, uint32_t hash,
         .                                           bool *needs_resize)
    11,190 ( 0.00%)  {
         .               struct qht_bucket *b = head;
       746 ( 0.00%)      struct qht_bucket *prev = NULL;
         .               struct qht_bucket *new = NULL;
         .               int i;
         .           
         .               do {
     1,025 ( 0.00%)          for (i = 0; i < QHT_BUCKET_ENTRIES; i++) {
     3,356 ( 0.00%)              if (b->pointers[i]) {
       613 ( 0.00%)                  if (unlikely(b->hashes[i] == hash &&
       366 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/tb-maint.c:tb_cmp (61x)
         .                                        ht->cmp(b->pointers[i], p))) {
         .                               return b->pointers[i];
         .                           }
         .                       } else {
         .                           goto found;
         .                       }
         .                   }
         .                   prev = b;
-- line 581 ----------------------------------------
-- line 589 ----------------------------------------
         .               qatomic_inc(&map->n_added_buckets);
         .               if (unlikely(qht_map_needs_resize(map)) && needs_resize) {
         .                   *needs_resize = true;
         .               }
         .           
         .            found:
         .               /* found an empty key: acquire the seqlock and write */
         .               seqlock_write_begin(&head->sequence);
     1,492 ( 0.00%)      if (new) {
         .                   qatomic_rcu_set(&prev->next, b);
         .               }
         .               /* smp_wmb() implicit in seqlock_write_begin.  */
       746 ( 0.00%)      qatomic_set(&b->hashes[i], hash);
       746 ( 0.00%)      qatomic_set(&b->pointers[i], p);
         .               seqlock_write_end(&head->sequence);
       746 ( 0.00%)      return NULL;
     7,460 ( 0.00%)  }
         .           
         .           static __attribute__((noinline)) void qht_grow_maybe(struct qht *ht)
         .           {
         .               struct qht_map *map;
         .           
         .               /*
         .                * If the lock is taken it probably means there's an ongoing resize,
         .                * so bail out.
-- line 613 ----------------------------------------
-- line 621 ----------------------------------------
         .                   struct qht_map *new = qht_map_create(map->n_buckets * 2);
         .           
         .                   qht_do_resize(ht, new);
         .               }
         .               qht_unlock(ht);
         .           }
         .           
         .           bool qht_insert(struct qht *ht, void *p, uint32_t hash, void **existing)
    11,936 ( 0.00%)  {
         .               struct qht_bucket *b;
         .               struct qht_map *map;
       746 ( 0.00%)      bool needs_resize = false;
         .               void *prev;
         .           
         .               /* NULL pointers are not supported */
         .               qht_debug_assert(p);
         .           
         .               b = qht_bucket_lock__no_stale(ht, hash, &map);
     4,476 ( 0.00%)      prev = qht_insert__locked(ht, map, b, p, hash, &needs_resize);
    32,962 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qht.c:qht_insert__locked (746x)
         .               qht_bucket_debug__locked(b);
         .               qemu_spin_unlock(&b->lock);
         .           
     1,492 ( 0.00%)      if (unlikely(needs_resize) && ht->mode & QHT_MODE_AUTO_RESIZE) {
         .                   qht_grow_maybe(ht);
         .               }
     1,492 ( 0.00%)      if (likely(prev == NULL)) {
       746 ( 0.00%)          return true;
         .               }
         .               if (existing) {
         .                   *existing = prev;
         .               }
         .               return false;
     8,952 ( 0.00%)  }
         .           
         .           static inline bool qht_entry_is_last(const struct qht_bucket *b, int pos)
         .           {
         .               if (pos == QHT_BUCKET_ENTRIES - 1) {
         .                   if (b->next == NULL) {
         .                       return true;
         .                   }
         .                   return b->next->pointers[0] == NULL;
-- line 661 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/x86_64-linux-gnu/bits/string_fortified.h
--------------------------------------------------------------------------------
Ir                  

-- line 21 ----------------------------------------
         .           #ifndef _STRING_H
         .           # error "Never use <bits/string_fortified.h> directly; include <string.h> instead."
         .           #endif
         .           
         .           __fortify_function void *
         .           __NTH (memcpy (void *__restrict __dest, const void *__restrict __src,
         .           	       size_t __len))
         .           {
24,553,839 ( 0.03%)    return __builtin___memcpy_chk (__dest, __src, __len,
 1,139,943 ( 0.00%)  => ???:0x0000000004e3b990 (79,996x)
         .           				 __glibc_objsize0 (__dest));
         .           }
         .           
         .           __fortify_function void *
         .           __NTH (memmove (void *__dest, const void *__src, size_t __len))
         .           {
       372 ( 0.00%)    return __builtin___memmove_chk (__dest, __src, __len,
     2,577 ( 0.00%)  => ???:0x0000000004e3cac0 (124x)
         .           				  __glibc_objsize0 (__dest));
         .           }
         .           
         .           #ifdef __USE_GNU
         .           __fortify_function void *
         .           __NTH (mempcpy (void *__restrict __dest, const void *__restrict __src,
         .           		size_t __len))
         .           {
-- line 44 ----------------------------------------
-- line 51 ----------------------------------------
         .           /* The first two tests here help to catch a somewhat common problem
         .              where the second and third parameter are transposed.  This is
         .              especially problematic if the intended fill value is zero.  In this
         .              case no work is done at all.  We detect these problems by referring
         .              non-existing functions.  */
         .           __fortify_function void *
         .           __NTH (memset (void *__dest, int __ch, size_t __len))
         .           {
 1,075,615 ( 0.00%)    return __builtin___memset_chk (__dest, __ch, __len,
    37,283 ( 0.00%)  => ???:0x0000000004e3a930 (1x)
         .           				 __glibc_objsize0 (__dest));
         .           }
         .           
         .           #ifdef __USE_MISC
         .           # include <bits/strings_fortified.h>
         .           
         .           void __explicit_bzero_chk (void *__dest, size_t __len, size_t __destlen)
         .             __THROW __nonnull ((1)) __fortified_attr_access (__write_only__, 1, 2);
-- line 67 ----------------------------------------
-- line 87 ----------------------------------------
         .           }
         .           #endif
         .           
         .           
         .           __fortify_function char *
         .           __NTH (strncpy (char *__restrict __dest, const char *__restrict __src,
         .           		size_t __len))
         .           {
        12 ( 0.00%)    return __builtin___strncpy_chk (__dest, __src, __len,
       172 ( 0.00%)  => ???:0x0000000004e3b320 (4x)
         .           				  __glibc_objsize (__dest));
         .           }
         .           
         .           #ifdef __USE_XOPEN2K8
         .           # if __GNUC_PREREQ (4, 7) || __glibc_clang_prereq (2, 6)
         .           __fortify_function char *
         .           __NTH (stpncpy (char *__dest, const char *__src, size_t __n))
         .           {
-- line 103 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c
--------------------------------------------------------------------------------
Ir                  

-- line 80 ----------------------------------------
         .            * @type: type of clock
         .            *
         .            * Translate a clock type into a pointer to QEMUClock object.
         .            *
         .            * Returns: a pointer to the QEMUClock object
         .            */
         .           static inline QEMUClock *qemu_clock_ptr(QEMUClockType type)
         .           {
        60 ( 0.00%)      return &qemu_clocks[type];
         .           }
         .           
         .           static bool timer_expired_ns(QEMUTimer *timer_head, int64_t current_time)
         .           {
   543,360 ( 0.00%)      return timer_head && (timer_head->expire_time <= current_time);
         .           }
         .           
         .           QEMUTimerList *timerlist_new(QEMUClockType type,
         .                                        QEMUTimerListNotifyCB *cb,
         .                                        void *opaque)
       120 ( 0.00%)  {
         .               QEMUTimerList *timer_list;
         .               QEMUClock *clock = qemu_clock_ptr(type);
         .           
        36 ( 0.00%)      timer_list = g_new0(QEMUTimerList, 1);
     3,204 ( 0.00%)  => ???:0x0000000004e3cc20 (12x)
        36 ( 0.00%)      qemu_event_init(&timer_list->timers_done_ev, true);
        72 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_event_init (12x)
        12 ( 0.00%)      timer_list->clock = clock;
        12 ( 0.00%)      timer_list->notify_cb = cb;
        12 ( 0.00%)      timer_list->notify_opaque = opaque;
        24 ( 0.00%)      qemu_mutex_init(&timer_list->active_timers_lock);
       504 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_mutex_init (12x)
        92 ( 0.00%)      QLIST_INSERT_HEAD(&clock->timerlists, timer_list, list);
         .               return timer_list;
       108 ( 0.00%)  }
         .           
         .           void timerlist_free(QEMUTimerList *timer_list)
         .           {
         .               assert(!timerlist_has_timers(timer_list));
         .               if (timer_list->clock) {
         .                   QLIST_REMOVE(timer_list, list);
         .               }
         .               qemu_mutex_destroy(&timer_list->active_timers_lock);
-- line 119 ----------------------------------------
-- line 120 ----------------------------------------
         .               g_free(timer_list);
         .           }
         .           
         .           static void qemu_clock_init(QEMUClockType type, QEMUTimerListNotifyCB *notify_cb)
         .           {
         .               QEMUClock *clock = qemu_clock_ptr(type);
         .           
         .               /* Assert that the clock of type TYPE has not been initialized yet. */
        12 ( 0.00%)      assert(main_loop_tlg.tl[type] == NULL);
         .           
         4 ( 0.00%)      clock->type = type;
         8 ( 0.00%)      clock->enabled = (type == QEMU_CLOCK_VIRTUAL ? false : true);
         4 ( 0.00%)      QLIST_INIT(&clock->timerlists);
        16 ( 0.00%)      main_loop_tlg.tl[type] = timerlist_new(type, notify_cb, NULL);
     1,428 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:timerlist_new (4x)
         .           }
         .           
         .           bool qemu_clock_use_for_deadline(QEMUClockType type)
 4,324,232 ( 0.01%)  {
30,269,624 ( 0.04%)      return !(icount_enabled() && (type == QEMU_CLOCK_VIRTUAL));
 4,324,232 ( 0.01%)  }
         .           
         .           void qemu_clock_notify(QEMUClockType type)
         2 ( 0.00%)  {
         .               QEMUTimerList *timer_list;
         .               QEMUClock *clock = qemu_clock_ptr(type);
        13 ( 0.00%)      QLIST_FOREACH(timer_list, &clock->timerlists, list) {
         4 ( 0.00%)          timerlist_notify(timer_list);
        71 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:timerlist_notify (2x)
         .               }
         2 ( 0.00%)  }
         .           
         .           /* Disabling the clock will wait for related timerlists to stop
         .            * executing qemu_run_timers.  Thus, this functions should not
         .            * be used from the callback of a timer that is based on @clock.
         .            * Doing so would cause a deadlock.
         .            *
         .            * Caller should hold BQL.
         .            */
         .           void qemu_clock_enable(QEMUClockType type, bool enabled)
         1 ( 0.00%)  {
         .               QEMUClock *clock = qemu_clock_ptr(type);
         .               QEMUTimerList *tl;
         6 ( 0.00%)      bool old = clock->enabled;
         1 ( 0.00%)      clock->enabled = enabled;
         4 ( 0.00%)      if (enabled && !old) {
         1 ( 0.00%)          qemu_clock_notify(type);
        92 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:qemu_clock_notify (1x)
         .               } else if (!enabled && old) {
         .                   QLIST_FOREACH(tl, &clock->timerlists, list) {
         .                       qemu_event_wait(&tl->timers_done_ev);
         .                   }
         .               }
         .           }
         .           
         .           bool timerlist_has_timers(QEMUTimerList *timer_list)
-- line 172 ----------------------------------------
-- line 205 ----------------------------------------
         .           }
         .           
         .           /*
         .            * As above, but return -1 for no deadline, and do not cap to 2^32
         .            * as we know the result is always positive.
         .            */
         .           
         .           int64_t timerlist_deadline_ns(QEMUTimerList *timer_list)
14,399,008 ( 0.02%)  {
         .               int64_t delta;
         .               int64_t expire_time;
         .           
10,799,256 ( 0.01%)      if (!qatomic_read(&timer_list->active_timers)) {
 6,837,264 ( 0.01%)          return -1;
         .               }
         .           
   724,480 ( 0.00%)      if (!timer_list->clock->enabled) {
         .                   return -1;
         .               }
         .           
         .               /* The active timers list may be modified before the caller uses our return
         .                * value but ->notify_cb() is called when the deadline changes.  Therefore
         .                * the caller should notice the change and there is no race condition.
         .                */
   181,120 ( 0.00%)      WITH_QEMU_LOCK_GUARD(&timer_list->active_timers_lock) {
   724,480 ( 0.00%)          if (!timer_list->active_timers) {
         .                       return -1;
         .                   }
   181,120 ( 0.00%)          expire_time = timer_list->active_timers->expire_time;
         .               }
         .           
   905,600 ( 0.00%)      delta = expire_time - qemu_clock_get_ns(timer_list->clock->type);
 5,252,480 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:qemu_clock_get_ns (181,120x)
         .           
   181,120 ( 0.00%)      if (delta <= 0) {
         .                   return 0;
         .               }
         .           
         .               return delta;
17,998,760 ( 0.02%)  }
         .           
         .           /* Calculate the soonest deadline across all timerlists attached
         .            * to the clock. This is used for the icount timeout so we
         .            * ignore whether or not the clock should be used in deadline
         .            * calculations.
         .            */
         .           int64_t qemu_clock_deadline_ns_all(QEMUClockType type, int attr_mask)
         .           {
-- line 251 ----------------------------------------
-- line 292 ----------------------------------------
         .           }
         .           
         .           QEMUTimerList *qemu_clock_get_main_loop_timerlist(QEMUClockType type)
         .           {
         .               return main_loop_tlg.tl[type];
         .           }
         .           
         .           void timerlist_notify(QEMUTimerList *timer_list)
    18,604 ( 0.00%)  {
    55,812 ( 0.00%)      if (timer_list->notify_cb) {
    74,416 ( 0.00%)          timer_list->notify_cb(timer_list->notify_opaque, timer_list->clock->type);
   745,334 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpu-timers.c:qemu_timer_notify_cb (18,603x)
         9 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/async.c:aio_timerlist_notify (1x)
         .               } else {
         .                   qemu_notify_event();
         .               }
         .           }
         .           
         .           /* Transition function to convert a nanosecond timeout to ms
         .            * This is used where a system does not support ppoll
         .            */
         .           int qemu_timeout_ns_to_ms(int64_t ns)
   362,240 ( 0.00%)  {
         .               int64_t ms;
   724,480 ( 0.00%)      if (ns < 0) {
   359,409 ( 0.00%)          return -1;
         .               }
         .           
     2,831 ( 0.00%)      if (!ns) {
     2,831 ( 0.00%)          return 0;
         .               }
         .           
         .               /* Always round up, because it's better to wait too long than to wait too
         .                * little and effectively busy-wait
         .                */
         .               ms = DIV_ROUND_UP(ns, SCALE_MS);
         .           
         .               /* To avoid overflow problems, limit this to 2^31, i.e. approx 25 days */
         .               return MIN(ms, INT32_MAX);
   362,240 ( 0.00%)  }
         .           
         .           
         .           /* qemu implementation of g_poll which uses a nanosecond timeout but is
         .            * otherwise identical to g_poll
         .            */
         .           int qemu_poll_ns(GPollFD *fds, guint nfds, int64_t timeout)
   905,600 ( 0.00%)  {
         .           #ifdef CONFIG_PPOLL
   362,240 ( 0.00%)      if (timeout < 0) {
   181,120 ( 0.00%)          return ppoll((struct pollfd *)fds, nfds, NULL, NULL);
         .               } else {
         .                   struct timespec ts;
 1,448,960 ( 0.00%)          int64_t tvsec = timeout / 1000000000LL;
         .                   /* Avoid possibly overflowing and specifying a negative number of
         .                    * seconds, which would turn a very long timeout into a busy-wait.
         .                    */
   724,480 ( 0.00%)          if (tvsec > (int64_t)INT32_MAX) {
   181,120 ( 0.00%)              tvsec = INT32_MAX;
         .                   }
   181,120 ( 0.00%)          ts.tv_sec = tvsec;
 1,811,200 ( 0.00%)          ts.tv_nsec = timeout % 1000000000LL;
         .                   return ppoll((struct pollfd *)fds, nfds, &ts, NULL);
         .               }
         .           #else
         .               return g_poll(fds, nfds, qemu_timeout_ns_to_ms(timeout));
         .           #endif
   905,600 ( 0.00%)  }
         .           
         .           
         .           void timer_init_full(QEMUTimer *ts,
         .                                QEMUTimerListGroup *timer_list_group, QEMUClockType type,
         .                                int scale, int attributes,
         .                                QEMUTimerCB *cb, void *opaque)
        16 ( 0.00%)  {
        16 ( 0.00%)      if (!timer_list_group) {
        16 ( 0.00%)          timer_list_group = &main_loop_tlg;
         .               }
        24 ( 0.00%)      ts->timer_list = timer_list_group->tl[type];
         8 ( 0.00%)      ts->cb = cb;
        16 ( 0.00%)      ts->opaque = opaque;
         8 ( 0.00%)      ts->scale = scale;
         8 ( 0.00%)      ts->attributes = attributes;
         8 ( 0.00%)      ts->expire_time = -1;
         8 ( 0.00%)  }
         .           
         .           void timer_deinit(QEMUTimer *ts)
         .           {
         .               assert(ts->expire_time == -1);
         .               ts->timer_list = NULL;
         .           }
         .           
         .           static void timer_del_locked(QEMUTimerList *timer_list, QEMUTimer *ts)
         .           {
         .               QEMUTimer **pt, *t;
         .           
    37,203 ( 0.00%)      ts->expire_time = -1;
    74,405 ( 0.00%)      pt = &timer_list->active_timers;
         .               for(;;) {
         .                   t = *pt;
    74,406 ( 0.00%)          if (!t)
         .                       break;
    37,202 ( 0.00%)          if (t == ts) {
    37,202 ( 0.00%)              qatomic_set(pt, t->next);
    18,601 ( 0.00%)              break;
         .                   }
         .                   pt = &t->next;
         .               }
         .           }
         .           
         .           static bool timer_mod_ns_locked(QEMUTimerList *timer_list,
         .                                           QEMUTimer *ts, int64_t expire_time)
         .           {
-- line 401 ----------------------------------------
-- line 405 ----------------------------------------
         .               pt = &timer_list->active_timers;
         .               for (;;) {
         .                   t = *pt;
         .                   if (!timer_expired_ns(t, expire_time)) {
         .                       break;
         .                   }
         .                   pt = &t->next;
         .               }
    74,408 ( 0.00%)      ts->expire_time = MAX(expire_time, 0);
    37,204 ( 0.00%)      ts->next = *pt;
    18,602 ( 0.00%)      qatomic_set(pt, ts);
         .           
         .               return pt == &timer_list->active_timers;
         .           }
         .           
         .           static void timerlist_rearm(QEMUTimerList *timer_list)
         .           {
         .               /* Interrupt execution to force deadline recalculation.  */
    74,408 ( 0.00%)      if (icount_enabled() && timer_list->clock->type == QEMU_CLOCK_VIRTUAL) {
         .                   icount_start_warp_timer();
         .               }
    37,204 ( 0.00%)      timerlist_notify(timer_list);
   894,104 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:timerlist_notify (18,602x)
         .           }
         .           
         .           /* stop a timer, but do not dealloc it */
         .           void timer_del(QEMUTimer *ts)
   111,606 ( 0.00%)  {
    18,601 ( 0.00%)      QEMUTimerList *timer_list = ts->timer_list;
         .           
    37,202 ( 0.00%)      if (timer_list) {
   167,409 ( 0.00%)          qemu_mutex_lock(&timer_list->active_timers_lock);
    37,202 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_mutex_lock_impl (18,601x)
         .                   timer_del_locked(timer_list, ts);
    74,404 ( 0.00%)          qemu_mutex_unlock(&timer_list->active_timers_lock);
    37,202 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_mutex_unlock_impl (18,601x)
         .               }
    93,005 ( 0.00%)  }
         .           
         .           /* modify the current timer so that it will be fired when current_time
         .              >= expire_time. The corresponding callback will be called. */
         .           void timer_mod_ns(QEMUTimer *ts, int64_t expire_time)
   186,020 ( 0.00%)  {
    18,602 ( 0.00%)      QEMUTimerList *timer_list = ts->timer_list;
         .               bool rearm;
         .           
   148,816 ( 0.00%)      qemu_mutex_lock(&timer_list->active_timers_lock);
    37,204 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_mutex_lock_impl (18,602x)
         .               timer_del_locked(timer_list, ts);
         .               rearm = timer_mod_ns_locked(timer_list, ts, expire_time);
    74,408 ( 0.00%)      qemu_mutex_unlock(&timer_list->active_timers_lock);
    37,204 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_mutex_unlock_impl (18,602x)
         .           
         .               if (rearm) {
         .                   timerlist_rearm(timer_list);
         .               }
   130,214 ( 0.00%)  }
         .           
         .           /* modify the current timer so that it will be fired when current_time
         .              >= expire_time or the current deadline, whichever comes earlier.
         .              The corresponding callback will be called. */
         .           void timer_mod_anticipate_ns(QEMUTimer *ts, int64_t expire_time)
         .           {
         .               QEMUTimerList *timer_list = ts->timer_list;
         .               bool rearm;
-- line 464 ----------------------------------------
-- line 474 ----------------------------------------
         .                   }
         .               }
         .               if (rearm) {
         .                   timerlist_rearm(timer_list);
         .               }
         .           }
         .           
         .           void timer_mod(QEMUTimer *ts, int64_t expire_time)
    37,204 ( 0.00%)  {
    55,806 ( 0.00%)      timer_mod_ns(ts, expire_time * ts->scale);
 1,842,806 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:timer_mod_ns (18,602x)
         .           }
         .           
         .           void timer_mod_anticipate(QEMUTimer *ts, int64_t expire_time)
         .           {
         .               timer_mod_anticipate_ns(ts, expire_time * ts->scale);
         .           }
         .           
         .           bool timer_pending(QEMUTimer *ts)
-- line 491 ----------------------------------------
-- line 494 ----------------------------------------
         .           }
         .           
         .           bool timer_expired(QEMUTimer *timer_head, int64_t current_time)
         .           {
         .               return timer_expired_ns(timer_head, current_time * timer_head->scale);
         .           }
         .           
         .           bool timerlist_run_timers(QEMUTimerList *timer_list)
 2,184,764 ( 0.00%)  {
         .               QEMUTimer *ts;
         .               int64_t current_time;
   181,120 ( 0.00%)      bool progress = false;
         .               QEMUTimerCB *cb;
         .               void *opaque;
         .           
 2,207,412 ( 0.00%)      if (!qatomic_read(&timer_list->active_timers)) {
         .                   return false;
         .               }
         .           
   724,480 ( 0.00%)      qemu_event_reset(&timer_list->timers_done_ev);
 1,448,960 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_event_reset (181,120x)
   724,480 ( 0.00%)      if (!timer_list->clock->enabled) {
         .                   goto out;
         .               }
         .           
   905,600 ( 0.00%)      switch (timer_list->clock->type) {
         .               case QEMU_CLOCK_REALTIME:
         .                   break;
         .               default:
         .               case QEMU_CLOCK_VIRTUAL:
         .                   break;
         .               case QEMU_CLOCK_HOST:
         .                   if (!replay_checkpoint(CHECKPOINT_CLOCK_HOST)) {
         .                       goto out;
-- line 526 ----------------------------------------
-- line 538 ----------------------------------------
         .                *
         .                * In rr mode we need "filtered" checkpointing for virtual clock.  The
         .                * checkpoint must be recorded/replayed before processing any non-EXTERNAL timer,
         .                * and that must only be done once since the clock value stays the same. Because
         .                * non-EXTERNAL timers may appear in the timers list while it being processed,
         .                * the checkpoint can be issued at a time until no timers are left and we are
         .                * done".
         .                */
   362,240 ( 0.00%)      current_time = qemu_clock_get_ns(timer_list->clock->type);
 5,252,480 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:qemu_clock_get_ns (181,120x)
 1,448,960 ( 0.00%)      qemu_mutex_lock(&timer_list->active_timers_lock);
   362,240 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_mutex_lock_impl (181,120x)
   724,480 ( 0.00%)      while ((ts = timer_list->active_timers)) {
         .                   if (!timer_expired_ns(ts, current_time)) {
         .                       /* No expired timers left.  The checkpoint can be skipped
         .                        * if no timers fired or they were all external.
         .                        */
         .                       break;
         .                   }
         .                   /* Checkpoint for virtual clock is redundant in cases where
         .                    * it's being triggered with only non-EXTERNAL timers, because
-- line 556 ----------------------------------------
-- line 573 ----------------------------------------
         .           
         .                   /* run the callback (the timer list can be modified) */
         .                   qemu_mutex_unlock(&timer_list->active_timers_lock);
         .                   cb(opaque);
         .                   qemu_mutex_lock(&timer_list->active_timers_lock);
         .           
         .                   progress = true;
         .               }
 1,086,720 ( 0.00%)      qemu_mutex_unlock(&timer_list->active_timers_lock);
   362,240 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_mutex_unlock_impl (181,120x)
         .           
         .           out:
   543,360 ( 0.00%)      qemu_event_set(&timer_list->timers_done_ev);
 2,535,680 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_event_set (181,120x)
         .               return progress;
 2,739,448 ( 0.00%)  }
         .           
         .           bool qemu_clock_run_timers(QEMUClockType type)
   724,480 ( 0.00%)  {
 2,897,920 ( 0.00%)      return timerlist_run_timers(main_loop_tlg.tl[type]);
24,270,080 ( 0.03%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:timerlist_run_timers (724,480x)
         .           }
         .           
         .           void timerlistgroup_init(QEMUTimerListGroup *tlg,
         .                                    QEMUTimerListNotifyCB *cb, void *opaque)
        20 ( 0.00%)  {
         .               QEMUClockType type;
        24 ( 0.00%)      for (type = 0; type < QEMU_CLOCK_MAX; type++) {
        40 ( 0.00%)          tlg->tl[type] = timerlist_new(type, cb, opaque);
     2,864 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:timerlist_new (8x)
         .               }
        12 ( 0.00%)  }
         .           
         .           void timerlistgroup_deinit(QEMUTimerListGroup *tlg)
         .           {
         .               QEMUClockType type;
         .               for (type = 0; type < QEMU_CLOCK_MAX; type++) {
         .                   timerlist_free(tlg->tl[type]);
         .               }
         .           }
         .           
         .           bool timerlistgroup_run_timers(QEMUTimerListGroup *tlg)
    16,986 ( 0.00%)  {
         .               QEMUClockType type;
     2,831 ( 0.00%)      bool progress = false;
    33,972 ( 0.00%)      for (type = 0; type < QEMU_CLOCK_MAX; type++) {
    33,972 ( 0.00%)          progress |= timerlist_run_timers(tlg->tl[type]);
    67,944 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:timerlist_run_timers (11,324x)
         .               }
         .               return progress;
    14,155 ( 0.00%)  }
         .           
         .           int64_t timerlistgroup_deadline_ns(QEMUTimerListGroup *tlg)
 5,399,628 ( 0.01%)  {
   899,938 ( 0.00%)      int64_t deadline = -1;
         .               QEMUClockType type;
10,799,256 ( 0.01%)      for (type = 0; type < QEMU_CLOCK_MAX; type++) {
14,399,008 ( 0.02%)          if (qemu_clock_use_for_deadline(type)) {
32,397,768 ( 0.04%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:qemu_clock_use_for_deadline (3,599,752x)
 7,199,504 ( 0.01%)              deadline = qemu_soonest_timeout(deadline,
60,901,488 ( 0.08%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:timerlist_deadline_ns (3,599,752x)
         .                                                       timerlist_deadline_ns(tlg->tl[type]));
         .                   }
         .               }
         .               return deadline;
 4,499,690 ( 0.01%)  }
         .           
         .           int64_t qemu_clock_get_ns(QEMUClockType type)
 2,285,064 ( 0.00%)  {
 2,285,060 ( 0.00%)      switch (type) {
         .               case QEMU_CLOCK_REALTIME:
         .                   return get_clock();
         .               default:
         .               case QEMU_CLOCK_VIRTUAL:
 1,523,368 ( 0.00%)          return cpus_get_virtual_clock();
 4,189,262 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:cpus_get_virtual_clock (380,842x)
         .               case QEMU_CLOCK_HOST:
         6 ( 0.00%)          return REPLAY_CLOCK(REPLAY_CLOCK_HOST, get_clock_realtime());
         .               case QEMU_CLOCK_VIRTUAL_RT:
         .                   return REPLAY_CLOCK(REPLAY_CLOCK_VIRTUAL_RT, cpu_get_clock());
         .               }
   761,696 ( 0.00%)  }
         .           
         .           void init_clocks(QEMUTimerListNotifyCB *notify_cb)
        10 ( 0.00%)  {
         .               QEMUClockType type;
        16 ( 0.00%)      for (type = 0; type < QEMU_CLOCK_MAX; type++) {
         .                   qemu_clock_init(type, notify_cb);
         .               }
         .           
         .           #ifdef CONFIG_PRCTL_PR_SET_TIMERSLACK
         7 ( 0.00%)      prctl(PR_SET_TIMERSLACK, 1, 0, 0, 0);
        26 ( 0.00%)  => ???:0x0000000004e3c410 (1x)
         .           #endif
         5 ( 0.00%)  }
         .           
         .           uint64_t timer_expire_time_ns(QEMUTimer *ts)
         .           {
         .               return timer_pending(ts) ? ts->expire_time : -1;
         .           }
         .           
         .           bool qemu_clock_run_all_timers(void)
   724,480 ( 0.00%)  {
   181,120 ( 0.00%)      bool progress = false;
         .               QEMUClockType type;
         .           
 2,354,560 ( 0.00%)      for (type = 0; type < QEMU_CLOCK_MAX; type++) {
 2,897,920 ( 0.00%)          if (qemu_clock_use_for_deadline(type)) {
 6,520,320 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:qemu_clock_use_for_deadline (724,480x)
 2,897,920 ( 0.00%)              progress |= qemu_clock_run_timers(type);
27,892,480 ( 0.04%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:qemu_clock_run_timers (724,480x)
         .                   }
         .               }
         .           
         .               return progress;
   905,600 ( 0.00%)  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/include/qemu/range.h
--------------------------------------------------------------------------------
Ir                  

-- line 191 ----------------------------------------
         .               }
         .               range_invariant(range);
         .           }
         .           
         .           /* Get last byte of a range from offset + length.
         .            * Undefined for ranges that wrap around 0. */
         .           static inline uint64_t range_get_last(uint64_t offset, uint64_t len)
         .           {
 9,662,393 ( 0.01%)      return offset + len - 1;
         .           }
         .           
         .           /* Check whether a given range covers a given byte. */
         .           static inline int range_covers_byte(uint64_t offset, uint64_t len,
         .                                               uint64_t byte)
         .           {
40,023,328 ( 0.05%)      return offset <= byte && byte <= range_get_last(offset, len);
         .           }
         .           
         .           /* Check whether 2 given ranges overlap.
         .            * Undefined if ranges that wrap around 0. */
         .           static inline int ranges_overlap(uint64_t first1, uint64_t len1,
         .                                            uint64_t first2, uint64_t len2)
         .           {
         .               uint64_t last1 = range_get_last(first1, len1);
-- line 214 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/cpu-sysemu.c
--------------------------------------------------------------------------------
Ir                  

-- line 63 ----------------------------------------
         .           hwaddr cpu_get_phys_page_debug(CPUState *cpu, vaddr addr)
         .           {
         .               MemTxAttrs attrs = {};
         .           
         .               return cpu_get_phys_page_attrs_debug(cpu, addr, &attrs);
         .           }
         .           
         .           int cpu_asidx_from_attrs(CPUState *cpu, MemTxAttrs attrs)
 9,992,523 ( 0.01%)  {
         .               int ret = 0;
         .           
16,654,205 ( 0.02%)      if (cpu->cc->sysemu_ops->asidx_from_attrs) {
 3,330,841 ( 0.00%)          ret = cpu->cc->sysemu_ops->asidx_from_attrs(cpu, attrs);
16,654,205 ( 0.02%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/cpu.h:arm_asidx_from_attrs (3,330,841x)
13,323,364 ( 0.02%)          assert(ret < cpu->num_ases && ret >= 0);
         .               }
         .               return ret;
 6,661,682 ( 0.01%)  }
         .           
         .           int cpu_write_elf32_qemunote(WriteCoreDumpFunction f, CPUState *cpu,
         .                                        void *opaque)
         .           {
         .               CPUClass *cc = CPU_GET_CLASS(cpu);
         .           
         .               if (!cc->sysemu_ops->write_elf32_qemunote) {
         .                   return 0;
-- line 87 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c
--------------------------------------------------------------------------------
Ir                   

-- line 97 ----------------------------------------
          .            * this is only different in the obscure corner case where guest
          .            * code has manually deactivated an exception and is about
          .            * to fail an exception-return integrity check. The definition
          .            * above is the one from the v8M ARM ARM and is also in line
          .            * with the behaviour documented for the Cortex-M3.
          .            */
          .           static bool nvic_rettobase(NVICState *s)
          .           {
    492,488 ( 0.00%)      int irq, nhand = 0;
          .               bool check_sec = arm_feature(&s->cpu->env, ARM_FEATURE_M_SECURITY);
          .           
158,581,136 ( 0.22%)      for (irq = ARMV7M_EXCP_RESET; irq < s->num_irq; irq++) {
168,430,896 ( 0.23%)          if (s->vectors[irq].active ||
          .                       (check_sec && irq < NVIC_INTERNAL_VECTORS &&
          .                        s->sec_vectors[irq].active)) {
          .                       nhand++;
  1,477,464 ( 0.00%)              if (nhand == 2) {
          .                           return 0;
          .                       }
          .                   }
          .               }
          .           
    984,976 ( 0.00%)      return 1;
          .           }
          .           
          .           /* Return the value of the ISCR ISRPENDING bit:
          .            * 1 if an external interrupt is pending
          .            * 0 if no external interrupt is pending
          .            */
          .           static bool nvic_isrpending(NVICState *s)
          .           {
-- line 127 ----------------------------------------
-- line 144 ----------------------------------------
          .               return false;
          .           }
          .           
          .           static bool exc_is_banked(int exc)
          .           {
          .               /* Return true if this is one of the limited set of exceptions which
          .                * are banked (and thus have state in sec_vectors[])
          .                */
  3,024,640 ( 0.00%)      return exc == ARMV7M_EXCP_HARD ||
          .                   exc == ARMV7M_EXCP_MEM ||
          .                   exc == ARMV7M_EXCP_USAGE ||
          .                   exc == ARMV7M_EXCP_SVC ||
          .                   exc == ARMV7M_EXCP_PENDSV ||
          .                   exc == ARMV7M_EXCP_SYSTICK;
          .           }
          .           
          .           /* Return a mask word which clears the subpriority bits from
          .            * a priority value for an M-profile exception, leaving only
          .            * the group priority.
          .            */
          .           static inline uint32_t nvic_gprio_mask(NVICState *s, bool secure)
          .           {
 11,694,466 ( 0.02%)      return ~0U << (s->prigroup[secure] + 1);
          .           }
          .           
          .           static bool exc_targets_secure(NVICState *s, int exc)
          .           {
          .               /* Return true if this non-banked exception targets Secure state. */
          .               if (!arm_feature(&s->cpu->env, ARM_FEATURE_M_SECURITY)) {
          .                   return false;
          .               }
-- line 174 ----------------------------------------
-- line 200 ----------------------------------------
          .           }
          .           
          .           static int exc_group_prio(NVICState *s, int rawprio, bool targets_secure)
          .           {
          .               /* Return the group priority for this exception, given its raw
          .                * (group-and-subgroup) priority value and whether it is targeting
          .                * secure state or not.
          .                */
    622,736 ( 0.00%)      if (rawprio < 0) {
          .                   return rawprio;
          .               }
    311,368 ( 0.00%)      rawprio &= nvic_gprio_mask(s, targets_secure);
          .               /* AIRCR.PRIS causes us to squash all NS priorities into the
          .                * lower half of the total range
          .                */
    622,736 ( 0.00%)      if (!targets_secure &&
    311,368 ( 0.00%)          (s->cpu->env.v7m.aircr & R_V7M_AIRCR_PRIS_MASK)) {
  1,556,840 ( 0.00%)          rawprio = (rawprio >> 1) + NVIC_NS_PRIO_LIMIT;
          .               }
          .               return rawprio;
          .           }
          .           
          .           /* Recompute vectpending and exception_prio for a CPU which implements
          .            * the Security extension
          .            */
          .           static void nvic_recompute_state_secure(NVICState *s)
-- line 225 ----------------------------------------
-- line 269 ----------------------------------------
          .                       }
          .                       if (vec->active && prio < active_prio) {
          .                           active_prio = prio;
          .                       }
          .                   }
          .               }
          .           
          .               s->vectpending_is_s_banked = pending_is_s_banked;
  1,533,270 ( 0.00%)      s->vectpending = pend_irq;
  1,533,270 ( 0.00%)      s->vectpending_prio = pend_prio;
  1,533,270 ( 0.00%)      s->exception_prio = active_prio;
          .           
          .               trace_nvic_recompute_state_secure(s->vectpending,
          .                                                 s->vectpending_is_s_banked,
          .                                                 s->vectpending_prio,
          .                                                 s->exception_prio);
          .           }
          .           
          .           /* Recompute vectpending and exception_prio */
          .           static void nvic_recompute_state(NVICState *s)
 12,266,160 ( 0.02%)  {
          .               int i;
  1,533,270 ( 0.00%)      int pend_prio = NVIC_NOEXC_PRIO;
  1,533,270 ( 0.00%)      int active_prio = NVIC_NOEXC_PRIO;
  1,533,270 ( 0.00%)      int pend_irq = 0;
          .           
          .               /* In theory we could write one function that handled both
          .                * the "security extension present" and "not present"; however
          .                * the security related changes significantly complicate the
          .                * recomputation just by themselves and mixing both cases together
          .                * would be even worse, so we retain a separate non-secure-only
          .                * version for CPUs which don't implement the security extension.
          .                */
  4,599,810 ( 0.01%)      if (arm_feature(&s->cpu->env, ARM_FEATURE_M_SECURITY)) {
          .                   nvic_recompute_state_secure(s);
          .                   return;
          .               }
          .           
492,179,670 ( 0.67%)      for (i = 1; i < s->num_irq; i++) {
          .                   VecInfo *vec = &s->vectors[i];
          .           
260,544,288 ( 0.36%)          if (vec->enabled && vec->pending && vec->prio < pend_prio) {
          .                       pend_prio = vec->prio;
          .                       pend_irq = i;
          .                   }
243,901,542 ( 0.33%)          if (vec->active && vec->prio < active_prio) {
          .                       active_prio = vec->prio;
          .                   }
          .               }
          .           
  3,066,540 ( 0.00%)      if (active_prio > 0) {
  1,440,260 ( 0.00%)          active_prio &= nvic_gprio_mask(s, false);
          .               }
          .           
  4,525,402 ( 0.01%)      if (pend_prio > 0) {
  1,458,862 ( 0.00%)          pend_prio &= nvic_gprio_mask(s, false);
          .               }
          .           
          .               s->vectpending = pend_irq;
          .               s->vectpending_prio = pend_prio;
          .               s->exception_prio = active_prio;
          .           
          .               trace_nvic_recompute_state(s->vectpending,
          .                                          s->vectpending_prio,
          .                                          s->exception_prio);
 12,266,160 ( 0.02%)  }
          .           
          .           /* Return the current execution priority of the CPU
          .            * (equivalent to the pseudocode ExecutionPriority function).
          .            * This is a value between -2 (NMI priority) and NVIC_NOEXC_PRIO.
          .            */
          .           static inline int nvic_exec_prio(NVICState *s)
 28,744,338 ( 0.04%)  {
  4,106,334 ( 0.01%)      CPUARMState *env = &s->cpu->env;
          .               int running = NVIC_NOEXC_PRIO;
          .           
 12,319,002 ( 0.02%)      if (env->v7m.basepri[M_REG_NS] > 0) {
          .                   running = exc_group_prio(s, env->v7m.basepri[M_REG_NS], M_REG_NS);
          .           	    printf("c%d\n",running);
          .               }
          .           
 12,319,002 ( 0.02%)      if (env->v7m.basepri[M_REG_S] > 0) {
          .                   int basepri = exc_group_prio(s, env->v7m.basepri[M_REG_S], M_REG_S);
          .                   if (running > basepri) {
          .                       running = basepri;
          .           	    printf("d%d\n",running);
          .                   }
          .               }
          .           
 12,319,002 ( 0.02%)      if (env->v7m.primask[M_REG_NS]) {
  9,780,540 ( 0.01%)          if (env->v7m.aircr & R_V7M_AIRCR_PRIS_MASK) {
          .                       if (running > NVIC_NS_PRIO_LIMIT) {
          .                           running = NVIC_NS_PRIO_LIMIT;
          .                       }
          .                   } else {
          .                       running = 0;
          .                   }
          .               }
          .           
          .               if (env->v7m.primask[M_REG_S]) {
 16,425,336 ( 0.02%)          running = 0;
          .               }
          .           
 12,319,002 ( 0.02%)      if (env->v7m.faultmask[M_REG_NS]) {
          .                   if (env->v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK) {
          .                       running = -1;
          .           	    printf("b%d\n",running);
          .                   } else {
          .                       if (env->v7m.aircr & R_V7M_AIRCR_PRIS_MASK) {
          .                           if (running > NVIC_NS_PRIO_LIMIT) {
          .                               running = NVIC_NS_PRIO_LIMIT;
          .                           }
          .                       } else {
          .                           running = 0;
          .                       }
          .                   }
          .               }
          .           
 12,319,002 ( 0.02%)      if (env->v7m.faultmask[M_REG_S]) {
          .                   running = (env->v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK) ? -3 : -1;
          .           	printf("a%d\n",running);
          .               }
          .           
          .               /* consider priority of active handler */
 12,319,002 ( 0.02%)      return  MIN(running, s->exception_prio);
 24,638,004 ( 0.03%)  }
          .           
          .           bool armv7m_nvic_neg_prio_requested(void *opaque, bool secure)
  3,369,129 ( 0.00%)  {
          .               /* Return true if the requested execution priority is negative
          .                * for the specified security state, ie that security state
          .                * has an active NMI or HardFault or has set its FAULTMASK.
          .                * Note that this is not the same as whether the execution
          .                * priority is actually negative (for instance AIRCR.PRIS may
          .                * mean we don't allow FAULTMASK_NS to actually make the execution
          .                * priority negative). Compare pseudocode IsReqExcPriNeg().
          .                */
          .               NVICState *s = opaque;
          .           
 16,845,645 ( 0.02%)      if (s->cpu->env.v7m.faultmask[secure]) {
  3,369,129 ( 0.00%)          return true;
          .               }
          .           
 13,476,516 ( 0.02%)      if (secure ? s->sec_vectors[ARMV7M_EXCP_HARD].active :
          .                   s->vectors[ARMV7M_EXCP_HARD].active) {
          .                   return true;
          .               }
          .           
  6,738,258 ( 0.01%)      if (s->vectors[ARMV7M_EXCP_NMI].active &&
          .                   exc_targets_secure(s, ARMV7M_EXCP_NMI) == secure) {
          .                   return true;
          .               }
          .           
  3,369,129 ( 0.00%)      return false;
  3,369,129 ( 0.00%)  }
          .           
          .           bool armv7m_nvic_can_take_pending_exception(void *opaque)
  6,911,094 ( 0.01%)  {
          .               NVICState *s = opaque;
          .           
  6,911,094 ( 0.01%)      return nvic_exec_prio(s) > nvic_pending_prio(s);
 92,713,668 ( 0.13%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:nvic_exec_prio (2,303,698x)
  4,607,396 ( 0.01%)  }
          .           
          .           int armv7m_nvic_raw_execution_priority(void *opaque)
          .           {
          .               NVICState *s = opaque;
          .           
          .               return s->exception_prio;
          .           }
          .           
          .           /* caller must call nvic_irq_update() after this.
          .            * secure indicates the bank to use for banked exceptions (we assert if
          .            * we are passed secure=true for a non-banked exception).
          .            */
          .           static void set_prio(NVICState *s, unsigned irq, bool secure, uint8_t prio)
    111,612 ( 0.00%)  {
    111,612 ( 0.00%)      assert(irq > ARMV7M_EXCP_NMI); /* only use for configurable prios */
    111,612 ( 0.00%)      assert(irq < s->num_irq);
          .           
    613,866 ( 0.00%)      prio &= MAKE_64BIT_MASK(8 - s->num_prio_bits, s->num_prio_bits);
          .           
    111,612 ( 0.00%)      if (secure) {
          .                   assert(exc_is_banked(irq));
          .                   s->sec_vectors[irq].prio = prio;
          .               } else {
    167,418 ( 0.00%)          s->vectors[irq].prio = prio;
          .               }
          .           
          .               trace_nvic_set_prio(irq, secure, prio);
    111,612 ( 0.00%)  }
          .           
          .           /* Return the current raw priority register value.
          .            * secure indicates the bank to use for banked exceptions (we assert if
          .            * we are passed secure=true for a non-banked exception).
          .            */
          .           static int get_prio(NVICState *s, unsigned irq, bool secure)
          .           {
     37,204 ( 0.00%)      assert(irq > ARMV7M_EXCP_NMI); /* only use for configurable prios */
     37,204 ( 0.00%)      assert(irq < s->num_irq);
          .           
     37,204 ( 0.00%)      if (secure) {
          .                   assert(exc_is_banked(irq));
          .                   return s->sec_vectors[irq].prio;
          .               } else {
     74,408 ( 0.00%)          return s->vectors[irq].prio;
          .               }
          .           }
          .           
          .           /* Recompute state and assert irq line accordingly.
          .            * Must be called after changes to:
          .            *  vec->active, vec->enabled, vec->pending or vec->prio for any vector
          .            *  prigroup
          .            */
          .           static void nvic_irq_update(NVICState *s)
          .           {
          .               int lvl;
          .               int pend_prio;
          .           
  3,066,540 ( 0.00%)      nvic_recompute_state(s);
 38,357,324 ( 0.05%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:nvic_recompute_state (55,806x)
          .               pend_prio = nvic_pending_prio(s);
          .           
          .               /* Raise NVIC output if this IRQ would be taken, except that we
          .                * ignore the effects of the BASEPRI, FAULTMASK and PRIMASK (which
          .                * will be checked for in arm_v7m_cpu_exec_interrupt()); changes
          .                * to those CPU registers don't cause us to recalculate the NVIC
          .                * pending info.
          .                */
  6,133,080 ( 0.01%)      lvl = (pend_prio < s->exception_prio);
          .               trace_nvic_irq_update(s->vectpending, pend_prio, s->exception_prio, lvl);
  3,066,540 ( 0.00%)      qemu_set_irq(s->excpout, lvl);
  3,850,614 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/irq.c:qemu_set_irq (55,806x)
          .           }
          .           
          .           /**
          .            * armv7m_nvic_clear_pending: mark the specified exception as not pending
          .            * @opaque: the NVIC
          .            * @irq: the exception number to mark as not pending
          .            * @secure: false for non-banked exceptions or for the nonsecure
          .            * version of a banked exception, true for the secure version of a banked
-- line 506 ----------------------------------------
-- line 527 ----------------------------------------
          .               if (vec->pending) {
          .                   vec->pending = 0;
          .                   nvic_irq_update(s);
          .               }
          .           }
          .           
          .           static void do_armv7m_nvic_set_pending(void *opaque, int irq, bool secure,
          .                                                  bool derived)
  9,227,024 ( 0.01%)  {
          .               /* Pend an exception, including possibly escalating it to HardFault.
          .                *
          .                * This function handles both "normal" pending of interrupts and
          .                * exceptions, and also derived exceptions (ones which occur as
          .                * a result of trying to take some other exception).
          .                *
          .                * If derived == true, the caller guarantees that we are part way through
          .                * trying to take an exception (but have not yet called
-- line 543 ----------------------------------------
-- line 549 ----------------------------------------
          .                * in the DerivedLateArrival() function.
          .                */
          .           
          .               NVICState *s = (NVICState *)opaque;
          .               bool banked = exc_is_banked(irq);
          .               VecInfo *vec;
          .               bool targets_secure;
          .           
  1,607,712 ( 0.00%)      assert(irq > ARMV7M_EXCP_RESET && irq < s->num_irq);
  1,245,472 ( 0.00%)      assert(!secure || banked);
          .           
  3,085,176 ( 0.00%)      vec = (banked && secure) ? &s->sec_vectors[irq] : &s->vectors[irq];
          .           
    803,856 ( 0.00%)      targets_secure = banked ? secure : exc_targets_secure(s, irq);
          .           
    492,488 ( 0.00%)      trace_nvic_set_pending(irq, secure, targets_secure,
    492,488 ( 0.00%)                             derived, vec->enabled, vec->prio);
          .           
    984,976 ( 0.00%)      if (derived) {
          .                   /* Derived exceptions are always synchronous. */
          .                   assert(irq >= ARMV7M_EXCP_HARD && irq < ARMV7M_EXCP_PENDSV);
          .           
          .                   if (irq == ARMV7M_EXCP_DEBUG &&
          .                       exc_group_prio(s, vec->prio, secure) >= nvic_exec_prio(s)) {
          .                       /* DebugMonitorFault, but its priority is lower than the
          .                        * preempted exception priority: just ignore it.
          .                        */
-- line 575 ----------------------------------------
-- line 596 ----------------------------------------
          .                   /* We now continue with the same code as for a normal pending
          .                    * exception, which will cause us to pend the derived exception.
          .                    * We'll then take either the original or the derived exception
          .                    * based on which is higher priority by the usual mechanism
          .                    * for selecting the highest priority pending interrupt.
          .                    */
          .               }
          .           
    984,976 ( 0.00%)      if (irq >= ARMV7M_EXCP_HARD && irq < ARMV7M_EXCP_PENDSV) {
          .                   /* If a synchronous exception is pending then it may be
          .                    * escalated to HardFault if:
          .                    *  * it is equal or lower priority to current execution
          .                    *  * it is disabled
          .                    * (ie we need to take it immediately but we can't do so).
          .                    * Asynchronous exceptions (and interrupts) simply remain pending.
          .                    *
          .                    * For QEMU, we don't have any imprecise (asynchronous) faults,
-- line 612 ----------------------------------------
-- line 617 ----------------------------------------
          .                    * but we don't currently implement any Debug exceptions other
          .                    * than those that result from BKPT, so we treat all debug exceptions
          .                    * as needing escalation.
          .                    *
          .                    * This all means we can identify whether to escalate based only on
          .                    * the exception number and don't (yet) need the caller to explicitly
          .                    * tell us whether this exception is synchronous or not.
          .                    */
    934,104 ( 0.00%)          int running = nvic_exec_prio(s);
 11,209,248 ( 0.02%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:nvic_exec_prio (311,368x)
          .                   bool escalate = false;
    934,104 ( 0.00%)          if (exc_group_prio(s, vec->prio, secure) >= running) {
          .                       trace_nvic_escalate_prio(irq, vec->prio, running);
          .                       escalate = true;
    622,736 ( 0.00%)          } else if (!vec->enabled) {
          .                       trace_nvic_escalate_disabled(irq);
          .                       escalate = true;
          .                   }
          .                   if (escalate) {
          .           
          .                       /* We need to escalate this exception to a synchronous HardFault.
          .                        * If BFHFNMINS is set then we escalate to the banked HF for
          .                        * the target security state of the original exception; otherwise
-- line 638 ----------------------------------------
-- line 657 ----------------------------------------
          .                                     "(current priority %d)\n", irq, running);
          .                       }
          .           
          .                       /* HF may be banked but there is only one shared HFSR */
          .                       s->cpu->env.v7m.hfsr |= R_V7M_HFSR_FORCED_MASK;
          .                   }
          .               }
          .           
    984,976 ( 0.00%)      if (!vec->pending) {
    492,488 ( 0.00%)          vec->pending = 1;
          .                   nvic_irq_update(s);
          .               }
  3,447,416 ( 0.00%)  }
          .           
          .           void armv7m_nvic_set_pending(void *opaque, int irq, bool secure)
    492,488 ( 0.00%)  {
  1,477,464 ( 0.00%)      do_armv7m_nvic_set_pending(opaque, irq, secure, false);
408,519,288 ( 0.56%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:do_armv7m_nvic_set_pending (492,488x)
          .           }
          .           
          .           void armv7m_nvic_set_pending_derived(void *opaque, int irq, bool secure)
          .           {
          .               do_armv7m_nvic_set_pending(opaque, irq, secure, true);
          .           }
          .           
          .           void armv7m_nvic_set_pending_lazyfp(void *opaque, int irq, bool secure)
-- line 681 ----------------------------------------
-- line 771 ----------------------------------------
          .                    * returns the right answer.
          .                    */
          .                   nvic_recompute_state(s);
          .               }
          .           }
          .           
          .           /* Make pending IRQ active.  */
          .           void armv7m_nvic_acknowledge_irq(void *opaque)
  2,462,440 ( 0.00%)  {
          .               NVICState *s = (NVICState *)opaque;
    984,976 ( 0.00%)      CPUARMState *env = &s->cpu->env;
    492,488 ( 0.00%)      const int pending = s->vectpending;
    492,488 ( 0.00%)      const int running = nvic_exec_prio(s);
 17,729,568 ( 0.02%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:nvic_exec_prio (492,488x)
          .               VecInfo *vec;
          .           
  1,969,952 ( 0.00%)      assert(pending > ARMV7M_EXCP_RESET && pending < s->num_irq);
          .           
  1,969,952 ( 0.00%)      if (s->vectpending_is_s_banked) {
          .                   vec = &s->sec_vectors[pending];
          .               } else {
    492,488 ( 0.00%)          vec = &s->vectors[pending];
          .               }
          .           
    984,976 ( 0.00%)      assert(vec->enabled);
    984,976 ( 0.00%)      assert(vec->pending);
          .           
    984,976 ( 0.00%)      assert(s->vectpending_prio < running);
          .           
          .               trace_nvic_acknowledge_irq(pending, s->vectpending_prio);
          .           
          .               vec->active = 1;
    984,976 ( 0.00%)      vec->pending = 0;
          .           
  1,477,464 ( 0.00%)      write_v7m_exception(env, s->vectpending);
  6,940,872 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:write_v7m_exception (492,488x)
          .           
          .               nvic_irq_update(s);
  1,477,464 ( 0.00%)  }
          .           
          .           static bool vectpending_targets_secure(NVICState *s)
          .           {
          .               /* Return true if s->vectpending targets Secure state */
  2,462,440 ( 0.00%)      if (s->vectpending_is_s_banked) {
          .                   return true;
          .               }
  2,462,440 ( 0.00%)      return !exc_is_banked(s->vectpending) &&
          .                   exc_targets_secure(s, s->vectpending);
          .           }
          .           
          .           void armv7m_nvic_get_pending_irq_info(void *opaque,
          .                                                 int *pirq, bool *ptargets_secure)
  1,969,952 ( 0.00%)  {
          .               NVICState *s = (NVICState *)opaque;
    492,488 ( 0.00%)      const int pending = s->vectpending;
          .               bool targets_secure;
          .           
  1,969,952 ( 0.00%)      assert(pending > ARMV7M_EXCP_RESET && pending < s->num_irq);
          .           
          .               targets_secure = vectpending_targets_secure(s);
          .           
          .               trace_nvic_get_pending_irq_info(pending, targets_secure);
          .           
    492,488 ( 0.00%)      *ptargets_secure = targets_secure;
    492,488 ( 0.00%)      *pirq = pending;
  1,969,952 ( 0.00%)  }
          .           
          .           int armv7m_nvic_complete_irq(void *opaque, int irq, bool secure)
  2,954,928 ( 0.00%)  {
          .               NVICState *s = (NVICState *)opaque;
          .               VecInfo *vec = NULL;
          .               int ret = 0;
          .           
  3,939,904 ( 0.01%)      assert(irq > ARMV7M_EXCP_RESET && irq < s->num_irq);
          .           
          .               trace_nvic_complete_irq(irq, secure);
          .           
  1,969,952 ( 0.00%)      if (secure && exc_is_banked(irq)) {
          .                   vec = &s->sec_vectors[irq];
          .               } else {
    492,488 ( 0.00%)          vec = &s->vectors[irq];
          .               }
          .           
          .               /*
          .                * Identify illegal exception return cases. We can't immediately
          .                * return at this point because we still need to deactivate
          .                * (either this exception or NMI/HardFault) first.
          .                */
  2,462,440 ( 0.00%)      if (!exc_is_banked(irq) && exc_targets_secure(s, irq) != secure) {
          .                   /*
          .                    * Return from a configurable exception targeting the opposite
          .                    * security state from the one we're trying to complete it for.
          .                    * Clear vec because it's not really the VecInfo for this
          .                    * (irq, secstate) so we mustn't deactivate it.
          .                    */
          .                   ret = -1;
          .                   vec = NULL;
    984,976 ( 0.00%)      } else if (!vec->active) {
          .                   /* Return from an inactive interrupt */
    492,488 ( 0.00%)          ret = -1;
          .               } else {
          .                   /* Legal return, we will return the RETTOBASE bit value to the caller */
  1,477,464 ( 0.00%)          ret = nvic_rettobase(s);
331,936,912 ( 0.46%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/target/arm/cpu.h:nvic_rettobase (492,488x)
          .               }
          .           
          .               /*
          .                * For negative priorities, v8M will forcibly deactivate the appropriate
          .                * NMI or HardFault regardless of what interrupt we're being asked to
          .                * deactivate (compare the DeActivate() pseudocode). This is a guard
          .                * against software returning from NMI or HardFault with a corrupted
          .                * IPSR and leaving the CPU in a negative-priority state.
          .                * v7M does not do this, but simply deactivates the requested interrupt.
          .                */
    984,976 ( 0.00%)      if (arm_feature(&s->cpu->env, ARM_FEATURE_V8)) {
          .                   switch (armv7m_nvic_raw_execution_priority(s)) {
          .                   case -1:
          .                       if (s->cpu->env.v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK) {
          .                           vec = &s->vectors[ARMV7M_EXCP_HARD];
          .                       } else {
          .                           vec = &s->sec_vectors[ARMV7M_EXCP_HARD];
          .                       }
          .                       break;
-- line 890 ----------------------------------------
-- line 898 ----------------------------------------
          .                       break;
          .                   }
          .               }
          .           
          .               if (!vec) {
          .                   return ret;
          .               }
          .           
    492,488 ( 0.00%)      vec->active = 0;
    984,976 ( 0.00%)      if (vec->level) {
          .                   /* Re-pend the exception if it's still held high; only
          .                    * happens for extenal IRQs
          .                    */
          .                   assert(irq >= NVIC_FIRST_IRQ);
          .                   vec->pending = 1;
          .               }
          .           
          .               nvic_irq_update(s);
          .           
          .               return ret;
  3,447,416 ( 0.00%)  }
          .           
          .           bool armv7m_nvic_get_ready_status(void *opaque, int irq, bool secure)
 16,779,504 ( 0.02%)  {
          .               /*
          .                * Return whether an exception is "ready", i.e. it is enabled and is
          .                * configured at a priority which would allow it to interrupt the
          .                * current execution priority.
          .                *
          .                * irq and secure have the same semantics as for armv7m_nvic_set_pending():
          .                * for non-banked exceptions secure is always false; for banked exceptions
          .                * it indicates which of the exceptions is required.
          .                */
          .               NVICState *s = (NVICState *)opaque;
          .               bool banked = exc_is_banked(irq);
          .               VecInfo *vec;
  1,997,560 ( 0.00%)      int running = nvic_exec_prio(s);
 35,956,080 ( 0.05%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:nvic_exec_prio (998,780x)
          .           
  3,995,120 ( 0.01%)      assert(irq > ARMV7M_EXCP_RESET && irq < s->num_irq);
  1,997,560 ( 0.00%)      assert(!secure || banked);
          .           
          .               /*
          .                * HardFault is an odd special case: we always check against -1,
          .                * even if we're secure and HardFault has priority -3; we never
          .                * need to check for enabled state.
          .                */
  1,997,560 ( 0.00%)      if (irq == ARMV7M_EXCP_HARD) {
    599,268 ( 0.00%)          return running > -1;
          .               }
          .           
  6,791,704 ( 0.01%)      vec = (banked && secure) ? &s->sec_vectors[irq] : &s->vectors[irq];
          .           
  2,397,072 ( 0.00%)      return vec->enabled &&
          .                   exc_group_prio(s, vec->prio, secure) < running;
  6,991,460 ( 0.01%)  }
          .           
          .           /* callback when external interrupt line is changed */
          .           static void set_irq_level(void *opaque, int n, int level)
          .           {
          .               NVICState *s = opaque;
          .               VecInfo *vec;
          .           
          .               n += NVIC_FIRST_IRQ;
-- line 960 ----------------------------------------
-- line 994 ----------------------------------------
          .                */
          .               if (level) {
          .                   armv7m_nvic_set_pending(s, ARMV7M_EXCP_NMI, false);
          .               }
          .           }
          .           
          .           static uint32_t nvic_readl(NVICState *s, uint32_t offset, MemTxAttrs attrs)
          .           {
     75,806 ( 0.00%)      ARMCPU *cpu = s->cpu;
          .               uint32_t val;
          .           
    703,652 ( 0.00%)      switch (offset) {
          .               case 4: /* Interrupt Control Type.  */
          .                   if (!arm_feature(&cpu->env, ARM_FEATURE_V7)) {
          .                       goto bad_offset;
          .                   }
          .                   return ((s->num_irq - NVIC_FIRST_IRQ) / 32) - 1;
          .               case 0xc: /* CPPWR */
          .                   if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {
          .                       goto bad_offset;
-- line 1013 ----------------------------------------
-- line 1090 ----------------------------------------
          .                   if ((attrs.secure || (cpu->env.v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK))
          .                       && s->vectors[ARMV7M_EXCP_NMI].pending) {
          .                       val |= (1 << 31);
          .                   }
          .                   /* ISRPREEMPT: RES0 when halting debug not implemented */
          .                   /* STTNS: RES0 for the Main Extension */
          .                   return val;
          .               case 0xd08: /* Vector Table Offset.  */
     37,204 ( 0.00%)          return cpu->env.v7m.vecbase[attrs.secure];
          .               case 0xd0c: /* Application Interrupt/Reset Control (AIRCR) */
     74,408 ( 0.00%)          val = 0xfa050000 | (s->prigroup[attrs.secure] << 8);
     37,204 ( 0.00%)          if (attrs.secure) {
          .                       /* s->aircr stores PRIS, BFHFNMINS, SYSRESETREQS */
          .                       val |= cpu->env.v7m.aircr;
          .                   } else {
     37,204 ( 0.00%)              if (arm_feature(&cpu->env, ARM_FEATURE_V8)) {
          .                           /* BFHFNMINS is R/O from NS; other bits are RAZ/WI. If
          .                            * security isn't supported then BFHFNMINS is RAO (and
          .                            * the bit in env.v7m.aircr is always set).
          .                            */
          .                           val |= cpu->env.v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK;
          .                       }
          .                   }
          .                   return val;
-- line 1113 ----------------------------------------
-- line 1348 ----------------------------------------
          .               case 0xd80: /* CSSIDR */
          .               {
          .                   int idx = cpu->env.v7m.csselr[attrs.secure] & R_V7M_CSSELR_INDEX_MASK;
          .                   return cpu->ccsidr[idx];
          .               }
          .               case 0xd84: /* CSSELR */
          .                   return cpu->env.v7m.csselr[attrs.secure];
          .               case 0xd88: /* CPACR */
     60,000 ( 0.00%)          if (!cpu_isar_feature(aa32_vfp_simd, cpu)) {
          .                       return 0;
          .                   }
     40,000 ( 0.00%)          return cpu->env.v7m.cpacr[attrs.secure];
          .               case 0xd8c: /* NSACR */
          .                   if (!attrs.secure || !cpu_isar_feature(aa32_vfp_simd, cpu)) {
          .                       return 0;
          .                   }
          .                   return cpu->env.v7m.nsacr;
          .               /* TODO: Implement debug registers.  */
          .               case 0xd90: /* MPU_TYPE */
          .                   /* Unified MPU; if the MPU is not present this value is zero */
-- line 1367 ----------------------------------------
-- line 1562 ----------------------------------------
          .               }
          .           }
          .           
          .           static void nvic_writel(NVICState *s, uint32_t offset, uint32_t value,
          .                                   MemTxAttrs attrs)
          .           {
          .               ARMCPU *cpu = s->cpu;
          .           
    363,224 ( 0.00%)      switch (offset) {
          .               case 0xc: /* CPPWR */
          .                   if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {
          .                       goto bad_offset;
          .                   }
          .                   /* Make the IMPDEF choice to RAZ/WI this. */
          .                   break;
          .               case 0x380 ... 0x3bf: /* NVIC_ITNS<n> */
          .               {
-- line 1578 ----------------------------------------
-- line 1608 ----------------------------------------
          .                   }
          .                   if (value & (1 << 26)) {
          .                       armv7m_nvic_set_pending(s, ARMV7M_EXCP_SYSTICK, attrs.secure);
          .                   } else if (value & (1 << 25)) {
          .                       armv7m_nvic_clear_pending(s, ARMV7M_EXCP_SYSTICK, attrs.secure);
          .                   }
          .                   break;
          .               case 0xd08: /* Vector Table Offset.  */
     55,806 ( 0.00%)          cpu->env.v7m.vecbase[attrs.secure] = value & 0xffffff80;
     18,602 ( 0.00%)          break;
          .               case 0xd0c: /* Application Interrupt/Reset Control (AIRCR) */
          .                   if ((value >> R_V7M_AIRCR_VECTKEY_SHIFT) == 0x05fa) {
          .                       if (value & R_V7M_AIRCR_SYSRESETREQ_MASK) {
          .                           if (attrs.secure ||
          .                               !(cpu->env.v7m.aircr & R_V7M_AIRCR_SYSRESETREQS_MASK)) {
          .                               signal_sysresetreq(s);
          .                           }
          .                       }
-- line 1625 ----------------------------------------
-- line 1821 ----------------------------------------
          .                                 "NVIC: Aux fault status registers unimplemented\n");
          .                   break;
          .               case 0xd84: /* CSSELR */
          .                   if (!arm_v7m_csselr_razwi(cpu)) {
          .                       cpu->env.v7m.csselr[attrs.secure] = value & R_V7M_CSSELR_INDEX_MASK;
          .                   }
          .                   break;
          .               case 0xd88: /* CPACR */
     40,000 ( 0.00%)          if (cpu_isar_feature(aa32_vfp_simd, cpu)) {
          .                       /* We implement only the Floating Point extension's CP10/CP11 */
     80,000 ( 0.00%)              cpu->env.v7m.cpacr[attrs.secure] = value & (0xf << 20);
          .                   }
          .                   break;
          .               case 0xd8c: /* NSACR */
          .                   if (attrs.secure && cpu_isar_feature(aa32_vfp_simd, cpu)) {
          .                       /* We implement only the Floating Point extension's CP10/CP11 */
          .                       cpu->env.v7m.nsacr = value & (3 << 10);
          .                   }
          .                   break;
-- line 1839 ----------------------------------------
-- line 2166 ----------------------------------------
          .           static bool nvic_user_access_ok(NVICState *s, hwaddr offset, MemTxAttrs attrs)
          .           {
          .               /* Return true if unprivileged access to this register is permitted. */
          .               switch (offset) {
          .               case 0xf00: /* STIR: accessible only if CCR.USERSETMPEND permits */
          .                   /* For access via STIR_NS it is the NS CCR.USERSETMPEND that
          .                    * controls access even though the CPU is in Secure state (I_QDKX).
          .                    */
     57,204 ( 0.00%)          return s->cpu->env.v7m.ccr[attrs.secure] & R_V7M_CCR_USERSETMPEND_MASK;
          .               default:
          .                   /* All other user accesses cause a BusFault unconditionally */
          .                   return false;
          .               }
          .           }
          .           
          .           static int shpr_bank(NVICState *s, int exc, MemTxAttrs attrs)
          .           {
          .               /* Behaviour for the SHPR register field for this exception:
          .                * return M_REG_NS to use the nonsecure vector (including for
          .                * non-banked exceptions), M_REG_S for the secure version of
          .                * a banked exception, and -1 if this field should RAZ/WI.
          .                */
    520,856 ( 0.00%)      switch (exc) {
          .               case ARMV7M_EXCP_MEM:
          .               case ARMV7M_EXCP_USAGE:
          .               case ARMV7M_EXCP_SVC:
          .               case ARMV7M_EXCP_PENDSV:
          .               case ARMV7M_EXCP_SYSTICK:
          .                   /* Banked exceptions */
    297,632 ( 0.00%)          return attrs.secure;
          .               case ARMV7M_EXCP_BUS:
          .                   /* Not banked, RAZ/WI from nonsecure if BFHFNMINS is zero */
          .                   if (!attrs.secure &&
          .                       !(s->cpu->env.v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK)) {
          .                       return -1;
          .                   }
          .                   return M_REG_NS;
          .               case ARMV7M_EXCP_SECURE:
-- line 2203 ----------------------------------------
-- line 2217 ----------------------------------------
          .                   /* Not reachable due to decode of SHPR register addresses */
          .                   g_assert_not_reached();
          .               }
          .           }
          .           
          .           static MemTxResult nvic_sysreg_read(void *opaque, hwaddr addr,
          .                                               uint64_t *data, unsigned size,
          .                                               MemTxAttrs attrs)
  1,416,120 ( 0.00%)  {
          .               NVICState *s = (NVICState *)opaque;
          .               uint32_t offset = addr;
          .               unsigned i, startvec, end;
          .               uint32_t val;
          .           
    188,816 ( 0.00%)      if (attrs.user && !nvic_user_access_ok(s, addr, attrs)) {
          .                   /* Generate BusFault for unprivileged accesses */
          .                   return MEMTX_ERROR;
          .               }
          .           
    924,080 ( 0.00%)      switch (offset) {
          .               /* reads of set and clear both return the status */
          .               case 0x100 ... 0x13f: /* NVIC Set enable */
          .                   offset += 0x80;
          .                   /* fall through */
          .               case 0x180 ... 0x1bf: /* NVIC Clear enable */
          .                   val = 0;
          .                   startvec = 8 * (offset - 0x180) + NVIC_FIRST_IRQ; /* vector # */
          .           
-- line 2244 ----------------------------------------
-- line 2291 ----------------------------------------
          .               case 0xd18 ... 0xd1b: /* System Handler Priority (SHPR1) */
          .                   if (!arm_feature(&s->cpu->env, ARM_FEATURE_M_MAIN)) {
          .                       val = 0;
          .                       break;
          .                   }
          .                   /* fall through */
          .               case 0xd1c ... 0xd23: /* System Handler Priority (SHPR2, SHPR3) */
          .                   val = 0;
    241,826 ( 0.00%)          for (i = 0; i < size; i++) {
          .                       unsigned hdlidx = (offset - 0xd14) + i;
     74,408 ( 0.00%)              int sbank = shpr_bank(s, hdlidx, attrs);
    204,622 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:shpr_bank (18,602x)
          .           
     37,204 ( 0.00%)              if (sbank < 0) {
          .                           continue;
          .                       }
          .                       val = deposit32(val, i * 8, 8, get_prio(s, hdlidx, sbank));
          .                   }
          .                   break;
          .               case 0xd28 ... 0xd2b: /* Configurable Fault Status (CFSR) */
          .                   if (!arm_feature(&s->cpu->env, ARM_FEATURE_M_MAIN)) {
          .                       val = 0;
-- line 2311 ----------------------------------------
-- line 2328 ----------------------------------------
          .               case 0xfe0 ... 0xfff: /* ID.  */
          .                   if (offset & 3) {
          .                       val = 0;
          .                   } else {
          .                       val = nvic_id[(offset - 0xfe0) >> 2];
          .                   }
          .                   break;
          .               default:
    171,612 ( 0.00%)          if (size == 4) {
          .                       val = nvic_readl(s, offset, attrs);
          .                   } else {
          .                       qemu_log_mask(LOG_GUEST_ERROR,
          .                                     "NVIC: Bad read of size %d at offset 0x%x\n",
          .                                     size, offset);
          .                       val = 0;
          .                   }
          .               }
          .           
          .               trace_nvic_sysreg_read(addr, val, size);
    246,020 ( 0.00%)      *data = val;
    188,816 ( 0.00%)      return MEMTX_OK;
  1,038,488 ( 0.00%)  }
          .           
          .           static MemTxResult nvic_sysreg_write(void *opaque, hwaddr addr,
          .                                                uint64_t value, unsigned size,
          .                                                MemTxAttrs attrs)
  1,695,150 ( 0.00%)  {
          .               NVICState *s = (NVICState *)opaque;
          .               uint32_t offset = addr;
          .               unsigned i, startvec, end;
          .               unsigned setval = 0;
          .           
          .               trace_nvic_sysreg_write(addr, value, size);
          .           
    226,020 ( 0.00%)      if (attrs.user && !nvic_user_access_ok(s, addr, attrs)) {
          .                   /* Generate BusFault for unprivileged accesses */
          .                   return MEMTX_ERROR;
          .               }
          .           
    882,682 ( 0.00%)      switch (offset) {
          .               case 0x100 ... 0x13f: /* NVIC Set enable */
          .                   offset += 0x80;
          .                   setval = 1;
          .                   /* fall through */
          .               case 0x180 ... 0x1bf: /* NVIC Clear enable */
          .                   startvec = 8 * (offset - 0x180) + NVIC_FIRST_IRQ;
          .           
          .                   for (i = 0, end = size * 8; i < end && startvec + i < s->num_irq; i++) {
-- line 2375 ----------------------------------------
-- line 2385 ----------------------------------------
          .                    * is not needed since IRQs are never escalated
          .                    */
          .                   offset += 0x80;
          .                   setval = 1;
          .                   /* fall through */
          .               case 0x280 ... 0x2bf: /* NVIC Clear pend */
          .                   startvec = 8 * (offset - 0x280) + NVIC_FIRST_IRQ; /* vector # */
          .           
     20,000 ( 0.00%)          for (i = 0, end = size * 8; i < end && startvec + i < s->num_irq; i++) {
          .                       /*
          .                        * Note that if the input line is still held high and the interrupt
          .                        * is not active then rule R_CVJS requires that the Pending state
          .                        * remains set; in that case we mustn't let it be cleared.
          .                        */
          .                       if (value & (1 << i) &&
          .                           (attrs.secure || s->itns[startvec + i]) &&
          .                           !(setval == 0 && s->vectors[startvec + i].level &&
-- line 2401 ----------------------------------------
-- line 2418 ----------------------------------------
          .                   nvic_irq_update(s);
          .                   goto exit_ok;
          .               case 0xd18 ... 0xd1b: /* System Handler Priority (SHPR1) */
          .                   if (!arm_feature(&s->cpu->env, ARM_FEATURE_M_MAIN)) {
          .                       goto exit_ok;
          .                   }
          .                   /* fall through */
          .               case 0xd1c ... 0xd23: /* System Handler Priority (SHPR2, SHPR3) */
    279,030 ( 0.00%)          for (i = 0; i < size; i++) {
     55,806 ( 0.00%)              unsigned hdlidx = (offset - 0xd14) + i;
    111,612 ( 0.00%)              int newprio = extract32(value, i * 8, 8);
    558,060 ( 0.00%)              int sbank = shpr_bank(s, hdlidx, attrs);
    613,866 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:shpr_bank (55,806x)
          .           
    111,612 ( 0.00%)              if (sbank < 0) {
          .                           continue;
          .                       }
    334,836 ( 0.00%)              set_prio(s, hdlidx, sbank, newprio);
  1,339,344 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:set_prio (55,806x)
          .                   }
          .                   nvic_irq_update(s);
          .                   goto exit_ok;
          .               case 0xd28 ... 0xd2b: /* Configurable Fault Status (CFSR) */
          .                   if (!arm_feature(&s->cpu->env, ARM_FEATURE_M_MAIN)) {
          .                       goto exit_ok;
          .                   }
          .                   /* All bits are W1C, so construct 32 bit value with 0s in
-- line 2442 ----------------------------------------
-- line 2454 ----------------------------------------
          .                   if (attrs.secure) {
          .                       /* The BFSR bits [15:8] are shared between security states
          .                        * and we store them in the NS copy.
          .                        */
          .                       s->cpu->env.v7m.cfsr[M_REG_NS] &= ~(value & R_V7M_CFSR_BFSR_MASK);
          .                   }
          .                   goto exit_ok;
          .               }
    114,408 ( 0.00%)      if (size == 4) {
          .                   nvic_writel(s, offset, value, attrs);
     57,204 ( 0.00%)          goto exit_ok;
          .               }
          .               qemu_log_mask(LOG_GUEST_ERROR,
          .                             "NVIC: Bad write of size %d at offset 0x%x\n", size, offset);
          .               /* This is UNPREDICTABLE; treat as RAZ/WI */
          .           
          .            exit_ok:
          .               /* Ensure any changes made are reflected in the cached hflags.  */
    339,030 ( 0.00%)      arm_rebuild_hflags(&s->cpu->env);
 21,534,696 ( 0.03%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:arm_rebuild_hflags (113,010x)
    226,020 ( 0.00%)      return MEMTX_OK;
  1,243,110 ( 0.00%)  }
          .           
          .           static const MemoryRegionOps nvic_sysreg_ops = {
          .               .read_with_attrs = nvic_sysreg_read,
          .               .write_with_attrs = nvic_sysreg_write,
          .               .endianness = DEVICE_NATIVE_ENDIAN,
          .           };
          .           
          .           static int nvic_post_load(void *opaque, int version_id)
-- line 2482 ----------------------------------------
-- line 2581 ----------------------------------------
          .           
          .           static Property props_nvic[] = {
          .               /* Number of external IRQ lines (so excluding the 16 internal exceptions) */
          .               DEFINE_PROP_UINT32("num-irq", NVICState, num_irq, 64),
          .               DEFINE_PROP_END_OF_LIST()
          .           };
          .           
          .           static void armv7m_nvic_reset(DeviceState *dev)
          2 ( 0.00%)  {
          .               int resetprio;
          .               NVICState *s = NVIC(dev);
          .           
          .               memset(s->vectors, 0, sizeof(s->vectors));
          .               memset(s->sec_vectors, 0, sizeof(s->sec_vectors));
          1 ( 0.00%)      s->prigroup[M_REG_NS] = 0;
          .               s->prigroup[M_REG_S] = 0;
          .           
          1 ( 0.00%)      s->vectors[ARMV7M_EXCP_NMI].enabled = 1;
          .               /* MEM, BUS, and USAGE are enabled through
          .                * the System Handler Control register
          .                */
          1 ( 0.00%)      s->vectors[ARMV7M_EXCP_SVC].enabled = 1;
          1 ( 0.00%)      s->vectors[ARMV7M_EXCP_PENDSV].enabled = 1;
          1 ( 0.00%)      s->vectors[ARMV7M_EXCP_SYSTICK].enabled = 1;
          .           
          .               /* DebugMonitor is enabled via DEMCR.MON_EN */
          .               s->vectors[ARMV7M_EXCP_DEBUG].enabled = 0;
          .           
          4 ( 0.00%)      resetprio = arm_feature(&s->cpu->env, ARM_FEATURE_V8) ? -4 : -3;
          1 ( 0.00%)      s->vectors[ARMV7M_EXCP_RESET].prio = resetprio;
          2 ( 0.00%)      s->vectors[ARMV7M_EXCP_NMI].prio = -2;
          2 ( 0.00%)      s->vectors[ARMV7M_EXCP_HARD].prio = -1;
          .           
          2 ( 0.00%)      if (arm_feature(&s->cpu->env, ARM_FEATURE_M_SECURITY)) {
          .                   s->sec_vectors[ARMV7M_EXCP_HARD].enabled = 1;
          .                   s->sec_vectors[ARMV7M_EXCP_SVC].enabled = 1;
          .                   s->sec_vectors[ARMV7M_EXCP_PENDSV].enabled = 1;
          .                   s->sec_vectors[ARMV7M_EXCP_SYSTICK].enabled = 1;
          .           
          .                   /* AIRCR.BFHFNMINS resets to 0 so Secure HF is priority -1 (R_CMTC) */
          .                   s->sec_vectors[ARMV7M_EXCP_HARD].prio = -1;
          .                   /* If AIRCR.BFHFNMINS is 0 then NS HF is (effectively) disabled */
          .                   s->vectors[ARMV7M_EXCP_HARD].enabled = 0;
          .               } else {
          2 ( 0.00%)          s->vectors[ARMV7M_EXCP_HARD].enabled = 1;
          .               }
          .           
          .               /* Strictly speaking the reset handler should be enabled.
          .                * However, we don't simulate soft resets through the NVIC,
          .                * and the reset vector should never be pended.
          .                * So we leave it disabled to catch logic errors.
          .                */
          .           
          2 ( 0.00%)      s->exception_prio = NVIC_NOEXC_PRIO;
          1 ( 0.00%)      s->vectpending = 0;
          1 ( 0.00%)      s->vectpending_is_s_banked = false;
          .               s->vectpending_prio = NVIC_NOEXC_PRIO;
          .           
          2 ( 0.00%)      if (arm_feature(&s->cpu->env, ARM_FEATURE_M_SECURITY)) {
          .                   memset(s->itns, 0, sizeof(s->itns));
          .               } else {
          .                   /* This state is constant and not guest accessible in a non-security
          .                    * NVIC; we set the bits to true to avoid having to do a feature
          .                    * bit check in the NVIC enable/pend/etc register accessors.
          .                    */
          .                   int i;
          .           
          .                   for (i = NVIC_FIRST_IRQ; i < ARRAY_SIZE(s->itns); i++) {
         70 ( 0.00%)              s->itns[i] = true;
          .                   }
          .               }
          .           
          .               /*
          .                * We updated state that affects the CPU's MMUidx and thus its hflags;
          .                * and we can't guarantee that we run before the CPU reset function.
          .                */
          2 ( 0.00%)      arm_rebuild_hflags(&s->cpu->env);
        193 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:arm_rebuild_hflags (1x)
          1 ( 0.00%)  }
          .           
          .           static void nvic_systick_trigger(void *opaque, int n, int level)
          .           {
          .               NVICState *s = opaque;
          .           
          .               if (level) {
          .                   /* SysTick just asked us to pend its exception.
          .                    * (This is different from an external interrupt line's
-- line 2666 ----------------------------------------
-- line 2668 ----------------------------------------
          .                    * n == 0 : NonSecure systick
          .                    * n == 1 : Secure systick
          .                    */
          .                   armv7m_nvic_set_pending(s, ARMV7M_EXCP_SYSTICK, n);
          .               }
          .           }
          .           
          .           static void armv7m_nvic_realize(DeviceState *dev, Error **errp)
          6 ( 0.00%)  {
          .               NVICState *s = NVIC(dev);
          .           
          .               /* The armv7m container object will have set our CPU pointer */
          5 ( 0.00%)      if (!s->cpu || !arm_feature(&s->cpu->env, ARM_FEATURE_M)) {
          .                   error_setg(errp, "The NVIC can only be used with a Cortex-M CPU");
          .                   return;
          .               }
          .           
          3 ( 0.00%)      if (s->num_irq > NVIC_MAX_IRQ) {
          .                   error_setg(errp, "num-irq %d exceeds NVIC maximum", s->num_irq);
          .                   return;
          .               }
          .           
          3 ( 0.00%)      qdev_init_gpio_in(dev, set_irq_level, s->num_irq);
    449,929 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/gpio.c:qdev_init_gpio_in (1x)
          .           
          .               /* include space for internal exception vectors */
          1 ( 0.00%)      s->num_irq += NVIC_FIRST_IRQ;
          .           
          5 ( 0.00%)      s->num_prio_bits = arm_feature(&s->cpu->env, ARM_FEATURE_V7) ? 8 : 2;
          .           
          .               /*
          .                * This device provides a single memory region which covers the
          .                * sysreg/NVIC registers from 0xE000E000 .. 0xE000EFFF, with the
          .                * exception of the systick timer registers 0xE000E010 .. 0xE000E0FF.
          .                */
          8 ( 0.00%)      memory_region_init_io(&s->sysregmem, OBJECT(s), &nvic_sysreg_ops, s,
     14,660 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_init_io (1x)
          .                                     "nvic_sysregs", 0x1000);
          2 ( 0.00%)      sysbus_init_mmio(SYS_BUS_DEVICE(dev), &s->sysregmem);
         11 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/sysbus.c:sysbus_init_mmio (1x)
          3 ( 0.00%)  }
          .           
          .           static void armv7m_nvic_instance_init(Object *obj)
          5 ( 0.00%)  {
          .               DeviceState *dev = DEVICE(obj);
          .               NVICState *nvic = NVIC(obj);
          .               SysBusDevice *sbd = SYS_BUS_DEVICE(obj);
          .           
          2 ( 0.00%)      sysbus_init_irq(sbd, &nvic->excpout);
      5,329 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/sysbus.c:sysbus_init_irq (1x)
          5 ( 0.00%)      qdev_init_gpio_out_named(dev, &nvic->sysresetreq, "SYSRESETREQ", 1);
      5,478 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/gpio.c:qdev_init_gpio_out_named (1x)
          .               qdev_init_gpio_in_named(dev, nvic_systick_trigger, "systick-trigger",
          .                                       M_REG_NUM_BANKS);
          .               qdev_init_gpio_in_named(dev, nvic_nmi_trigger, "NMI", 1);
          3 ( 0.00%)  }
          .           
          .           static void armv7m_nvic_class_init(ObjectClass *klass, void *data)
          2 ( 0.00%)  {
          .               DeviceClass *dc = DEVICE_CLASS(klass);
          .           
          2 ( 0.00%)      dc->vmsd  = &vmstate_nvic;
          3 ( 0.00%)      device_class_set_props(dc, props_nvic);
      2,353 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/qdev-properties.c:device_class_set_props (1x)
          2 ( 0.00%)      dc->reset = armv7m_nvic_reset;
          2 ( 0.00%)      dc->realize = armv7m_nvic_realize;
          2 ( 0.00%)  }
          .           
          .           static const TypeInfo armv7m_nvic_info = {
          .               .name          = TYPE_NVIC,
          .               .parent        = TYPE_SYS_BUS_DEVICE,
          .               .instance_init = armv7m_nvic_instance_init,
          .               .instance_size = sizeof(NVICState),
          .               .class_init    = armv7m_nvic_class_init,
          .               .class_size    = sizeof(SysBusDeviceClass),
          .           };
          .           
          .           static void armv7m_nvic_register_types(void)
          1 ( 0.00%)  {
          2 ( 0.00%)      type_register_static(&armv7m_nvic_info);
      1,367 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_register_static (1x)
          .           }
          .           
          4 ( 0.00%)  type_init(armv7m_nvic_register_types)
        261 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/module.c:register_module_init (1x)

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/cpu_tcg.c
--------------------------------------------------------------------------------
Ir                  

-- line 148 ----------------------------------------
         .           }
         .           #endif /* !CONFIG_USER_ONLY */
         .           
         .           /* CPU models. These are not needed for the AArch64 linux-user build. */
         .           #if !defined(CONFIG_USER_ONLY) || !defined(TARGET_AARCH64)
         .           
         .           #if !defined(CONFIG_USER_ONLY) && defined(CONFIG_TCG)
         .           static bool arm_v7m_cpu_exec_interrupt(CPUState *cs, int interrupt_request)
12,678,470 ( 0.02%)  {
         .               CPUClass *cc = CPU_GET_CLASS(cs);
         .               ARMCPU *cpu = ARM_CPU(cs);
         .               CPUARMState *env = &cpu->env;
 1,630,090 ( 0.00%)      bool ret = false;
         .           
         .               /*
         .                * ARMv7-M interrupt masking works differently than -A or -R.
         .                * There is no FIQ/IRQ distinction. Instead of I and F bits
         .                * masking FIQ and IRQ interrupts, an exception is taken only
         .                * if it is higher priority than the current execution priority
         .                * (which depends on state like BASEPRI, FAULTMASK and the
         .                * currently active exception).
         .                */
 3,622,420 ( 0.00%)      if (interrupt_request & CPU_INTERRUPT_HARD
 9,056,050 ( 0.01%)          && (armv7m_nvic_can_take_pending_exception(env->nvic))) {
89,473,780 ( 0.12%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:armv7m_nvic_can_take_pending_exception (1,811,210x)
   181,120 ( 0.00%)          cs->exception_index = EXCP_IRQ;
   724,480 ( 0.00%)          cc->tcg_ops->do_interrupt(cs);
1,328,336,403 ( 1.82%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:arm_v7m_cpu_do_interrupt (181,120x)
         .                   ret = true;
         .               }
         .               return ret;
 9,056,050 ( 0.01%)  }
         .           #endif /* !CONFIG_USER_ONLY && CONFIG_TCG */
         .           
         .           static void arm926_initfn(Object *obj)
         .           {
         .               ARMCPU *cpu = ARM_CPU(obj);
         .           
         .               cpu->dtb_compatible = "arm,arm926";
         .               set_feature(&cpu->env, ARM_FEATURE_V5);
-- line 185 ----------------------------------------
-- line 708 ----------------------------------------
         .               cpu->isar.id_isar2 = 0x21112231;
         .               cpu->isar.id_isar3 = 0x01111110;
         .               cpu->isar.id_isar4 = 0x01310102;
         .               cpu->isar.id_isar5 = 0x00000000;
         .               cpu->isar.id_isar6 = 0x00000000;
         .           }
         .           
         .           static void cortex_m7_initfn(Object *obj)
         2 ( 0.00%)  {
         .               ARMCPU *cpu = ARM_CPU(obj);
         .           
         .               set_feature(&cpu->env, ARM_FEATURE_V7);
         .               set_feature(&cpu->env, ARM_FEATURE_M);
         .               set_feature(&cpu->env, ARM_FEATURE_M_MAIN);
         .               set_feature(&cpu->env, ARM_FEATURE_THUMB_DSP);
         1 ( 0.00%)      cpu->midr = 0x411fc272; /* r1p2 */
         1 ( 0.00%)      cpu->pmsav7_dregion = 8;
         2 ( 0.00%)      cpu->isar.mvfr0 = 0x10110221;
         .               cpu->isar.mvfr1 = 0x12000011;
         2 ( 0.00%)      cpu->isar.mvfr2 = 0x00000040;
         2 ( 0.00%)      cpu->isar.id_pfr0 = 0x00000030;
         .               cpu->isar.id_pfr1 = 0x00000200;
         .               cpu->isar.id_dfr0 = 0x00100000;
         1 ( 0.00%)      cpu->id_afr0 = 0x00000000;
         .               cpu->isar.id_mmfr0 = 0x00100030;
         2 ( 0.00%)      cpu->isar.id_mmfr1 = 0x00000000;
         .               cpu->isar.id_mmfr2 = 0x01000000;
         1 ( 0.00%)      cpu->isar.id_mmfr3 = 0x00000000;
         2 ( 0.00%)      cpu->isar.id_isar0 = 0x01101110;
         .               cpu->isar.id_isar1 = 0x02112000;
         2 ( 0.00%)      cpu->isar.id_isar2 = 0x20232231;
         .               cpu->isar.id_isar3 = 0x01111131;
         1 ( 0.00%)      cpu->isar.id_isar4 = 0x01310132;
         .               cpu->isar.id_isar5 = 0x00000000;
         2 ( 0.00%)      cpu->isar.id_isar6 = 0x00000000;
         2 ( 0.00%)  }
         .           
         .           static void cortex_m33_initfn(Object *obj)
         .           {
         .               ARMCPU *cpu = ARM_CPU(obj);
         .           
         .               set_feature(&cpu->env, ARM_FEATURE_V8);
         .               set_feature(&cpu->env, ARM_FEATURE_M);
         .               set_feature(&cpu->env, ARM_FEATURE_M_MAIN);
-- line 751 ----------------------------------------
-- line 1049 ----------------------------------------
         .               .adjust_watchpoint_address = arm_adjust_watchpoint_address,
         .               .debug_check_watchpoint = arm_debug_check_watchpoint,
         .               .debug_check_breakpoint = arm_debug_check_breakpoint,
         .           #endif /* !CONFIG_USER_ONLY */
         .           };
         .           #endif /* CONFIG_TCG */
         .           
         .           static void arm_v7m_class_init(ObjectClass *oc, void *data)
        36 ( 0.00%)  {
         .               ARMCPUClass *acc = ARM_CPU_CLASS(oc);
         .               CPUClass *cc = CPU_CLASS(oc);
         .           
         6 ( 0.00%)      acc->info = data;
         .           #ifdef CONFIG_TCG
        12 ( 0.00%)      cc->tcg_ops = &arm_v7m_tcg_ops;
         .           #endif /* CONFIG_TCG */
         .           
        12 ( 0.00%)      cc->gdb_core_xml_file = "arm-m-profile.xml";
        24 ( 0.00%)  }
         .           
         .           #ifndef TARGET_AARCH64
         .           /*
         .            * -cpu max: a CPU with as many features enabled as our emulation supports.
         .            * The version of '-cpu max' for qemu-system-aarch64 is defined in cpu64.c;
         .            * this only needs to handle 32 bits, and need not care about KVM.
         .            */
         .           static void arm_max_initfn(Object *obj)
-- line 1075 ----------------------------------------
-- line 1188 ----------------------------------------
         .           
         .           static const TypeInfo idau_interface_type_info = {
         .               .name = TYPE_IDAU_INTERFACE,
         .               .parent = TYPE_INTERFACE,
         .               .class_size = sizeof(IDAUInterfaceClass),
         .           };
         .           
         .           static void arm_tcg_cpu_register_types(void)
         6 ( 0.00%)  {
         .               size_t i;
         .           
         2 ( 0.00%)      type_register_static(&idau_interface_type_info);
     2,195 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_register_static (1x)
       106 ( 0.00%)      for (i = 0; i < ARRAY_SIZE(arm_tcg_cpus); ++i) {
        70 ( 0.00%)          arm_cpu_register(&arm_tcg_cpus[i]);
   178,124 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/cpu.c:arm_cpu_register (35x)
         .               }
         4 ( 0.00%)  }
         .           
         4 ( 0.00%)  type_init(arm_tcg_cpu_register_types)
       261 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/module.c:register_module_init (1x)
         .           
         .           #endif /* !CONFIG_USER_ONLY || !TARGET_AARCH64 */

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/include/exec/memory.h
--------------------------------------------------------------------------------
Ir                  

-- line 29 ----------------------------------------
         .           #include "qemu/rcu.h"
         .           
         .           #define RAM_ADDR_INVALID (~(ram_addr_t)0)
         .           
         .           #define MAX_PHYS_ADDR_SPACE_BITS 62
         .           #define MAX_PHYS_ADDR            (((hwaddr)1 << MAX_PHYS_ADDR_SPACE_BITS) - 1)
         .           
         .           #define TYPE_MEMORY_REGION "memory-region"
       130 ( 0.00%)  DECLARE_INSTANCE_CHECKER(MemoryRegion, MEMORY_REGION,
         6 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_dynamic_cast_assert (2x)
         .                                    TYPE_MEMORY_REGION)
         .           
         .           #define TYPE_IOMMU_MEMORY_REGION "iommu-memory-region"
         .           typedef struct IOMMUMemoryRegionClass IOMMUMemoryRegionClass;
        15 ( 0.00%)  DECLARE_OBJ_CHECKERS(IOMMUMemoryRegion, IOMMUMemoryRegionClass,
        18 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_class_dynamic_cast_assert (1x)
         .                                IOMMU_MEMORY_REGION, TYPE_IOMMU_MEMORY_REGION)
         .           
         .           #define TYPE_RAM_DISCARD_MANAGER "qemu:ram-discard-manager"
         .           typedef struct RamDiscardManagerClass RamDiscardManagerClass;
         .           typedef struct RamDiscardManager RamDiscardManager;
         7 ( 0.00%)  DECLARE_OBJ_CHECKERS(RamDiscardManager, RamDiscardManagerClass,
       534 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_class_dynamic_cast_assert (1x)
         .                                RAM_DISCARD_MANAGER, TYPE_RAM_DISCARD_MANAGER);
         .           
         .           #ifdef CONFIG_FUZZ
         .           void fuzz_dma_read_cb(size_t addr,
         .                                 size_t len,
         .                                 MemoryRegion *mr);
         .           #else
         .           static inline void fuzz_dma_read_cb(size_t addr,
         .                                               size_t len,
         .                                               MemoryRegion *mr)
         .           {
         .               /* Do Nothing */
   218,328 ( 0.00%)  }
         .           #endif
         .           
         .           /* Possible bits for global_dirty_log_{start|stop} */
         .           
         .           /* Dirty tracking enabled because migration is running */
         .           #define GLOBAL_DIRTY_MIGRATION  (1U << 0)
         .           
         .           /* Dirty tracking enabled because measuring dirty rate */
-- line 69 ----------------------------------------
-- line 206 ----------------------------------------
         .           /* RAM that isn't accessible through normal means. */
         .           #define RAM_PROTECTED (1 << 8)
         .           
         .           static inline void iommu_notifier_init(IOMMUNotifier *n, IOMMUNotify fn,
         .                                                  IOMMUNotifierFlag flags,
         .                                                  hwaddr start, hwaddr end,
         .                                                  int iommu_idx)
         .           {
   354,690 ( 0.00%)      n->notify = fn;
         .               n->notifier_flags = flags;
         .               n->start = start;
         .               n->end = end;
         .               n->iommu_idx = iommu_idx;
         .           }
         .           
         .           /*
         .            * Memory region callbacks
-- line 222 ----------------------------------------
-- line 1066 ----------------------------------------
         .               unsigned nr;
         .               unsigned nr_allocated;
         .               struct AddressSpaceDispatch *dispatch;
         .               MemoryRegion *root;
         .           };
         .           
         .           static inline FlatView *address_space_to_flatview(AddressSpace *as)
         .           {
 8,585,194 ( 0.01%)      return qatomic_rcu_read(&as->current_map);
         .           }
         .           
         .           /**
         .            * typedef flatview_cb: callback for flatview_for_each_range()
         .            *
         .            * @start: start address of the range within the FlatView
         .            * @len: length of the range in bytes
         .            * @mr: MemoryRegion covering this range
-- line 1082 ----------------------------------------
-- line 1588 ----------------------------------------
         .            * memory_region_is_ram: check whether a memory region is random access
         .            *
         .            * Returns %true if a memory region is random access.
         .            *
         .            * @mr: the memory region being queried
         .            */
         .           static inline bool memory_region_is_ram(MemoryRegion *mr)
         .           {
 9,920,042 ( 0.01%)      return mr->ram;
         .           }
         .           
         .           /**
         .            * memory_region_is_ram_device: check whether a memory region is a ram device
         .            *
         .            * Returns %true if a memory region is a device backed ram region
         .            *
         .            * @mr: the memory region being queried
-- line 1604 ----------------------------------------
-- line 1610 ----------------------------------------
         .            *
         .            * Returns %true if a memory region is a ROM device and currently set to allow
         .            * direct reads.
         .            *
         .            * @mr: the memory region being queried
         .            */
         .           static inline bool memory_region_is_romd(MemoryRegion *mr)
         .           {
 1,109,756 ( 0.00%)      return mr->rom_device && mr->romd_mode;
         .           }
         .           
         .           /**
         .            * memory_region_is_protected: check whether a memory region is protected
         .            *
         .            * Returns %true if a memory region is protected RAM and cannot be accessed
         .            * via standard mechanisms, e.g. DMA.
         .            *
-- line 1626 ----------------------------------------
-- line 1631 ----------------------------------------
         .           /**
         .            * memory_region_get_iommu: check whether a memory region is an iommu
         .            *
         .            * Returns pointer to IOMMUMemoryRegion if a memory region is an iommu,
         .            * otherwise NULL.
         .            *
         .            * @mr: the memory region being queried
         .            */
 9,207,664 ( 0.01%)  static inline IOMMUMemoryRegion *memory_region_get_iommu(MemoryRegion *mr)
         .           {
37,776,496 ( 0.05%)      if (mr->alias) {
         .                   return memory_region_get_iommu(mr->alias);
         .               }
18,888,248 ( 0.03%)      if (mr->is_iommu) {
         .                   return (IOMMUMemoryRegion *) mr;
         .               }
         .               return NULL;
         .           }
         .           
         .           /**
         .            * memory_region_get_iommu_class_nocheck: returns iommu memory region class
         .            *   if an iommu or NULL if not
-- line 1652 ----------------------------------------
-- line 2739 ----------------------------------------
         .                                            hwaddr *len, bool is_write,
         .                                            MemTxAttrs attrs);
         .           
         .           static inline MemoryRegion *address_space_translate(AddressSpace *as,
         .                                                               hwaddr addr, hwaddr *xlat,
         .                                                               hwaddr *len, bool is_write,
         .                                                               MemTxAttrs attrs)
         .           {
50,522,460 ( 0.07%)      return flatview_translate(address_space_to_flatview(as),
679,631,063 ( 0.93%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:flatview_translate (4,432,396x)
         .                                         addr, xlat, len, is_write, attrs);
         .           }
         .           
         .           /* address_space_access_valid: check for validity of accessing an address
         .            * space range
         .            *
         .            * Check whether memory is assigned to the given address space range, and
         .            * access is permitted by any IOMMU regions that are active for the address
-- line 2755 ----------------------------------------
-- line 2817 ----------------------------------------
         .                                                       hwaddr addr, const void *buf,
         .                                                       hwaddr len);
         .           
         .           int memory_access_size(MemoryRegion *mr, unsigned l, hwaddr addr);
         .           bool prepare_mmio_access(MemoryRegion *mr);
         .           
         .           static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)
         .           {
   622,668 ( 0.00%)      if (is_write) {
16,610,376 ( 0.02%)          return memory_region_is_ram(mr) && !mr->readonly &&
25,287,604 ( 0.03%)                 !mr->rom_device && !memory_region_is_ram_device(mr);
   493,740 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_is_ram_device (164,580x)
         .               } else {
27,467,700 ( 0.04%)          return (memory_region_is_ram(mr) && !memory_region_is_ram_device(mr)) ||
        12 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_is_ram_device (4x)
         .                          memory_region_is_romd(mr);
         .               }
         .           }
         .           
         .           /**
         .            * address_space_read: read from an address space.
         .            *
         .            * Return a MemTxResult indicating whether the operation succeeded
-- line 2837 ----------------------------------------
-- line 2944 ----------------------------------------
         .           #if HOST_BIG_ENDIAN != TARGET_BIG_ENDIAN
         .               /* Swap if non-host endianness or native (target) endianness */
         .               return (end == DEVICE_HOST_ENDIAN) ? 0 : MO_BSWAP;
         .           #else
         .               const int non_host_endianness =
         .                   DEVICE_LITTLE_ENDIAN ^ DEVICE_BIG_ENDIAN ^ DEVICE_HOST_ENDIAN;
         .           
         .               /* In this case, native (target) endianness needs no swap.  */
15,192,300 ( 0.02%)      return (end == non_host_endianness) ? MO_BSWAP : 0;
         .           #endif
         .           }
         .           #endif
         .           
         .           /*
         .            * Inhibit technologies that require discarding of pages in RAM blocks, e.g.,
         .            * to manage the actual amount of memory consumed by the VM (then, the memory
         .            * provided by RAM blocks might be bigger than the desired memory consumption).
-- line 2960 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c
--------------------------------------------------------------------------------
Ir                     

-- line 231 ----------------------------------------
            .               }
            .               if (aidx < bidx) {
            .                   return -1;
            .               }
            .               return 0;
            .           }
            .           
            .           void init_cpreg_list(ARMCPU *cpu)
            7 ( 0.00%)  {
            .               /* Initialise the cpreg_tuples[] array based on the cp_regs hash.
            .                * Note that we require cpreg_tuples[] to be sorted by key ID.
            .                */
            .               GList *keys;
            .               int arraylen;
            .           
            3 ( 0.00%)      keys = g_hash_table_get_keys(cpu->cp_regs);
           67 ( 0.00%)  => ???:0x0000000004e3b520 (1x)
            3 ( 0.00%)      keys = g_list_sort(keys, cpreg_key_compare);
           30 ( 0.00%)  => ???:0x0000000004e3d000 (1x)
            .           
            1 ( 0.00%)      cpu->cpreg_array_len = 0;
            .           
            4 ( 0.00%)      g_list_foreach(keys, count_cpreg, cpu);
            6 ( 0.00%)  => ???:0x0000000004e3c7d0 (1x)
            .           
            1 ( 0.00%)      arraylen = cpu->cpreg_array_len;
            4 ( 0.00%)      cpu->cpreg_indexes = g_new(uint64_t, arraylen);
           15 ( 0.00%)  => ???:0x0000000004e3aa60 (1x)
            4 ( 0.00%)      cpu->cpreg_values = g_new(uint64_t, arraylen);
           15 ( 0.00%)  => ???:0x0000000004e3aa60 (1x)
            4 ( 0.00%)      cpu->cpreg_vmstate_indexes = g_new(uint64_t, arraylen);
           15 ( 0.00%)  => ???:0x0000000004e3aa60 (1x)
            4 ( 0.00%)      cpu->cpreg_vmstate_values = g_new(uint64_t, arraylen);
           15 ( 0.00%)  => ???:0x0000000004e3aa60 (1x)
            2 ( 0.00%)      cpu->cpreg_vmstate_array_len = cpu->cpreg_array_len;
            1 ( 0.00%)      cpu->cpreg_array_len = 0;
            .           
            4 ( 0.00%)      g_list_foreach(keys, add_cpreg_to_list, cpu);
            6 ( 0.00%)  => ???:0x0000000004e3c7d0 (1x)
            .           
            2 ( 0.00%)      assert(cpu->cpreg_array_len == arraylen);
            .           
            2 ( 0.00%)      g_list_free(keys);
           38 ( 0.00%)  => ???:0x0000000004e3b540 (1x)
            5 ( 0.00%)  }
            .           
            .           /*
            .            * Some registers are not accessible from AArch32 EL3 if SCR.NS == 0.
            .            */
            .           static CPAccessResult access_el3_aa32ns(CPUARMState *env,
            .                                                   const ARMCPRegInfo *ri,
            .                                                   bool isread)
            .           {
-- line 274 ----------------------------------------
-- line 5323 ----------------------------------------
            .           }
            .           
            .           /*
            .            * Return the effective value of HCR_EL2, at the given security state.
            .            * Bits that are not included here:
            .            * RW       (read from SCR_EL3.RW as needed)
            .            */
            .           uint64_t arm_hcr_el2_eff_secstate(CPUARMState *env, bool secure)
      311,368 ( 0.00%)  {
            .               uint64_t ret = env->cp15.hcr_el2;
            .           
            .               if (!arm_is_el2_enabled_secstate(env, secure)) {
            .                   /*
            .                    * "This register has no effect if EL2 is not enabled in the
            .                    * current Security state".  This is ARMv8.4-SecEL2 speak for
            .                    * !(SCR_EL3.NS==1 || SCR_EL3.EEL2==1).
            .                    *
-- line 5339 ----------------------------------------
-- line 5342 ----------------------------------------
            .                    * as if this field is 0 for all purposes other than a direct
            .                    * read or write access of HCR_EL2".  With lots of enumeration
            .                    * on a per-field basis.  In current QEMU, this is condition
            .                    * is arm_is_secure_below_el3.
            .                    *
            .                    * Since the v8.4 language applies to the entire register, and
            .                    * appears to be backward compatible, use that.
            .                    */
      311,368 ( 0.00%)          return 0;
            .               }
            .           
            .               /*
            .                * For a cpu that supports both aarch64 and aarch32, we can set bits
            .                * in HCR_EL2 (e.g. via EL3) that are RES0 when we enter EL2 as aa32.
            .                * Ignore all of the bits in HCR+HCR2 that are not valid for aarch32.
            .                */
            .               if (!arm_el_is_aa64(env, 2)) {
-- line 5358 ----------------------------------------
-- line 5383 ----------------------------------------
            .                   }
            .                   ret &= ~(HCR_SWIO | HCR_PTW | HCR_VF | HCR_VI | HCR_VSE |
            .                            HCR_FB | HCR_TID1 | HCR_TID3 | HCR_TSC | HCR_TACR |
            .                            HCR_TSW | HCR_TTLB | HCR_TVM | HCR_HCD | HCR_TRVM |
            .                            HCR_TLOR);
            .               }
            .           
            .               return ret;
      311,368 ( 0.00%)  }
            .           
            .           uint64_t arm_hcr_el2_eff(CPUARMState *env)
      311,368 ( 0.00%)  {
      311,368 ( 0.00%)      return arm_hcr_el2_eff_secstate(env, arm_is_secure_below_el3(env));
    1,868,208 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:arm_hcr_el2_eff_secstate (311,368x)
            .           }
            .           
            .           /*
            .            * Corresponds to ARM pseudocode function ELIsInHost().
            .            */
            .           bool el_is_in_host(CPUARMState *env, int el)
            .           {
            .               uint64_t mask;
-- line 5403 ----------------------------------------
-- line 7412 ----------------------------------------
            .                 .type = ARM_CP_CONST, .resetvalue = 0 },
            .               { .name = "HACTLR2", .state = ARM_CP_STATE_AA32,
            .                 .cp = 15, .opc1 = 4, .crn = 1, .crm = 0, .opc2 = 3,
            .                 .access = PL2_RW, .type = ARM_CP_CONST,
            .                 .resetvalue = 0 },
            .           };
            .           
            .           void register_cp_regs_for_features(ARMCPU *cpu)
           13 ( 0.00%)  {
            .               /* Register all the coprocessor registers based on feature bits */
            .               CPUARMState *env = &cpu->env;
            2 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_M)) {
            .                   /* M profile has no coprocessor registers */
            .                   return;
            .               }
            .           
            .               define_arm_cp_regs(cpu, cp_reginfo);
            .               if (!arm_feature(env, ARM_FEATURE_V8)) {
            .                   /* Must go early as it is full of wildcards that may be
            .                    * overridden by later definitions.
-- line 7431 ----------------------------------------
-- line 8420 ----------------------------------------
            .               /*
            .                * Register redirections and aliases must be done last,
            .                * after the registers from the other extensions have been defined.
            .                */
            .               if (arm_feature(env, ARM_FEATURE_EL2) && cpu_isar_feature(aa64_vh, cpu)) {
            .                   define_arm_vh_e2h_redirects_aliases(cpu);
            .               }
            .           #endif
           11 ( 0.00%)  }
            .           
            .           /* Sort alphabetically by type name, except for "any". */
            .           static gint arm_cpu_list_compare(gconstpointer a, gconstpointer b)
            .           {
            .               ObjectClass *class_a = (ObjectClass *)a;
            .               ObjectClass *class_b = (ObjectClass *)b;
            .               const char *name_a, *name_b;
            .           
-- line 8436 ----------------------------------------
-- line 9172 ----------------------------------------
            .               }
            .               if (num == INT_MIN && den == -1) {
            .                   return INT_MIN;
            .               }
            .               return num / den;
            .           }
            .           
            .           uint32_t HELPER(udiv)(CPUARMState *env, uint32_t num, uint32_t den)
  133,374,452 ( 0.18%)  {
  400,123,356 ( 0.55%)      if (den == 0) {
            .                   handle_possible_div0_trap(env, GETPC());
            .                   return 0;
            .               }
  400,123,356 ( 0.55%)      return num / den;
  133,374,452 ( 0.18%)  }
            .           
            .           uint32_t HELPER(rbit)(uint32_t x)
            .           {
            .               return revbit32(x);
            .           }
            .           
            .           #ifdef CONFIG_USER_ONLY
            .           
-- line 9194 ----------------------------------------
-- line 9350 ----------------------------------------
            .               target_el = target_el_table[is64][scr][rw][hcr][secure][cur_el];
            .           
            .               assert(target_el > 0);
            .           
            .               return target_el;
            .           }
            .           
            .           void arm_log_exception(CPUState *cs)
      984,976 ( 0.00%)  {
            .               int idx = cs->exception_index;
            .           
            .               if (qemu_loglevel_mask(CPU_LOG_INT)) {
            .                   const char *exc = NULL;
            .                   static const char * const excnames[] = {
            .                       [EXCP_UDEF] = "Undefined Instruction",
            .                       [EXCP_SWI] = "SVC",
            .                       [EXCP_PREFETCH_ABORT] = "Prefetch Abort",
-- line 9366 ----------------------------------------
-- line 9390 ----------------------------------------
            .                       exc = excnames[idx];
            .                   }
            .                   if (!exc) {
            .                       exc = "unknown";
            .                   }
            .                   qemu_log_mask(CPU_LOG_INT, "Taking exception %d [%s] on CPU %d\n",
            .                                 idx, exc, cs->cpu_index);
            .               }
      984,976 ( 0.00%)  }
            .           
            .           /*
            .            * Function used to synchronize QEMU's AArch64 register set with AArch32
            .            * register set.  This is necessary when switching between AArch32 and AArch64
            .            * execution state.
            .            */
            .           void aarch64_sync_32_to_64(CPUARMState *env)
            .           {
-- line 9406 ----------------------------------------
-- line 10697 ----------------------------------------
            .               res = a + b;
            .               if (res < a)
            .                   res = 0xff;
            .               return res;
            .           }
            .           
            .           static inline uint8_t sub8_usat(uint8_t a, uint8_t b)
            .           {
      393,024 ( 0.00%)      if (a > b)
       32,752 ( 0.00%)          return a - b;
            .               else
            .                   return 0;
            .           }
            .           
            .           #define ADD16(a, b, n) RESULT(add16_usat(a, b), n, 16);
            .           #define SUB16(a, b, n) RESULT(sub16_usat(a, b), n, 16);
            .           #define ADD8(a, b, n)  RESULT(add8_usat(a, b), n, 8);
            .           #define SUB8(a, b, n)  RESULT(sub8_usat(a, b), n, 8);
-- line 10714 ----------------------------------------
-- line 10866 ----------------------------------------
            .               /* Linux crc32c converts the output to one's complement.  */
            .               return crc32c(acc, buf, bytes) ^ 0xffffffff;
            .           }
            .           
            .           /* Return the exception level to which FP-disabled exceptions should
            .            * be taken, or 0 if FP is enabled.
            .            */
            .           int fp_exception_el(CPUARMState *env, int cur_el)
   11,349,990 ( 0.02%)  {
            .           #ifndef CONFIG_USER_ONLY
            .               uint64_t hcr_el2;
            .           
            .               /* CPACR and the CPTR registers don't exist before v6, so FP is
            .                * always accessible
            .                */
    3,783,330 ( 0.01%)      if (!arm_feature(env, ARM_FEATURE_V6)) {
            .                   return 0;
            .               }
            .           
    3,783,330 ( 0.01%)      if (arm_feature(env, ARM_FEATURE_M)) {
            .                   /* CPACR can cause a NOCP UsageFault taken to current security state */
    1,891,665 ( 0.00%)          if (!v7m_cpacr_pass(env, env->v7m.secure, cur_el != 0)) {
            3 ( 0.00%)              return 1;
            .                   }
            .           
    3,783,324 ( 0.01%)          if (arm_feature(env, ARM_FEATURE_M_SECURITY) && !env->v7m.secure) {
            .                       if (!extract32(env->v7m.nsacr, 10, 1)) {
            .                           /* FP insns cause a NOCP UsageFault taken to Secure */
            .                           return 3;
            .                       }
            .                   }
            .           
    1,891,662 ( 0.00%)          return 0;
            .               }
            .           
            .               hcr_el2 = arm_hcr_el2_eff(env);
            .           
            .               /* The CPACR controls traps to EL1, or PL1 if we're 32 bit:
            .                * 0, 2 : trap EL0 and EL1/PL1 accesses
            .                * 1    : trap only EL0 accesses
            .                * 3    : trap no accesses
-- line 10906 ----------------------------------------
-- line 10967 ----------------------------------------
            .           
            .               /* CPTR_EL3 : present in v8 */
            .               if (FIELD_EX64(env->cp15.cptr_el[3], CPTR_EL3, TFP)) {
            .                   /* Trap all FP ops to EL3 */
            .                   return 3;
            .               }
            .           #endif
            .               return 0;
    7,566,660 ( 0.01%)  }
            .           
            .           /* Return the exception level we're running at if this is our mmu_idx */
            .           int arm_mmu_idx_to_el(ARMMMUIdx mmu_idx)
          746 ( 0.00%)  {
        1,492 ( 0.00%)      if (mmu_idx & ARM_MMU_IDX_M) {
        2,238 ( 0.00%)          return mmu_idx & ARM_MMU_IDX_M_PRIV;
            .               }
            .           
            .               switch (mmu_idx) {
            .               case ARMMMUIdx_E10_0:
            .               case ARMMMUIdx_E20_0:
            .                   return 0;
            .               case ARMMMUIdx_E10_1:
            .               case ARMMMUIdx_E10_1_PAN:
-- line 10989 ----------------------------------------
-- line 11011 ----------------------------------------
            .               if (is_a64(env)) {
            .                   return env->pstate & PSTATE_PAN;
            .               } else {
            .                   return env->uncached_cpsr & CPSR_PAN;
            .               }
            .           }
            .           
            .           ARMMMUIdx arm_mmu_idx_el(CPUARMState *env, int el)
    2,384,153 ( 0.00%)  {
            .               ARMMMUIdx idx;
            .               uint64_t hcr;
            .           
    4,768,306 ( 0.01%)      if (arm_feature(env, ARM_FEATURE_M)) {
   11,920,765 ( 0.02%)          return arm_v7m_mmu_idx_for_secstate(env, env->v7m.secure);
  131,084,848 ( 0.18%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:arm_v7m_mmu_idx_for_secstate (2,384,153x)
            .               }
            .           
            .               /* See ARM pseudo-function ELIsInHost.  */
            .               switch (el) {
            .               case 0:
            .                   hcr = arm_hcr_el2_eff(env);
            .                   if ((hcr & (HCR_E2H | HCR_TGE)) == (HCR_E2H | HCR_TGE)) {
            .                       idx = ARMMMUIdx_E20_0;
-- line 11032 ----------------------------------------
-- line 11058 ----------------------------------------
            .               default:
            .                   g_assert_not_reached();
            .               }
            .           
            .               return idx;
            .           }
            .           
            .           ARMMMUIdx arm_mmu_idx(CPUARMState *env)
      492,488 ( 0.00%)  {
      492,488 ( 0.00%)      return arm_mmu_idx_el(env, arm_current_el(env));
   31,519,232 ( 0.04%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:arm_mmu_idx_el (492,488x)
            .           }
            .           
            .           static CPUARMTBFlags rebuild_hflags_common(CPUARMState *env, int fp_el,
            .                                                      ARMMMUIdx mmu_idx,
            .                                                      CPUARMTBFlags flags)
            .           {
            .               DP_TBFLAG_ANY(flags, FPEXC_EL, fp_el);
            .               DP_TBFLAG_ANY(flags, MMUIDX, arm_to_core_mmu_idx(mmu_idx));
            .           
    3,783,330 ( 0.01%)      if (arm_singlestep_active(env)) {
    9,458,325 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/debug_helper.c:arm_singlestep_active (1,891,665x)
            .                   DP_TBFLAG_ANY(flags, SS_ACTIVE, 1);
            .               }
    1,891,665 ( 0.00%)      return flags;
            .           }
            .           
            .           static CPUARMTBFlags rebuild_hflags_common_32(CPUARMState *env, int fp_el,
            .                                                         ARMMMUIdx mmu_idx,
            .                                                         CPUARMTBFlags flags)
   17,024,985 ( 0.02%)  {
            .               bool sctlr_b = arm_sctlr_b(env);
            .           
            .               if (sctlr_b) {
            .                   DP_TBFLAG_A32(flags, SCTLR__B, 1);
            .               }
            .               if (arm_cpu_data_is_big_endian_a32(env, sctlr_b)) {
            .                   DP_TBFLAG_ANY(flags, BE_DATA, 1);
            .               }
            .               DP_TBFLAG_A32(flags, NS, !access_secure_reg(env));
            .           
            .               return rebuild_hflags_common(env, fp_el, mmu_idx, flags);
   11,349,990 ( 0.02%)  }
            .           
            .           static CPUARMTBFlags rebuild_hflags_m32(CPUARMState *env, int fp_el,
            .                                                   ARMMMUIdx mmu_idx)
            .           {
            .               CPUARMTBFlags flags = {};
    5,674,995 ( 0.01%)      uint32_t ccr = env->v7m.ccr[env->v7m.secure];
            .           
            .               /* Without HaveMainExt, CCR.UNALIGN_TRP is RES1. */
    5,674,995 ( 0.01%)      if (ccr & R_V7M_CCR_UNALIGN_TRP_MASK) {
            .                   DP_TBFLAG_ANY(flags, ALIGN_MEM, 1);
            .               }
            .           
    7,566,660 ( 0.01%)      if (arm_v7m_is_handler_mode(env)) {
            .                   DP_TBFLAG_M32(flags, HANDLER, 1);
            .               }
            .           
            .               /*
            .                * v8M always applies stack limit checks unless CCR.STKOFHFNMIGN
            .                * is suppressing them because the requested execution priority
            .                * is less than 0.
            .                */
    3,783,330 ( 0.01%)      if (arm_feature(env, ARM_FEATURE_V8) &&
            .                   !((mmu_idx & ARM_MMU_IDX_M_NEGPRI) &&
            .                     (ccr & R_V7M_CCR_STKOFHFNMIGN_MASK))) {
            .                   DP_TBFLAG_M32(flags, STACKCHECK, 1);
            .               }
            .           
    3,783,330 ( 0.01%)      if (arm_feature(env, ARM_FEATURE_M_SECURITY) && env->v7m.secure) {
            .                   DP_TBFLAG_M32(flags, SECURE, 1);
            .               }
            .           
    5,674,995 ( 0.01%)      return rebuild_hflags_common_32(env, fp_el, mmu_idx, flags);
   88,908,255 ( 0.12%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:rebuild_hflags_common_32 (1,891,665x)
            .           }
            .           
            .           static CPUARMTBFlags rebuild_hflags_a32(CPUARMState *env, int fp_el,
            .                                                   ARMMMUIdx mmu_idx)
            .           {
            .               CPUARMTBFlags flags = {};
            .               int el = arm_current_el(env);
            .           
-- line 11138 ----------------------------------------
-- line 11313 ----------------------------------------
            .               }
            .           
            .               return rebuild_hflags_common(env, fp_el, mmu_idx, flags);
            .           }
            .           
            .           static CPUARMTBFlags rebuild_hflags_internal(CPUARMState *env)
            .           {
            .               int el = arm_current_el(env);
    4,391,956 ( 0.01%)      int fp_el = fp_exception_el(env, el);
   31,841,675 ( 0.04%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:fp_exception_el (1,097,989x)
    4,391,956 ( 0.01%)      ARMMMUIdx mmu_idx = arm_mmu_idx_el(env, el);
   68,078,120 ( 0.09%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:arm_mmu_idx_el (1,097,989x)
            .           
    2,195,978 ( 0.00%)      if (is_a64(env)) {
            .                   return rebuild_hflags_a64(env, el, fp_el, mmu_idx);
    2,195,978 ( 0.00%)      } else if (arm_feature(env, ARM_FEATURE_M)) {
    3,293,967 ( 0.00%)          return rebuild_hflags_m32(env, fp_el, mmu_idx);
   71,369,285 ( 0.10%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:rebuild_hflags_m32 (1,097,989x)
            .               } else {
            .                   return rebuild_hflags_a32(env, fp_el, mmu_idx);
            .               }
            .           }
            .           
            .           void arm_rebuild_hflags(CPUARMState *env)
    5,489,945 ( 0.01%)  {
    1,097,989 ( 0.00%)      env->hflags = rebuild_hflags_internal(env);
    4,391,956 ( 0.01%)  }
            .           
            .           /*
            .            * If we have triggered a EL state change we can't rely on the
            .            * translator having passed it to us, we need to recompute.
            .            */
            .           void HELPER(rebuild_hflags_m32_newel)(CPUARMState *env)
      293,180 ( 0.00%)  {
            .               int el = arm_current_el(env);
      234,544 ( 0.00%)      int fp_el = fp_exception_el(env, el);
    1,700,444 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:fp_exception_el (58,636x)
      234,544 ( 0.00%)      ARMMMUIdx mmu_idx = arm_mmu_idx_el(env, el);
    3,518,160 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:arm_mmu_idx_el (58,636x)
            .           
      234,544 ( 0.00%)      env->hflags = rebuild_hflags_m32(env, fp_el, mmu_idx);
    3,811,340 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:rebuild_hflags_m32 (58,636x)
      234,544 ( 0.00%)  }
            .           
            .           void HELPER(rebuild_hflags_m32)(CPUARMState *env, int el)
    4,410,240 ( 0.01%)  {
    1,470,080 ( 0.00%)      int fp_el = fp_exception_el(env, el);
   21,316,160 ( 0.03%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:fp_exception_el (735,040x)
    2,940,160 ( 0.00%)      ARMMMUIdx mmu_idx = arm_mmu_idx_el(env, el);
   47,042,560 ( 0.06%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:arm_mmu_idx_el (735,040x)
            .           
    2,940,160 ( 0.00%)      env->hflags = rebuild_hflags_m32(env, fp_el, mmu_idx);
   47,777,600 ( 0.07%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:rebuild_hflags_m32 (735,040x)
    2,940,160 ( 0.00%)  }
            .           
            .           /*
            .            * If we have triggered a EL state change we can't rely on the
            .            * translator having passed it to us, we need to recompute.
            .            */
            .           void HELPER(rebuild_hflags_a32_newel)(CPUARMState *env)
            .           {
            .               int el = arm_current_el(env);
-- line 11365 ----------------------------------------
-- line 11415 ----------------------------------------
            .                * We do not include the effect of the ECI bits here -- they are
            .                * tracked in other TB flags. This simplifies the logic for
            .                * "when did we emit code that changes the MVE_NO_PRED TB flag
            .                * and thus need to end the TB?".
            .                */
            .               if (cpu_isar_feature(aa32_mve, env_archcpu(env))) {
            .                   return false;
            .               }
  536,580,834 ( 0.74%)      if (env->v7m.vpr) {
            .                   return false;
            .               }
  357,720,556 ( 0.49%)      if (env->v7m.ltpsize < 4) {
            .                   return false;
            .               }
            .               return true;
            .           }
            .           
            .           void cpu_get_tb_cpu_state(CPUARMState *env, target_ulong *pc,
            .                                     target_ulong *cs_base, uint32_t *pflags)
  715,441,112 ( 0.98%)  {
            .               CPUARMTBFlags flags;
            .           
            .               assert_hflags_rebuild_correctly(env);
  357,720,556 ( 0.49%)      flags = env->hflags;
            .           
  357,720,556 ( 0.49%)      if (EX_TBFLAG_ANY(flags, AARCH64_STATE)) {
            .                   *pc = env->pc;
            .                   if (cpu_isar_feature(aa64_bti, env_archcpu(env))) {
            .                       DP_TBFLAG_A64(flags, BTYPE, env->btype);
            .                   }
            .               } else {
  357,720,556 ( 0.49%)          *pc = env->regs[15];
            .           
  357,720,556 ( 0.49%)          if (arm_feature(env, ARM_FEATURE_M)) {
  357,720,556 ( 0.49%)              if (arm_feature(env, ARM_FEATURE_M_SECURITY) &&
  178,860,278 ( 0.25%)                  FIELD_EX32(env->v7m.fpccr[M_REG_S], V7M_FPCCR, S)
  178,860,278 ( 0.25%)                  != env->v7m.secure) {
            .                           DP_TBFLAG_M32(flags, FPCCR_S_WRONG, 1);
            .                       }
            .           
1,073,161,668 ( 1.47%)              if ((env->v7m.fpccr[env->v7m.secure] & R_V7M_FPCCR_ASPEN_MASK) &&
  467,502,730 ( 0.64%)                  (!(env->v7m.control[M_REG_S] & R_V7M_CONTROL_FPCA_MASK) ||
            .                            (env->v7m.secure &&
            .                             !(env->v7m.control[M_REG_S] & R_V7M_CONTROL_SFPA_MASK)))) {
            .                           /*
            .                            * ASPEN is set, but FPCA/SFPA indicate that there is no
            .                            * active FP context; we must create a new FP context before
            .                            * executing any FP insn.
            .                            */
   34,539,052 ( 0.05%)                  DP_TBFLAG_M32(flags, NEW_FP_CTXT_NEEDED, 1);
            .                       }
            .           
  178,860,278 ( 0.25%)              bool is_secure = env->v7m.fpccr[M_REG_S] & R_V7M_FPCCR_S_MASK;
  178,860,278 ( 0.25%)              if (env->v7m.fpccr[is_secure] & R_V7M_FPCCR_LSPACT_MASK) {
            .                           DP_TBFLAG_M32(flags, LSPACT, 1);
            .                       }
            .           
            .                       if (mve_no_pred(env)) {
            .                           DP_TBFLAG_M32(flags, MVE_NO_PRED, 1);
            .                       }
            .                   } else {
            .                       /*
-- line 11476 ----------------------------------------
-- line 11483 ----------------------------------------
            .                           DP_TBFLAG_A32(flags, VECLEN, env->vfp.vec_len);
            .                           DP_TBFLAG_A32(flags, VECSTRIDE, env->vfp.vec_stride);
            .                       }
            .                       if (env->vfp.xregs[ARM_VFP_FPEXC] & (1 << 30)) {
            .                           DP_TBFLAG_A32(flags, VFPEN, 1);
            .                       }
            .                   }
            .           
  178,860,278 ( 0.25%)          DP_TBFLAG_AM32(flags, THUMB, env->thumb);
  178,860,278 ( 0.25%)          DP_TBFLAG_AM32(flags, CONDEXEC, env->condexec_bits);
            .               }
            .           
            .               /*
            .                * The SS_ACTIVE and PSTATE_SS bits correspond to the state machine
            .                * states defined in the ARM ARM for software singlestep:
            .                *  SS_ACTIVE   PSTATE.SS   State
            .                *     0            x       Inactive (the TB flag for SS is always 0)
            .                *     1            0       Active-pending
            .                *     1            1       Active-not-pending
            .                * SS_ACTIVE is set in hflags; PSTATE__SS is computed every TB.
            .                */
  357,720,556 ( 0.49%)      if (EX_TBFLAG_ANY(flags, SS_ACTIVE) && (env->pstate & PSTATE_SS)) {
            .                   DP_TBFLAG_ANY(flags, PSTATE__SS, 1);
            .               }
            .           
  178,860,278 ( 0.25%)      *pflags = flags.flags;
  178,860,278 ( 0.25%)      *cs_base = flags.flags2;
  178,860,278 ( 0.25%)  }
            .           
            .           #ifdef TARGET_AARCH64
            .           /*
            .            * The manual says that when SVE is enabled and VQ is widened the
            .            * implementation is allowed to zero the previously inaccessible
            .            * portion of the registers.  The corollary to that is that when
            .            * SVE is enabled and VQ is narrowed we are also allowed to zero
            .            * the now inaccessible portion of the registers.
-- line 11518 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/cpu-common.c
--------------------------------------------------------------------------------
Ir                 

-- line 64 ----------------------------------------
        .                   exit(EXIT_FAILURE);
        .               }
        .               return cpu;
        .           }
        .           
        .           /* Resetting the IRQ comes from across the code base so we take the
        .            * BQL here if we need to.  cpu_interrupt assumes it is held.*/
        .           void cpu_reset_interrupt(CPUState *cpu, int mask)
6,244,692 ( 0.01%)  {
1,040,782 ( 0.00%)      bool need_lock = !qemu_mutex_iothread_locked();
22,897,204 ( 0.03%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:qemu_mutex_iothread_locked (1,040,782x)
        .           
2,081,564 ( 0.00%)      if (need_lock) {
        .                   qemu_mutex_lock_iothread();
        .               }
2,081,564 ( 0.00%)      cpu->interrupt_request &= ~mask;
        .               if (need_lock) {
        .                   qemu_mutex_unlock_iothread();
        .               }
4,163,128 ( 0.01%)  }
        .           
        .           void cpu_exit(CPUState *cpu)
        .           {
        .               qatomic_set(&cpu->exit_request, 1);
        .               /* Ensure cpu_exec will see the exit request after TCG has exited.  */
        .               smp_wmb();
        .               qatomic_set(&cpu->icount_decr_ptr->u16.high, -1);
        .           }
-- line 90 ----------------------------------------
-- line 105 ----------------------------------------
        .           
        .               if (cc->dump_state) {
        .                   cpu_synchronize_state(cpu);
        .                   cc->dump_state(cpu, f, flags);
        .               }
        .           }
        .           
        .           void cpu_reset(CPUState *cpu)
        4 ( 0.00%)  {
        2 ( 0.00%)      device_cold_reset(DEVICE(cpu));
   77,939 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/qdev.c:device_cold_reset (2x)
        .           
        .               trace_guest_cpu_reset(cpu);
        2 ( 0.00%)  }
        .           
        .           static void cpu_common_reset(DeviceState *dev)
        6 ( 0.00%)  {
        .               CPUState *cpu = CPU(dev);
        .               CPUClass *cc = CPU_GET_CLASS(cpu);
        .           
        .               if (qemu_loglevel_mask(CPU_LOG_RESET)) {
        .                   qemu_log("CPU Reset (CPU %d)\n", cpu->cpu_index);
        .                   log_cpu_state(cpu, cc->reset_dump_flags);
        .               }
        .           
        2 ( 0.00%)      cpu->interrupt_request = 0;
        4 ( 0.00%)      cpu->halted = cpu->start_powered_off;
        2 ( 0.00%)      cpu->mem_io_pc = 0;
        2 ( 0.00%)      cpu->icount_extra = 0;
        4 ( 0.00%)      qatomic_set(&cpu->icount_decr_ptr->u32, 0);
        4 ( 0.00%)      cpu->can_do_io = 1;
        .               cpu->exception_index = -1;
        2 ( 0.00%)      cpu->crash_occurred = false;
        2 ( 0.00%)      cpu->cflags_next_tb = -1;
        .           
        6 ( 0.00%)      if (tcg_enabled()) {
        4 ( 0.00%)          tcg_flush_jmp_cache(cpu);
   32,782 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/translate-all.c:tcg_flush_jmp_cache (2x)
        4 ( 0.00%)          tcg_flush_softmmu_tlb(cpu);
   33,094 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/translate-all.c:tcg_flush_softmmu_tlb (2x)
        .               }
        2 ( 0.00%)  }
        .           
        .           static bool cpu_common_has_work(CPUState *cs)
        .           {
        .               return false;
        .           }
        .           
        .           ObjectClass *cpu_class_by_name(const char *typename, const char *cpu_model)
        .           {
-- line 151 ----------------------------------------
-- line 182 ----------------------------------------
        .                                  featurestr);
        .                       return;
        .                   }
        .                   featurestr = strtok(NULL, ",");
        .               }
        .           }
        .           
        .           static void cpu_common_realizefn(DeviceState *dev, Error **errp)
        5 ( 0.00%)  {
        .               CPUState *cpu = CPU(dev);
        2 ( 0.00%)      Object *machine = qdev_get_machine();
        5 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/qdev.c:qdev_get_machine (1x)
        .           
        .               /* qdev_get_machine() can return something that's not TYPE_MACHINE
        .                * if this is one of the user-only emulators; in that case there's
        .                * no need to check the ignore_memory_transaction_failures board flag.
        .                */
        6 ( 0.00%)      if (object_dynamic_cast(machine, TYPE_MACHINE)) {
      245 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_dynamic_cast (1x)
        3 ( 0.00%)          ObjectClass *oc = object_get_class(machine);
        3 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_get_class (1x)
        .                   MachineClass *mc = MACHINE_CLASS(oc);
        .           
        2 ( 0.00%)          if (mc) {
        1 ( 0.00%)              cpu->ignore_memory_transaction_failures =
        1 ( 0.00%)                  mc->ignore_memory_transaction_failures;
        .                   }
        .               }
        .           
        3 ( 0.00%)      if (dev->hotplugged) {
        .                   cpu_synchronize_post_init(cpu);
        .                   cpu_resume(cpu);
        .               }
        .           
        .               /* NOTE: latest generic point where the cpu is fully realized */
        2 ( 0.00%)      trace_init_vcpu(cpu);
   65,572 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../trace/control-target.c:trace_init_vcpu (1x)
        3 ( 0.00%)  }
        .           
        .           static void cpu_common_unrealizefn(DeviceState *dev)
        .           {
        .               CPUState *cpu = CPU(dev);
        .           
        .               /* NOTE: latest generic point before the cpu is fully unrealized */
        .               trace_fini_vcpu(cpu);
        .               cpu_exec_unrealizefn(cpu);
        .           }
        .           
        .           static void cpu_common_initfn(Object *obj)
        3 ( 0.00%)  {
        .               CPUState *cpu = CPU(obj);
        .               CPUClass *cc = CPU_GET_CLASS(obj);
        .           
        1 ( 0.00%)      cpu->cpu_index = UNASSIGNED_CPU_INDEX;
        .               cpu->cluster_index = UNASSIGNED_CLUSTER_INDEX;
        3 ( 0.00%)      cpu->gdb_num_regs = cpu->gdb_num_g_regs = cc->gdb_num_core_regs;
        .               /* *-user doesn't have configurable SMP topology */
        .               /* the default value is changed by qemu_init_vcpu() for softmmu */
        2 ( 0.00%)      cpu->nr_cores = 1;
        .               cpu->nr_threads = 1;
        .           
        2 ( 0.00%)      qemu_mutex_init(&cpu->work_mutex);
       42 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_mutex_init (1x)
        3 ( 0.00%)      QSIMPLEQ_INIT(&cpu->work_list);
        3 ( 0.00%)      QTAILQ_INIT(&cpu->breakpoints);
        3 ( 0.00%)      QTAILQ_INIT(&cpu->watchpoints);
        .           
        2 ( 0.00%)      cpu_exec_initfn(cpu);
       45 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../cpu.c:cpu_exec_initfn (1x)
        1 ( 0.00%)  }
        .           
        .           static void cpu_common_finalize(Object *obj)
        .           {
        .               CPUState *cpu = CPU(obj);
        .           
        .               qemu_mutex_destroy(&cpu->work_mutex);
        .           }
        .           
        .           static int64_t cpu_common_get_arch_id(CPUState *cpu)
        .           {
        .               return cpu->cpu_index;
        .           }
        .           
        .           static void cpu_class_init(ObjectClass *klass, void *data)
        5 ( 0.00%)  {
        .               DeviceClass *dc = DEVICE_CLASS(klass);
        .               CPUClass *k = CPU_CLASS(klass);
        .           
        2 ( 0.00%)      k->parse_features = cpu_common_parse_features;
        2 ( 0.00%)      k->get_arch_id = cpu_common_get_arch_id;
        2 ( 0.00%)      k->has_work = cpu_common_has_work;
        2 ( 0.00%)      k->gdb_read_register = cpu_common_gdb_read_register;
        2 ( 0.00%)      k->gdb_write_register = cpu_common_gdb_write_register;
        .               set_bit(DEVICE_CATEGORY_CPU, dc->categories);
        2 ( 0.00%)      dc->realize = cpu_common_realizefn;
        2 ( 0.00%)      dc->unrealize = cpu_common_unrealizefn;
        2 ( 0.00%)      dc->reset = cpu_common_reset;
        2 ( 0.00%)      cpu_class_init_props(dc);
    8,324 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../cpu.c:cpu_class_init_props (1x)
        .               /*
        .                * Reason: CPUs still need special care by board code: wiring up
        .                * IRQs, adding reset handlers, halting non-first CPUs, ...
        .                */
        1 ( 0.00%)      dc->user_creatable = false;
        4 ( 0.00%)  }
        .           
        .           static const TypeInfo cpu_type_info = {
        .               .name = TYPE_CPU,
        .               .parent = TYPE_DEVICE,
        .               .instance_size = sizeof(CPUState),
        .               .instance_init = cpu_common_initfn,
        .               .instance_finalize = cpu_common_finalize,
        .               .abstract = true,
        .               .class_size = sizeof(CPUClass),
        .               .class_init = cpu_class_init,
        .           };
        .           
        .           static void cpu_register_types(void)
        1 ( 0.00%)  {
        2 ( 0.00%)      type_register_static(&cpu_type_info);
    1,948 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_register_static (1x)
        .           }
        .           
        4 ( 0.00%)  type_init(cpu_register_types)
      343 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/module.c:register_module_init (1x)

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c
--------------------------------------------------------------------------------
Ir                  

-- line 33 ----------------------------------------
         .           #include "arm_ldst.h"
         .           #include "exec/cpu_ldst.h"
         .           #include "semihosting/common-semi.h"
         .           #endif
         .           
         .           typedef bool (*do_arm_interrupt_cb)(int32_t exec_index);
         .           do_arm_interrupt_cb do_arm_interrupt_func;
         .           void xx_register_arm_do_interrupt_hook(do_arm_interrupt_cb cb)
         1 ( 0.00%)  {
         2 ( 0.00%)      do_arm_interrupt_func = cb;
         1 ( 0.00%)  }
         .           
         .           static void v7m_msr_xpsr(CPUARMState *env, uint32_t mask,
         .                                    uint32_t reg, uint32_t val)
         .           {
         .               /* Only APSR is actually writable */
         .               if (!(reg & 4)) {
         .                   uint32_t apsrmask = 0;
         .           
-- line 51 ----------------------------------------
-- line 58 ----------------------------------------
         .                   xpsr_write(env, val, apsrmask);
         .               }
         .           }
         .           
         .           static uint32_t v7m_mrs_xpsr(CPUARMState *env, uint32_t reg, unsigned el)
         .           {
         .               uint32_t mask = 0;
         .           
 1,319,880 ( 0.00%)      if ((reg & 1) && el) {
   329,970 ( 0.00%)          mask |= XPSR_EXCP; /* IPSR (unpriv. reads as zero) */
         .               }
   659,940 ( 0.00%)      if (!(reg & 4)) {
         .                   mask |= XPSR_NZCV | XPSR_Q; /* APSR */
         .                   if (arm_feature(env, ARM_FEATURE_THUMB_DSP)) {
         .                       mask |= XPSR_GE;
         .                   }
         .               }
         .               /* EPSR reads as zero */
   329,970 ( 0.00%)      return xpsr_read(env) & mask;
         .           }
         .           
         .           static uint32_t v7m_mrs_control(CPUARMState *env, uint32_t secure)
         .           {
         .               uint32_t value = env->v7m.control[secure];
         .           
    37,204 ( 0.00%)      if (!secure) {
         .                   /* SFPA is RAZ/WI from NS; FPCA is stored in the M_REG_S bank */
    74,408 ( 0.00%)          value |= env->v7m.control[M_REG_S] & R_V7M_CONTROL_FPCA_MASK;
         .               }
         .               return value;
         .           }
         .           
         .           #ifdef CONFIG_USER_ONLY
         .           
         .           void HELPER(v7m_msr)(CPUARMState *env, uint32_t maskreg, uint32_t val)
         .           {
-- line 93 ----------------------------------------
-- line 182 ----------------------------------------
         .           typedef enum StackingMode {
         .               STACK_NORMAL,
         .               STACK_IGNFAULTS,
         .               STACK_LAZYFP,
         .           } StackingMode;
         .           
         .           static bool v7m_stack_write(ARMCPU *cpu, uint32_t addr, uint32_t value,
         .                                       ARMMMUIdx mmu_idx, StackingMode mode)
59,820,210 ( 0.08%)  {
         .               CPUState *cs = CPU(cpu);
 3,988,014 ( 0.01%)      CPUARMState *env = &cpu->env;
         .               MemTxResult txres;
15,952,056 ( 0.02%)      GetPhysAddrResult res = {};
 7,976,028 ( 0.01%)      ARMMMUFaultInfo fi = {};
         .               bool secure = mmu_idx & ARM_MMU_IDX_M_S;
         .               int exc;
         .               bool exc_secure;
         .           
23,928,084 ( 0.03%)      if (get_phys_addr(env, addr, MMU_DATA_STORE, mmu_idx, &res, &fi)) {
777,662,730 ( 1.07%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/ptw.c:get_phys_addr (3,988,014x)
         .                   /* MPU/SAU lookup failed */
         .                   if (fi.type == ARMFault_QEMU_SFault) {
         .                       if (mode == STACK_LAZYFP) {
         .                           qemu_log_mask(CPU_LOG_INT,
         .                                         "...SecureFault with SFSR.LSPERR "
         .                                         "during lazy stacking\n");
         .                           env->v7m.sfsr |= R_V7M_SFSR_LSPERR_MASK;
         .                       } else {
-- line 208 ----------------------------------------
-- line 225 ----------------------------------------
         .                                         "...MemManageFault with CFSR.MSTKERR\n");
         .                           env->v7m.cfsr[secure] |= R_V7M_CFSR_MSTKERR_MASK;
         .                       }
         .                       exc = ARMV7M_EXCP_MEM;
         .                       exc_secure = secure;
         .                   }
         .                   goto pend_fault;
         .               }
23,928,084 ( 0.03%)      address_space_stl_le(arm_addressspace(cs, res.f.attrs), res.f.phys_addr,
1,764,689,528 ( 2.42%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/memory_ldst.c.inc:address_space_stl_le (3,988,014x)
         .                                    value, res.f.attrs, &txres);
11,964,042 ( 0.02%)      if (txres != MEMTX_OK) {
         .                   /* BusFault trying to write the data */
         .                   if (mode == STACK_LAZYFP) {
         .                       qemu_log_mask(CPU_LOG_INT, "...BusFault with BFSR.LSPERR\n");
         .                       env->v7m.cfsr[M_REG_NS] |= R_V7M_CFSR_LSPERR_MASK;
         .                   } else {
         .                       qemu_log_mask(CPU_LOG_INT, "...BusFault with BFSR.STKERR\n");
         .                       env->v7m.cfsr[M_REG_NS] |= R_V7M_CFSR_STKERR_MASK;
         .                   }
         .                   exc = ARMV7M_EXCP_BUS;
         .                   exc_secure = false;
         .                   goto pend_fault;
         .               }
 3,988,014 ( 0.01%)      return true;
         .           
         .           pend_fault:
         .               /*
         .                * By pending the exception at this point we are making
         .                * the IMPDEF choice "overridden exceptions pended" (see the
         .                * MergeExcInfo() pseudocode). The other choice would be to not
         .                * pend them now and then make a choice about which to throw away
         .                * later if we have two derived exceptions.
-- line 256 ----------------------------------------
-- line 266 ----------------------------------------
         .                   break;
         .               case STACK_LAZYFP:
         .                   armv7m_nvic_set_pending_lazyfp(env->nvic, exc, exc_secure);
         .                   break;
         .               case STACK_IGNFAULTS:
         .                   break;
         .               }
         .               return false;
43,868,154 ( 0.06%)  }
         .           
         .           static bool v7m_stack_read(ARMCPU *cpu, uint32_t *dest, uint32_t addr,
         .                                      ARMMMUIdx mmu_idx)
47,278,848 ( 0.06%)  {
         .               CPUState *cs = CPU(cpu);
 3,939,904 ( 0.01%)      CPUARMState *env = &cpu->env;
         .               MemTxResult txres;
15,759,616 ( 0.02%)      GetPhysAddrResult res = {};
 7,879,808 ( 0.01%)      ARMMMUFaultInfo fi = {};
         .               bool secure = mmu_idx & ARM_MMU_IDX_M_S;
         .               int exc;
         .               bool exc_secure;
         .               uint32_t value;
         .           
27,579,328 ( 0.04%)      if (get_phys_addr(env, addr, MMU_DATA_LOAD, mmu_idx, &res, &fi)) {
768,281,280 ( 1.05%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/ptw.c:get_phys_addr (3,939,904x)
         .                   /* MPU/SAU lookup failed */
         .                   if (fi.type == ARMFault_QEMU_SFault) {
         .                       qemu_log_mask(CPU_LOG_INT,
         .                                     "...SecureFault with SFSR.AUVIOL during unstack\n");
         .                       env->v7m.sfsr |= R_V7M_SFSR_AUVIOL_MASK | R_V7M_SFSR_SFARVALID_MASK;
         .                       env->v7m.sfar = addr;
         .                       exc = ARMV7M_EXCP_SECURE;
         .                       exc_secure = false;
-- line 297 ----------------------------------------
-- line 300 ----------------------------------------
         .                                     "...MemManageFault with CFSR.MUNSTKERR\n");
         .                       env->v7m.cfsr[secure] |= R_V7M_CFSR_MUNSTKERR_MASK;
         .                       exc = ARMV7M_EXCP_MEM;
         .                       exc_secure = secure;
         .                   }
         .                   goto pend_fault;
         .               }
         .           
19,699,520 ( 0.03%)      value = address_space_ldl(arm_addressspace(cs, res.f.attrs),
836,829,487 ( 1.15%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/memory_ldst.c.inc:address_space_ldl (3,939,904x)
         .                                         res.f.phys_addr, res.f.attrs, &txres);
11,819,712 ( 0.02%)      if (txres != MEMTX_OK) {
         .                   /* BusFault trying to read the data */
         .                   qemu_log_mask(CPU_LOG_INT, "...BusFault with BFSR.UNSTKERR\n");
         .                   env->v7m.cfsr[M_REG_NS] |= R_V7M_CFSR_UNSTKERR_MASK;
         .                   exc = ARMV7M_EXCP_BUS;
         .                   exc_secure = false;
         .                   goto pend_fault;
         .               }
         .           
 3,939,904 ( 0.01%)      *dest = value;
 7,879,808 ( 0.01%)      return true;
         .           
         .           pend_fault:
         .               /*
         .                * By pending the exception at this point we are making
         .                * the IMPDEF choice "overridden exceptions pended" (see the
         .                * MergeExcInfo() pseudocode). The other choice would be to not
         .                * pend them now and then make a choice about which to throw away
         .                * later if we have two derived exceptions.
         .                */
         .               armv7m_nvic_set_pending(env->nvic, exc, exc_secure);
         .               return false;
35,459,136 ( 0.05%)  }
         .           
         .           void HELPER(v7m_preserve_fp_state)(CPUARMState *env)
    25,470 ( 0.00%)  {
         .               /*
         .                * Preserve FP state (because LSPACT was set and we are about
         .                * to execute an FP instruction). This corresponds to the
         .                * PreserveFPState() pseudocode.
         .                * We may throw an exception if the stacking fails.
         .                */
         .               ARMCPU *cpu = env_archcpu(env);
     5,660 ( 0.00%)      bool is_secure = env->v7m.fpccr[M_REG_S] & R_V7M_FPCCR_S_MASK;
    11,320 ( 0.00%)      bool negpri = !(env->v7m.fpccr[M_REG_S] & R_V7M_FPCCR_HFRDY_MASK);
    39,620 ( 0.00%)      bool is_priv = !(env->v7m.fpccr[is_secure] & R_V7M_FPCCR_USER_MASK);
     2,830 ( 0.00%)      bool splimviol = env->v7m.fpccr[is_secure] & R_V7M_FPCCR_SPLIMVIOL_MASK;
     5,660 ( 0.00%)      uint32_t fpcar = env->v7m.fpcar[is_secure];
         .               bool stacked_ok = true;
    11,320 ( 0.00%)      bool ts = is_secure && (env->v7m.fpccr[M_REG_S] & R_V7M_FPCCR_TS_MASK);
         .               bool take_exception;
         .           
         .               /* Take the iothread lock as we are going to touch the NVIC */
     8,490 ( 0.00%)      qemu_mutex_lock_iothread();
   183,950 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:qemu_mutex_lock_iothread_impl (2,830x)
         .           
         .               /* Check the background context had access to the FPU */
         .               if (!v7m_cpacr_pass(env, is_secure, is_priv)) {
         .                   armv7m_nvic_set_pending_lazyfp(env->nvic, ARMV7M_EXCP_USAGE, is_secure);
         .                   env->v7m.cfsr[is_secure] |= R_V7M_CFSR_NOCP_MASK;
         .                   stacked_ok = false;
    11,320 ( 0.00%)      } else if (!is_secure && !extract32(env->v7m.nsacr, 10, 1)) {
         .                   armv7m_nvic_set_pending_lazyfp(env->nvic, ARMV7M_EXCP_USAGE, M_REG_S);
         .                   env->v7m.cfsr[M_REG_S] |= R_V7M_CFSR_NOCP_MASK;
         .                   stacked_ok = false;
         .               }
         .           
     5,660 ( 0.00%)      if (!splimviol && stacked_ok) {
         .                   /* We only stack if the stack limit wasn't violated */
         .                   int i;
         .                   ARMMMUIdx mmu_idx;
         .           
    39,620 ( 0.00%)          mmu_idx = arm_v7m_mmu_idx_all(env, is_secure, is_priv, negpri);
    33,960 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:arm_v7m_mmu_idx_all (2,830x)
    73,580 ( 0.00%)          for (i = 0; i < (ts ? 32 : 16); i += 2) {
    67,920 ( 0.00%)              uint64_t dn = *aa32_vfp_dreg(env, i / 2);
         .                       uint32_t faddr = fpcar + 4 * i;
         .                       uint32_t slo = extract64(dn, 0, 32);
         .                       uint32_t shi = extract64(dn, 32, 32);
         .           
    45,280 ( 0.00%)              if (i >= 16) {
         .                           faddr += 8; /* skip the slot for the FPSCR/VPR */
         .                       }
    90,560 ( 0.00%)              stacked_ok = stacked_ok &&
   181,120 ( 0.00%)                  v7m_stack_write(cpu, faddr, slo, mmu_idx, STACK_LAZYFP) &&
15,825,360 ( 0.02%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:v7m_stack_write (22,640x)
   249,040 ( 0.00%)                  v7m_stack_write(cpu, faddr + 4, shi, mmu_idx, STACK_LAZYFP);
15,825,360 ( 0.02%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:v7m_stack_write (22,640x)
         .                   }
         .           
    14,150 ( 0.00%)          stacked_ok = stacked_ok &&
    25,470 ( 0.00%)              v7m_stack_write(cpu, fpcar + 0x40,
 1,978,170 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:v7m_stack_write (2,830x)
   124,520 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/vfp_helper.c:vfp_get_fpscr (2,830x)
         .                                       vfp_get_fpscr(env), mmu_idx, STACK_LAZYFP);
         .                   if (cpu_isar_feature(aa32_mve, cpu)) {
         .                       stacked_ok = stacked_ok &&
         .                           v7m_stack_write(cpu, fpcar + 0x44,
         .                                           env->v7m.vpr, mmu_idx, STACK_LAZYFP);
         .                   }
         .               }
         .           
-- line 395 ----------------------------------------
-- line 396 ----------------------------------------
         .               /*
         .                * We definitely pended an exception, but it's possible that it
         .                * might not be able to be taken now. If its priority permits us
         .                * to take it now, then we must not update the LSPACT or FP regs,
         .                * but instead jump out to take the exception immediately.
         .                * If it's just pending and won't be taken until the current
         .                * handler exits, then we do update LSPACT and the FP regs.
         .                */
     5,660 ( 0.00%)      take_exception = !stacked_ok &&
         .                   armv7m_nvic_can_take_pending_exception(env->nvic);
         .           
     2,830 ( 0.00%)      qemu_mutex_unlock_iothread();
   161,310 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:qemu_mutex_unlock_iothread (2,830x)
         .           
         .               if (take_exception) {
         .                   raise_exception_ra(env, EXCP_LAZYFP, 0, 1, GETPC());
         .               }
         .           
     2,830 ( 0.00%)      env->v7m.fpccr[is_secure] &= ~R_V7M_FPCCR_LSPACT_MASK;
         .           
     8,490 ( 0.00%)      if (ts) {
         .                   /* Clear s0 to s31 and the FPSCR and VPR */
         .                   int i;
         .           
         .                   for (i = 0; i < 32; i += 2) {
         .                       *aa32_vfp_dreg(env, i / 2) = 0;
         .                   }
         .                   vfp_set_fpscr(env, 0);
         .                   if (cpu_isar_feature(aa32_mve, cpu)) {
         .                       env->v7m.vpr = 0;
         .                   }
         .               }
         .               /*
         .                * Otherwise s0 to s15, FPSCR and VPR are UNKNOWN; we choose to leave them
         .                * unchanged.
         .                */
    22,640 ( 0.00%)  }
         .           
         .           /*
         .            * Write to v7M CONTROL.SPSEL bit for the specified security bank.
         .            * This may change the current stack pointer between Main and Process
         .            * stack pointers if it is done for the CONTROL register for the current
         .            * security state.
         .            */
         .           static void write_v7m_control_spsel_for_secstate(CPUARMState *env,
         .                                                            bool new_spsel,
         .                                                            bool secstate)
   984,976 ( 0.00%)  {
         .               bool old_is_psp = v7m_using_psp(env);
         .           
   984,976 ( 0.00%)      env->v7m.control[secstate] =
 3,939,904 ( 0.01%)          deposit32(env->v7m.control[secstate],
         .                             R_V7M_CONTROL_SPSEL_SHIFT,
         .                             R_V7M_CONTROL_SPSEL_LENGTH, new_spsel);
         .           
   984,976 ( 0.00%)      if (secstate == env->v7m.secure) {
         .                   bool new_is_psp = v7m_using_psp(env);
         .                   uint32_t tmp;
         .           
         .                   if (old_is_psp != new_is_psp) {
         .                       tmp = env->v7m.other_sp;
         .                       env->v7m.other_sp = env->regs[13];
         .                       env->regs[13] = tmp;
         .                   }
-- line 458 ----------------------------------------
-- line 460 ----------------------------------------
         .           }
         .           
         .           /*
         .            * Write to v7M CONTROL.SPSEL bit. This may change the current
         .            * stack pointer between Main and Process stack pointers.
         .            */
         .           static void write_v7m_control_spsel(CPUARMState *env, bool new_spsel)
         .           {
 2,954,928 ( 0.00%)      write_v7m_control_spsel_for_secstate(env, new_spsel, env->v7m.secure);
 7,387,320 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:write_v7m_control_spsel_for_secstate (492,488x)
         .           }
         .           
         .           void write_v7m_exception(CPUARMState *env, uint32_t new_exc)
   984,976 ( 0.00%)  {
         .               /*
         .                * Write a new value to v7m.exception, thus transitioning into or out
         .                * of Handler mode; this may result in a change of active stack pointer.
         .                */
         .               bool new_is_psp, old_is_psp = v7m_using_psp(env);
         .               uint32_t tmp;
         .           
   984,976 ( 0.00%)      env->v7m.exception = new_exc;
         .           
         .               new_is_psp = v7m_using_psp(env);
         .           
   984,976 ( 0.00%)      if (old_is_psp != new_is_psp) {
   854,762 ( 0.00%)          tmp = env->v7m.other_sp;
 1,709,524 ( 0.00%)          env->v7m.other_sp = env->regs[13];
   854,762 ( 0.00%)          env->regs[13] = tmp;
         .               }
   984,976 ( 0.00%)  }
         .           
         .           /* Switch M profile security state between NS and S */
         .           static void switch_v7m_security_state(CPUARMState *env, bool new_secstate)
         .           {
         .               uint32_t new_ss_msp, new_ss_psp;
         .           
 3,939,904 ( 0.01%)      if (env->v7m.secure == new_secstate) {
         .                   return;
         .               }
         .           
         .               /*
         .                * All the banked state is accessed by looking at env->v7m.secure
         .                * except for the stack pointer; rearrange the SP appropriately.
         .                */
         .               new_ss_msp = env->v7m.other_ss_msp;
-- line 504 ----------------------------------------
-- line 516 ----------------------------------------
         .           
         .               if (v7m_using_psp(env)) {
         .                   env->regs[13] = new_ss_psp;
         .                   env->v7m.other_sp = new_ss_msp;
         .               } else {
         .                   env->regs[13] = new_ss_msp;
         .                   env->v7m.other_sp = new_ss_psp;
         .               }
   984,976 ( 0.00%)  }
         .           
         .           void HELPER(v7m_bxns)(CPUARMState *env, uint32_t dest)
         .           {
         .               /*
         .                * Handle v7M BXNS:
         .                *  - if the return value is a magic value, do exception return (like BX)
         .                *  - otherwise bit 0 of the return value is the target security state
         .                */
-- line 532 ----------------------------------------
-- line 642 ----------------------------------------
         .                * SPSEL control bit value; this is because we also use this
         .                * function in handling of pushing of the callee-saves registers
         .                * part of the v8M stack frame (pseudocode PushCalleeStack()),
         .                * and in the tailchain codepath the SPSEL bit comes from the exception
         .                * return magic LR value from the previous exception. The pseudocode
         .                * opencodes the stack-selection in PushCalleeStack(), but we prefer
         .                * to make this utility function generic enough to do the job.
         .                */
   492,488 ( 0.00%)      bool want_psp = threadmode && spsel;
         .           
   984,976 ( 0.00%)      if (secure == env->v7m.secure) {
   984,976 ( 0.00%)          if (want_psp == v7m_using_psp(env)) {
   223,224 ( 0.00%)              return &env->regs[13];
         .                   } else {
 1,746,728 ( 0.00%)              return &env->v7m.other_sp;
         .                   }
         .               } else {
         .                   if (want_psp) {
   492,488 ( 0.00%)              return &env->v7m.other_ss_psp;
         .                   } else {
         .                       return &env->v7m.other_ss_msp;
         .                   }
         .               }
         .           }
         .           
         .           static bool arm_v7m_load_vector(ARMCPU *cpu, int exc, bool targets_secure,
         .                                           uint32_t *pvec)
         .           {
         .               CPUState *cs = CPU(cpu);
         .               CPUARMState *env = &cpu->env;
         .               MemTxResult result;
 2,462,440 ( 0.00%)      uint32_t addr = env->v7m.vecbase[targets_secure] + exc * 4;
         .               uint32_t vector_entry;
         .               MemTxAttrs attrs = {};
         .               ARMMMUIdx mmu_idx;
         .               bool exc_secure;
         .           
         .               qemu_log_mask(CPU_LOG_INT,
         .                             "...loading from element %d of %s vector table at 0x%x\n",
         .                             exc, targets_secure ? "secure" : "non-secure", addr);
         .           
 2,954,928 ( 0.00%)      mmu_idx = arm_v7m_mmu_idx_for_secstate_and_priv(env, targets_secure, true);
22,161,960 ( 0.03%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:arm_v7m_mmu_idx_for_secstate_and_priv (492,488x)
         .           
         .               /*
         .                * We don't do a get_phys_addr() here because the rules for vector
         .                * loads are special: they always use the default memory map, and
         .                * the default memory map permits reads from all addresses.
         .                * Since there's no easy way to pass through to pmsav8_mpu_lookup()
         .                * that we want this special case which would always say "yes",
         .                * we just do the SAU lookup here followed by a direct physical load.
         .                */
         .               attrs.secure = targets_secure;
         .               attrs.user = false;
         .           
 1,477,464 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_M_SECURITY)) {
         .                   V8M_SAttributes sattrs = {};
         .           
         .                   v8m_security_lookup(env, addr, MMU_DATA_LOAD, mmu_idx,
         .                                       targets_secure, &sattrs);
         .                   if (sattrs.ns) {
         .                       attrs.secure = false;
         .                   } else if (!targets_secure) {
         .                       /*
-- line 704 ----------------------------------------
-- line 705 ----------------------------------------
         .                        * NS access to S memory: the underlying exception which we escalate
         .                        * to HardFault is SecureFault, which always targets Secure.
         .                        */
         .                       exc_secure = true;
         .                       goto load_fail;
         .                   }
         .               }
         .           
 2,954,928 ( 0.00%)      vector_entry = address_space_ldl(arm_addressspace(cs, attrs), addr,
108,744,512 ( 0.15%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/memory_ldst.c.inc:address_space_ldl (492,488x)
         .                                                attrs, &result);
 1,477,464 ( 0.00%)      if (result != MEMTX_OK) {
         .                   /*
         .                    * Underlying exception is BusFault: its target security state
         .                    * depends on BFHFNMINS.
         .                    */
         .                   exc_secure = !(cpu->env.v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK);
         .                   goto load_fail;
         .               }
         .               *pvec = vector_entry;
-- line 723 ----------------------------------------
-- line 838 ----------------------------------------
         .               /* Update SP regardless of whether any of the stack accesses failed. */
         .               *frame_sp_p = frameptr;
         .           
         .               return !stacked_ok;
         .           }
         .           
         .           static void v7m_exception_taken(ARMCPU *cpu, uint32_t lr, bool dotailchain,
         .                                           bool ignore_stackfaults)
 6,894,832 ( 0.01%)  {
         .               /*
         .                * Do the "take the exception" parts of exception entry,
         .                * but not the pushing of state to the stack. This is
         .                * similar to the pseudocode ExceptionTaken() function.
         .                */
   492,488 ( 0.00%)      CPUARMState *env = &cpu->env;
         .               uint32_t addr;
         .               bool targets_secure;
         .               int exc;
         .               bool push_failed = false;
         .           
 1,969,952 ( 0.00%)      armv7m_nvic_get_pending_irq_info(env->nvic, &exc, &targets_secure);
12,312,200 ( 0.02%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:armv7m_nvic_get_pending_irq_info (492,488x)
         .               qemu_log_mask(CPU_LOG_INT, "...taking pending %s exception %d\n",
         .                             targets_secure ? "secure" : "nonsecure", exc);
         .           
   984,976 ( 0.00%)      if (dotailchain) {
         .                   /* Sanitize LR FType and PREFIX bits */
         .                   if (!cpu_isar_feature(aa32_vfp_simd, cpu)) {
         .                       lr |= R_V7M_EXCRET_FTYPE_MASK;
         .                   }
         .                   lr = deposit32(lr, 24, 8, 0xff);
         .               }
         .           
   984,976 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_V8)) {
         .                   if (arm_feature(env, ARM_FEATURE_M_SECURITY) &&
         .                       (lr & R_V7M_EXCRET_S_MASK)) {
         .                       /*
         .                        * The background code (the owner of the registers in the
         .                        * exception frame) is Secure. This means it may either already
         .                        * have or now needs to push callee-saves registers.
         .                        */
   984,976 ( 0.00%)              if (targets_secure) {
         .                           if (dotailchain && !(lr & R_V7M_EXCRET_ES_MASK)) {
         .                               /*
         .                                * We took an exception from Secure to NonSecure
         .                                * (which means the callee-saved registers got stacked)
         .                                * and are now tailchaining to a Secure exception.
         .                                * Clear DCRS so eventual return from this Secure
         .                                * exception unstacks the callee-saved registers.
         .                                */
-- line 886 ----------------------------------------
-- line 954 ----------------------------------------
         .                    * targets a different security state, so try again from the top.
         .                    */
         .                   qemu_log_mask(CPU_LOG_INT,
         .                                 "...derived exception on callee-saves register stacking");
         .                   v7m_exception_taken(cpu, lr, true, true);
         .                   return;
         .               }
         .           
   492,488 ( 0.00%)      if (!arm_v7m_load_vector(cpu, exc, targets_secure, &addr)) {
         .                   /* Vector load failed: derived exception */
         .                   qemu_log_mask(CPU_LOG_INT, "...derived exception on vector table load");
         .                   v7m_exception_taken(cpu, lr, true, true);
         .                   return;
         .               }
         .           
         .               /*
         .                * Now we've done everything that might cause a derived exception
         .                * we can go ahead and activate whichever exception we're going to
         .                * take (which might now be the derived exception).
         .                */
   984,976 ( 0.00%)      armv7m_nvic_acknowledge_irq(env->nvic);
417,303,824 ( 0.57%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:armv7m_nvic_acknowledge_irq (492,488x)
         .           
         .               /* Switch to target security state -- must do this before writing SPSEL */
 1,477,464 ( 0.00%)      switch_v7m_security_state(env, targets_secure);
 2,462,440 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:switch_v7m_security_state (492,488x)
         .               write_v7m_control_spsel(env, 0);
         .               arm_clear_exclusive(env);
         .               /* Clear SFPA and FPCA (has no effect if no FPU) */
   492,488 ( 0.00%)      env->v7m.control[M_REG_S] &=
         .                   ~(R_V7M_CONTROL_FPCA_MASK | R_V7M_CONTROL_SFPA_MASK);
         .               /* Clear IT bits */
   492,488 ( 0.00%)      env->condexec_bits = 0;
   492,488 ( 0.00%)      env->regs[14] = lr;
 1,477,464 ( 0.00%)      env->regs[15] = addr & 0xfffffffe;
   984,976 ( 0.00%)      env->thumb = addr & 1;
   984,976 ( 0.00%)      arm_rebuild_hflags(env);
91,602,768 ( 0.13%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:arm_rebuild_hflags (492,488x)
 5,417,368 ( 0.01%)  }
         .           
         .           static void v7m_update_fpccr(CPUARMState *env, uint32_t frameptr,
         .                                        bool apply_splim)
 1,797,804 ( 0.00%)  {
         .               /*
         .                * Like the pseudocode UpdateFPCCR: save state in FPCAR and FPCCR
         .                * that we will need later in order to do lazy FP reg stacking.
         .                */
   399,512 ( 0.00%)      bool is_secure = env->v7m.secure;
   199,756 ( 0.00%)      void *nvic = env->nvic;
         .               /*
         .                * Some bits are unbanked and live always in fpccr[M_REG_S]; some bits
         .                * are banked and we want to update the bit in the bank for the
         .                * current security state; and in one case we want to specifically
         .                * update the NS banked version of a bit even if we are secure.
         .                */
         .               uint32_t *fpccr_s = &env->v7m.fpccr[M_REG_S];
         .               uint32_t *fpccr_ns = &env->v7m.fpccr[M_REG_NS];
   799,024 ( 0.00%)      uint32_t *fpccr = &env->v7m.fpccr[is_secure];
         .               bool hfrdy, bfrdy, mmrdy, ns_ufrdy, s_ufrdy, sfrdy, monrdy;
         .           
   799,024 ( 0.00%)      env->v7m.fpcar[is_secure] = frameptr & ~0x7;
         .           
   799,024 ( 0.00%)      if (apply_splim && arm_feature(env, ARM_FEATURE_V8)) {
         .                   bool splimviol;
         .                   uint32_t splim = v7m_sp_limit(env);
         .                   bool ign = armv7m_nvic_neg_prio_requested(nvic, is_secure) &&
         .                       (env->v7m.ccr[is_secure] & R_V7M_CCR_STKOFHFNMIGN_MASK);
         .           
         .                   splimviol = !ign && frameptr < splim;
         .                   *fpccr = FIELD_DP32(*fpccr, V7M_FPCCR, SPLIMVIOL, splimviol);
         .               }
         .           
   199,756 ( 0.00%)      *fpccr = FIELD_DP32(*fpccr, V7M_FPCCR, LSPACT, 1);
         .           
         .               *fpccr_s = FIELD_DP32(*fpccr_s, V7M_FPCCR, S, is_secure);
         .           
         .               *fpccr = FIELD_DP32(*fpccr, V7M_FPCCR, USER, arm_current_el(env) == 0);
         .           
   599,268 ( 0.00%)      *fpccr = FIELD_DP32(*fpccr, V7M_FPCCR, THREAD,
         .                                   !arm_v7m_is_handler_mode(env));
         .           
   799,024 ( 0.00%)      hfrdy = armv7m_nvic_get_ready_status(nvic, ARMV7M_EXCP_HARD, false);
15,181,456 ( 0.02%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:armv7m_nvic_get_ready_status (199,756x)
   199,756 ( 0.00%)      *fpccr_s = FIELD_DP32(*fpccr_s, V7M_FPCCR, HFRDY, hfrdy);
         .           
   799,024 ( 0.00%)      bfrdy = armv7m_nvic_get_ready_status(nvic, ARMV7M_EXCP_BUS, false);
16,579,748 ( 0.02%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:armv7m_nvic_get_ready_status (199,756x)
   199,756 ( 0.00%)      *fpccr_s = FIELD_DP32(*fpccr_s, V7M_FPCCR, BFRDY, bfrdy);
         .           
   799,024 ( 0.00%)      mmrdy = armv7m_nvic_get_ready_status(nvic, ARMV7M_EXCP_MEM, is_secure);
16,379,992 ( 0.02%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:armv7m_nvic_get_ready_status (199,756x)
   199,756 ( 0.00%)      *fpccr = FIELD_DP32(*fpccr, V7M_FPCCR, MMRDY, mmrdy);
         .           
   799,024 ( 0.00%)      ns_ufrdy = armv7m_nvic_get_ready_status(nvic, ARMV7M_EXCP_USAGE, false);
16,379,992 ( 0.02%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:armv7m_nvic_get_ready_status (199,756x)
   199,756 ( 0.00%)      *fpccr_ns = FIELD_DP32(*fpccr_ns, V7M_FPCCR, UFRDY, ns_ufrdy);
         .           
   799,024 ( 0.00%)      monrdy = armv7m_nvic_get_ready_status(nvic, ARMV7M_EXCP_DEBUG, false);
16,579,748 ( 0.02%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:armv7m_nvic_get_ready_status (199,756x)
   199,756 ( 0.00%)      *fpccr_s = FIELD_DP32(*fpccr_s, V7M_FPCCR, MONRDY, monrdy);
         .           
   399,512 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_M_SECURITY)) {
         .                   s_ufrdy = armv7m_nvic_get_ready_status(nvic, ARMV7M_EXCP_USAGE, true);
         .                   *fpccr_s = FIELD_DP32(*fpccr_s, V7M_FPCCR, UFRDY, s_ufrdy);
         .           
         .                   sfrdy = armv7m_nvic_get_ready_status(nvic, ARMV7M_EXCP_SECURE, false);
         .                   *fpccr_s = FIELD_DP32(*fpccr_s, V7M_FPCCR, SFRDY, sfrdy);
         .               }
 1,598,048 ( 0.00%)  }
         .           
         .           void HELPER(v7m_vlstm)(CPUARMState *env, uint32_t fptr)
         .           {
         .               /* fptr is the value of Rn, the frame pointer we store the FP regs to */
         .               ARMCPU *cpu = env_archcpu(env);
         .               bool s = env->v7m.fpccr[M_REG_S] & R_V7M_FPCCR_S_MASK;
         .               bool lspact = env->v7m.fpccr[s] & R_V7M_FPCCR_LSPACT_MASK;
         .               uintptr_t ra = GETPC();
-- line 1062 ----------------------------------------
-- line 1179 ----------------------------------------
         .                       env->v7m.vpr = cpu_ldl_data_ra(env, fptr + 0x44, ra);
         .                   }
         .               }
         .           
         .               env->v7m.control[M_REG_S] |= R_V7M_CONTROL_FPCA_MASK;
         .           }
         .           
         .           static bool v7m_push_stack(ARMCPU *cpu)
 3,939,904 ( 0.01%)  {
         .               /*
         .                * Do the "set up stack frame" part of exception entry,
         .                * similar to pseudocode PushStack().
         .                * Return true if we generate a derived exception (and so
         .                * should ignore further stack faults trying to process
         .                * that derived exception.)
         .                */
         .               bool stacked_ok = true, limitviol = false;
   492,488 ( 0.00%)      CPUARMState *env = &cpu->env;
         .               uint32_t xpsr = xpsr_read(env);
   492,488 ( 0.00%)      uint32_t frameptr = env->regs[13];
 1,477,464 ( 0.00%)      ARMMMUIdx mmu_idx = arm_mmu_idx(env);
37,921,576 ( 0.05%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:arm_mmu_idx (492,488x)
         .               uint32_t framesize;
         .               bool nsacr_cp10 = extract32(env->v7m.nsacr, 10, 1);
         .           
 1,876,976 ( 0.00%)      if ((env->v7m.control[M_REG_S] & R_V7M_CONTROL_FPCA_MASK) &&
   492,488 ( 0.00%)          (env->v7m.secure || nsacr_cp10)) {
         .                   if (env->v7m.secure &&
         .                       env->v7m.fpccr[M_REG_S] & R_V7M_FPCCR_TS_MASK) {
         .                       framesize = 0xa8;
         .                   } else {
         .                       framesize = 0x68;
         .                   }
         .               } else {
 1,091,756 ( 0.00%)          framesize = 0x20;
         .               }
         .           
         .               /* Align stack pointer if the guest wants that */
 1,969,952 ( 0.00%)      if ((frameptr & 4) &&
         .                   (env->v7m.ccr[env->v7m.secure] & R_V7M_CCR_STKALIGN_MASK)) {
         .                   frameptr -= 4;
         .                   xpsr |= XPSR_SPREALIGN;
         .               }
         .           
   492,488 ( 0.00%)      xpsr &= ~XPSR_SFPA;
   785,220 ( 0.00%)      if (env->v7m.secure &&
         .                   (env->v7m.control[M_REG_S] & R_V7M_CONTROL_SFPA_MASK)) {
         .                   xpsr |= XPSR_SFPA;
         .               }
         .           
   492,488 ( 0.00%)      frameptr -= framesize;
         .           
   984,976 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_V8)) {
         .                   uint32_t limit = v7m_sp_limit(env);
         .           
         .                   if (frameptr < limit) {
         .                       /*
         .                        * Stack limit failure: set SP to the limit value, and generate
         .                        * STKOF UsageFault. Stack pushes below the limit must not be
         .                        * performed. It is IMPDEF whether pushes above the limit are
         .                        * performed; we choose not to.
-- line 1238 ----------------------------------------
-- line 1255 ----------------------------------------
         .               }
         .           
         .               /*
         .                * Write as much of the stack frame as we can. If we fail a stack
         .                * write this will result in a derived exception being pended
         .                * (which may be taken in preference to the one we started with
         .                * if it has higher priority).
         .                */
   984,976 ( 0.00%)      stacked_ok = stacked_ok &&
 3,939,904 ( 0.01%)          v7m_stack_write(cpu, frameptr, env->regs[0], mmu_idx, STACK_NORMAL) &&
349,003,920 ( 0.48%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:v7m_stack_write (492,488x)
 2,954,928 ( 0.00%)          v7m_stack_write(cpu, frameptr + 4, env->regs[1],
344,993,192 ( 0.47%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:v7m_stack_write (492,488x)
   984,976 ( 0.00%)                          mmu_idx, STACK_NORMAL) &&
 2,954,928 ( 0.00%)          v7m_stack_write(cpu, frameptr + 8, env->regs[2],
344,993,192 ( 0.47%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:v7m_stack_write (492,488x)
   984,976 ( 0.00%)                          mmu_idx, STACK_NORMAL) &&
 2,954,928 ( 0.00%)          v7m_stack_write(cpu, frameptr + 12, env->regs[3],
344,993,192 ( 0.47%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:v7m_stack_write (492,488x)
   984,976 ( 0.00%)                          mmu_idx, STACK_NORMAL) &&
 2,954,928 ( 0.00%)          v7m_stack_write(cpu, frameptr + 16, env->regs[12],
344,993,192 ( 0.47%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:v7m_stack_write (492,488x)
   984,976 ( 0.00%)                          mmu_idx, STACK_NORMAL) &&
 2,954,928 ( 0.00%)          v7m_stack_write(cpu, frameptr + 20, env->regs[14],
344,993,192 ( 0.47%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:v7m_stack_write (492,488x)
   984,976 ( 0.00%)                          mmu_idx, STACK_NORMAL) &&
 2,954,928 ( 0.00%)          v7m_stack_write(cpu, frameptr + 24, env->regs[15],
344,993,192 ( 0.47%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:v7m_stack_write (492,488x)
         .                                   mmu_idx, STACK_NORMAL) &&
 3,447,416 ( 0.00%)          v7m_stack_write(cpu, frameptr + 28, xpsr, mmu_idx, STACK_NORMAL);
344,993,192 ( 0.47%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:v7m_stack_write (492,488x)
         .           
 1,184,732 ( 0.00%)      if (env->v7m.control[M_REG_S] & R_V7M_CONTROL_FPCA_MASK) {
         .                   /* FPU is active, try to save its registers */
   599,268 ( 0.00%)          bool fpccr_s = env->v7m.fpccr[M_REG_S] & R_V7M_FPCCR_S_MASK;
   199,756 ( 0.00%)          bool lspact = env->v7m.fpccr[fpccr_s] & R_V7M_FPCCR_LSPACT_MASK;
         .           
   399,512 ( 0.00%)          if (lspact && arm_feature(env, ARM_FEATURE_M_SECURITY)) {
         .                       qemu_log_mask(CPU_LOG_INT,
         .                                     "...SecureFault because LSPACT and FPCA both set\n");
         .                       env->v7m.sfsr |= R_V7M_SFSR_LSERR_MASK;
         .                       armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_SECURE, false);
   799,024 ( 0.00%)          } else if (!env->v7m.secure && !nsacr_cp10) {
         .                       qemu_log_mask(CPU_LOG_INT,
         .                                     "...Secure UsageFault with CFSR.NOCP because "
         .                                     "NSACR.CP10 prevents stacking FP regs\n");
         .                       armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_USAGE, M_REG_S);
         .                       env->v7m.cfsr[M_REG_S] |= R_V7M_CFSR_NOCP_MASK;
         .                   } else {
   399,512 ( 0.00%)              if (!(env->v7m.fpccr[M_REG_S] & R_V7M_FPCCR_LSPEN_MASK)) {
         .                           /* Lazy stacking disabled, save registers now */
         .                           int i;
         .                           bool cpacr_pass = v7m_cpacr_pass(env, env->v7m.secure,
         .                                                            arm_current_el(env) != 0);
         .           
         .                           if (stacked_ok && !cpacr_pass) {
         .                               /*
         .                                * Take UsageFault if CPACR forbids access. The pseudocode
-- line 1304 ----------------------------------------
-- line 1343 ----------------------------------------
         .                               }
         .                               vfp_set_fpscr(env, 0);
         .                               if (cpu_isar_feature(aa32_mve, cpu)) {
         .                                   env->v7m.vpr = 0;
         .                               }
         .                           }
         .                       } else {
         .                           /* Lazy stacking enabled, save necessary info to stack later */
   998,780 ( 0.00%)                  v7m_update_fpccr(env, frameptr + 0x20, true);
103,873,120 ( 0.14%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:v7m_update_fpccr (199,756x)
         .                       }
         .                   }
         .               }
         .           
         .               /*
         .                * If we broke a stack limit then SP was already updated earlier;
         .                * otherwise we update SP regardless of whether any of the stack
         .                * accesses failed or we took some other kind of fault.
         .                */
   399,512 ( 0.00%)      if (!limitviol) {
   492,488 ( 0.00%)          env->regs[13] = frameptr;
         .               }
         .           
   892,000 ( 0.00%)      return !stacked_ok;
 3,939,904 ( 0.01%)  }
         .           
         .           static void do_v7m_exception_exit(ARMCPU *cpu)
         .           {
   984,976 ( 0.00%)      CPUARMState *env = &cpu->env;
         .               uint32_t excret;
         .               uint32_t xpsr, xpsr_mask;
         .               bool ufault = false;
   492,488 ( 0.00%)      bool sfault = false;
         .               bool return_to_sp_process;
         .               bool return_to_handler;
         .               bool rettobase = false;
         .               bool exc_secure = false;
         .               bool return_to_secure;
         .               bool ftype;
         .               bool restore_s16_s31 = false;
         .           
-- line 1382 ----------------------------------------
-- line 1386 ----------------------------------------
         .                * security extensions the magic secure-function-return has to
         .                * work in thread mode too, so to avoid doing an extra check in
         .                * the generated code we allow exception-exit magic to also cause the
         .                * internal exception and bring us here in thread mode. Correct code
         .                * will never try to do this (the following insn fetch will always
         .                * fault) so we the overhead of having taken an unnecessary exception
         .                * doesn't matter.
         .                */
   984,976 ( 0.00%)      if (!arm_v7m_is_handler_mode(env)) {
         .                   return;
         .               }
         .           
         .               /*
         .                * In the spec pseudocode ExceptionReturn() is called directly
         .                * from BXWritePC() and gets the full target PC value including
         .                * bit zero. In QEMU's implementation we treat it as a normal
         .                * jump-to-register (which is then caught later on), and so split
         .                * the target value up between env->regs[15] and env->thumb in
         .                * gen_bx(). Reconstitute it.
         .                */
         .               excret = env->regs[15];
   984,976 ( 0.00%)      if (env->thumb) {
   492,488 ( 0.00%)          excret |= 1;
         .               }
         .           
         .               qemu_log_mask(CPU_LOG_INT, "Exception return: magic PC %" PRIx32
         .                             " previous exception %d\n",
         .                             excret, env->v7m.exception);
         .           
         .               if ((excret & R_V7M_EXCRET_RES1_MASK) != R_V7M_EXCRET_RES1_MASK) {
         .                   qemu_log_mask(LOG_GUEST_ERROR, "M profile: zero high bits in exception "
         .                                 "exit PC value 0x%" PRIx32 " are UNPREDICTABLE\n",
         .                                 excret);
         .               }
         .           
   492,488 ( 0.00%)      ftype = excret & R_V7M_EXCRET_FTYPE_MASK;
         .           
 1,378,828 ( 0.00%)      if (!ftype && !cpu_isar_feature(aa32_vfp_simd, cpu)) {
         .                   qemu_log_mask(LOG_GUEST_ERROR, "M profile: zero FTYPE in exception "
         .                                 "exit PC value 0x%" PRIx32 " is UNPREDICTABLE "
         .                                 "if FPU not present\n",
         .                                 excret);
         .                   ftype = true;
         .               }
         .           
   984,976 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_M_SECURITY)) {
         .                   /*
         .                    * EXC_RETURN.ES validation check (R_SMFL). We must do this before
         .                    * we pick which FAULTMASK to clear.
         .                    */
         .                   if (!env->v7m.secure &&
         .                       ((excret & R_V7M_EXCRET_ES_MASK) ||
         .                        !(excret & R_V7M_EXCRET_DCRS_MASK))) {
         .                       sfault = 1;
         .                       /* For all other purposes, treat ES as 0 (R_HXSR) */
         .                       excret &= ~R_V7M_EXCRET_ES_MASK;
         .                   }
         .                   exc_secure = excret & R_V7M_EXCRET_ES_MASK;
         .               }
         .           
   984,976 ( 0.00%)      if (env->v7m.exception != ARMV7M_EXCP_NMI) {
         .                   /*
         .                    * Auto-clear FAULTMASK on return from other than NMI.
         .                    * If the security extension is implemented then this only
         .                    * happens if the raw execution priority is >= 0; the
         .                    * value of the ES bit in the exception return value indicates
         .                    * which security state's faultmask to clear. (v8M ARM ARM R_KBNF.)
         .                    */
         .                   if (arm_feature(env, ARM_FEATURE_M_SECURITY)) {
         .                       if (armv7m_nvic_raw_execution_priority(env->nvic) >= 0) {
         .                           env->v7m.faultmask[exc_secure] = 0;
         .                       }
         .                   } else {
 1,477,464 ( 0.00%)              env->v7m.faultmask[M_REG_NS] = 0;
         .                   }
         .               }
         .           
 2,954,928 ( 0.00%)      switch (armv7m_nvic_complete_irq(env->nvic, env->v7m.exception,
728,882,240 ( 1.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:armv7m_nvic_complete_irq (492,488x)
         .                                                exc_secure)) {
         .               case -1:
         .                   /* attempt to exit an exception that isn't active */
         .                   ufault = true;
         .                   break;
         .               case 0:
         .                   /* still an irq active now */
         .                   break;
-- line 1471 ----------------------------------------
-- line 1476 ----------------------------------------
         .                    * where we have 'rettobase == false'.)
         .                    */
         .                   rettobase = true;
         .                   break;
         .               default:
         .                   g_assert_not_reached();
         .               }
         .           
 3,447,416 ( 0.00%)      return_to_handler = !(excret & R_V7M_EXCRET_MODE_MASK);
 2,954,928 ( 0.00%)      return_to_sp_process = excret & R_V7M_EXCRET_SPSEL_MASK;
 1,477,464 ( 0.00%)      return_to_secure = arm_feature(env, ARM_FEATURE_M_SECURITY) &&
         .                   (excret & R_V7M_EXCRET_S_MASK);
         .           
   984,976 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_V8)) {
         .                   if (!arm_feature(env, ARM_FEATURE_M_SECURITY)) {
         .                       /*
         .                        * UNPREDICTABLE if S == 1 or DCRS == 0 or ES == 1 (R_XLCP);
         .                        * we choose to take the UsageFault.
         .                        */
         .                       if ((excret & R_V7M_EXCRET_S_MASK) ||
         .                           (excret & R_V7M_EXCRET_ES_MASK) ||
         .                           !(excret & R_V7M_EXCRET_DCRS_MASK)) {
-- line 1497 ----------------------------------------
-- line 1498 ----------------------------------------
         .                           ufault = true;
         .                       }
         .                   }
         .                   if (excret & R_V7M_EXCRET_RES0_MASK) {
         .                       ufault = true;
         .                   }
         .               } else {
         .                   /* For v7M we only recognize certain combinations of the low bits */
 2,954,928 ( 0.00%)          switch (excret & 0xf) {
         .                   case 1: /* Return to Handler */
         .                       break;
         .                   case 13: /* Return to Thread using Process stack */
         .                   case 9: /* Return to Thread using Main stack */
         .                       /*
         .                        * We only need to check NONBASETHRDENA for v7M, because in
         .                        * v8M this bit does not exist (it is RES1).
         .                        */
   984,976 ( 0.00%)              if (!rettobase &&
         .                           !(env->v7m.ccr[env->v7m.secure] &
         .                             R_V7M_CCR_NONBASETHRDENA_MASK)) {
         .                           ufault = true;
         .                       }
         .                       break;
         .                   default:
         .                       ufault = true;
         .                   }
-- line 1523 ----------------------------------------
-- line 1526 ----------------------------------------
         .               /*
         .                * Set CONTROL.SPSEL from excret.SPSEL. Since we're still in
         .                * Handler mode (and will be until we write the new XPSR.Interrupt
         .                * field) this does not switch around the current stack pointer.
         .                * We must do this before we do any kind of tailchaining, including
         .                * for the derived exceptions on integrity check failures, or we will
         .                * give the guest an incorrect EXCRET.SPSEL value on exception entry.
         .                */
 1,477,464 ( 0.00%)      write_v7m_control_spsel_for_secstate(env, return_to_sp_process, exc_secure);
 7,387,320 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:write_v7m_control_spsel_for_secstate (492,488x)
         .           
         .               /*
         .                * Clear scratch FP values left in caller saved registers; this
         .                * must happen before any kind of tail chaining.
         .                */
 1,477,464 ( 0.00%)      if ((env->v7m.fpccr[M_REG_S] & R_V7M_FPCCR_CLRONRET_MASK) &&
         .                   (env->v7m.control[M_REG_S] & R_V7M_CONTROL_FPCA_MASK)) {
         .                   if (env->v7m.fpccr[M_REG_S] & R_V7M_FPCCR_LSPACT_MASK) {
         .                       env->v7m.sfsr |= R_V7M_SFSR_LSERR_MASK;
         .                       armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_SECURE, false);
         .                       qemu_log_mask(CPU_LOG_INT, "...taking SecureFault on existing "
         .                                     "stackframe: error during lazy state deactivation\n");
         .                       v7m_exception_taken(cpu, excret, true, false);
         .                       return;
-- line 1548 ----------------------------------------
-- line 1552 ----------------------------------------
         .                           bool nsacr_pass = exc_secure ||
         .                               extract32(env->v7m.nsacr, 10, 1);
         .                           bool cpacr_pass = v7m_cpacr_pass(env, exc_secure, true);
         .                           if (!nsacr_pass) {
         .                               armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_USAGE, true);
         .                               env->v7m.cfsr[M_REG_S] |= R_V7M_CFSR_NOCP_MASK;
         .                               qemu_log_mask(CPU_LOG_INT, "...taking UsageFault on existing "
         .                                   "stackframe: NSACR prevents clearing FPU registers\n");
   984,976 ( 0.00%)                      v7m_exception_taken(cpu, excret, true, false);
710,238,848 ( 0.97%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:v7m_exception_taken (492,488x)
         .                               return;
         .                           } else if (!cpacr_pass) {
         .                               armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_USAGE,
         .                                                       exc_secure);
         .                               env->v7m.cfsr[exc_secure] |= R_V7M_CFSR_NOCP_MASK;
         .                               qemu_log_mask(CPU_LOG_INT, "...taking UsageFault on existing "
         .                                   "stackframe: CPACR prevents clearing FPU registers\n");
         .                               v7m_exception_taken(cpu, excret, true, false);
-- line 1568 ----------------------------------------
-- line 1577 ----------------------------------------
         .                       }
         .                       vfp_set_fpscr(env, 0);
         .                       if (cpu_isar_feature(aa32_mve, cpu)) {
         .                           env->v7m.vpr = 0;
         .                       }
         .                   }
         .               }
         .           
   984,976 ( 0.00%)      if (sfault) {
         .                   env->v7m.sfsr |= R_V7M_SFSR_INVER_MASK;
   492,488 ( 0.00%)          armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_SECURE, false);
         .                   qemu_log_mask(CPU_LOG_INT, "...taking SecureFault on existing "
         .                                 "stackframe: failed EXC_RETURN.ES validity check\n");
         .                   v7m_exception_taken(cpu, excret, true, false);
         .                   return;
         .               }
         .           
   984,976 ( 0.00%)      if (ufault) {
         .                   /*
         .                    * Bad exception return: instead of popping the exception
         .                    * stack, directly take a usage fault on the current stack.
         .                    */
         .                   env->v7m.cfsr[env->v7m.secure] |= R_V7M_CFSR_INVPC_MASK;
         .                   armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_USAGE, env->v7m.secure);
         .                   qemu_log_mask(CPU_LOG_INT, "...taking UsageFault on existing "
         .                                 "stackframe: failed exception return integrity check\n");
-- line 1602 ----------------------------------------
-- line 1609 ----------------------------------------
         .                * is high enough priority to preempt execution at the level we're
         .                * about to return to, then just directly take that exception now,
         .                * avoiding an unstack-and-then-stack. Note that now we have
         .                * deactivated the previous exception by calling armv7m_nvic_complete_irq()
         .                * our current execution priority is already the execution priority we are
         .                * returning to -- none of the state we would unstack or set based on
         .                * the EXCRET value affects it.
         .                */
 1,477,464 ( 0.00%)      if (armv7m_nvic_can_take_pending_exception(env->nvic)) {
21,669,472 ( 0.03%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:armv7m_nvic_can_take_pending_exception (492,488x)
         .                   qemu_log_mask(CPU_LOG_INT, "...tailchaining to pending exception\n");
         .                   v7m_exception_taken(cpu, excret, true, false);
         .                   return;
         .               }
         .           
 1,477,464 ( 0.00%)      switch_v7m_security_state(env, return_to_secure);
 2,462,440 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:switch_v7m_security_state (492,488x)
         .           
         .               {
         .                   /*
         .                    * The stack pointer we should be reading the exception frame from
         .                    * depends on bits in the magic exception return type value (and
         .                    * for v8M isn't necessarily the stack pointer we will eventually
         .                    * end up resuming execution with). Get a pointer to the location
         .                    * in the CPU state struct where the SP we need is currently being
         .                    * stored; we will use and modify it in place.
         .                    * We use this limited C variable scope so we don't accidentally
         .                    * use 'frame_sp_p' after we do something that makes it invalid.
         .                    */
 2,462,440 ( 0.00%)          bool spsel = env->v7m.control[return_to_secure] & R_V7M_CONTROL_SPSEL_MASK;
         .                   uint32_t *frame_sp_p = get_v7m_sp_ptr(env,
         .                                                         return_to_secure,
         .                                                         !return_to_handler,
   984,976 ( 0.00%)                                                spsel);
         .                   uint32_t frameptr = *frame_sp_p;
         .                   bool pop_ok = true;
         .                   ARMMMUIdx mmu_idx;
 4,432,392 ( 0.01%)          bool return_to_priv = return_to_handler ||
         .                       !(env->v7m.control[return_to_secure] & R_V7M_CONTROL_NPRIV_MASK);
         .           
 2,462,440 ( 0.00%)          mmu_idx = arm_v7m_mmu_idx_for_secstate_and_priv(env, return_to_secure,
22,161,960 ( 0.03%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:arm_v7m_mmu_idx_for_secstate_and_priv (492,488x)
         .                                                                   return_to_priv);
         .           
         .                   if (!QEMU_IS_ALIGNED(frameptr, 8) &&
         .                       arm_feature(env, ARM_FEATURE_V8)) {
         .                       qemu_log_mask(LOG_GUEST_ERROR,
         .                                     "M profile exception return with non-8-aligned SP "
         .                                     "for destination state is UNPREDICTABLE\n");
         .                   }
         .           
         .                   /* Do we need to pop callee-saved registers? */
   984,976 ( 0.00%)          if (return_to_secure &&
         .                       ((excret & R_V7M_EXCRET_ES_MASK) == 0 ||
         .                        (excret & R_V7M_EXCRET_DCRS_MASK) == 0)) {
         .                       uint32_t actual_sig;
         .           
         .                       pop_ok = v7m_stack_read(cpu, &actual_sig, frameptr, mmu_idx);
         .           
         .                       if (pop_ok && v7m_integrity_sig(env, excret) != actual_sig) {
         .                           /* Take a SecureFault on the current stack */
-- line 1666 ----------------------------------------
-- line 1682 ----------------------------------------
         .                           v7m_stack_read(cpu, &env->regs[9], frameptr + 0x1c, mmu_idx) &&
         .                           v7m_stack_read(cpu, &env->regs[10], frameptr + 0x20, mmu_idx) &&
         .                           v7m_stack_read(cpu, &env->regs[11], frameptr + 0x24, mmu_idx);
         .           
         .                       frameptr += 0x28;
         .                   }
         .           
         .                   /* Pop registers */
   984,976 ( 0.00%)          pop_ok = pop_ok &&
 3,447,416 ( 0.00%)              v7m_stack_read(cpu, &env->regs[0], frameptr, mmu_idx) &&
252,246,231 ( 0.35%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:v7m_stack_read (492,488x)
 3,447,416 ( 0.00%)              v7m_stack_read(cpu, &env->regs[1], frameptr + 0x4, mmu_idx) &&
227,036,968 ( 0.31%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:v7m_stack_read (492,488x)
 3,447,416 ( 0.00%)              v7m_stack_read(cpu, &env->regs[2], frameptr + 0x8, mmu_idx) &&
227,036,968 ( 0.31%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:v7m_stack_read (492,488x)
 3,447,416 ( 0.00%)              v7m_stack_read(cpu, &env->regs[3], frameptr + 0xc, mmu_idx) &&
227,036,968 ( 0.31%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:v7m_stack_read (492,488x)
 3,447,416 ( 0.00%)              v7m_stack_read(cpu, &env->regs[12], frameptr + 0x10, mmu_idx) &&
227,036,968 ( 0.31%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:v7m_stack_read (492,488x)
 3,447,416 ( 0.00%)              v7m_stack_read(cpu, &env->regs[14], frameptr + 0x14, mmu_idx) &&
227,036,968 ( 0.31%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:v7m_stack_read (492,488x)
 3,447,416 ( 0.00%)              v7m_stack_read(cpu, &env->regs[15], frameptr + 0x18, mmu_idx) &&
227,036,968 ( 0.31%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:v7m_stack_read (492,488x)
 2,954,928 ( 0.00%)              v7m_stack_read(cpu, &xpsr, frameptr + 0x1c, mmu_idx);
227,036,968 ( 0.31%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:v7m_stack_read (492,488x)
         .           
         .                   if (!pop_ok) {
         .                       /*
         .                        * v7m_stack_read() pended a fault, so take it (as a tail
         .                        * chained exception on the same stack frame)
         .                        */
         .                       qemu_log_mask(CPU_LOG_INT, "...derived exception on unstacking\n");
         .                       v7m_exception_taken(cpu, excret, true, false);
-- line 1706 ----------------------------------------
-- line 1711 ----------------------------------------
         .                    * Returning from an exception with a PC with bit 0 set is defined
         .                    * behaviour on v8M (bit 0 is ignored), but for v7M it was specified
         .                    * to be UNPREDICTABLE. In practice actual v7M hardware seems to ignore
         .                    * the lsbit, and there are several RTOSes out there which incorrectly
         .                    * assume the r15 in the stack frame should be a Thumb-style "lsbit
         .                    * indicates ARM/Thumb" value, so ignore the bit on v7M as well, but
         .                    * complain about the badly behaved guest.
         .                    */
 1,477,464 ( 0.00%)          if (env->regs[15] & 1) {
    80,068 ( 0.00%)              env->regs[15] &= ~1U;
         .                       if (!arm_feature(env, ARM_FEATURE_V8)) {
         .                           qemu_log_mask(LOG_GUEST_ERROR,
         .                                         "M profile return from interrupt with misaligned "
         .                                         "PC is UNPREDICTABLE on v7M\n");
         .                       }
         .                   }
         .           
   984,976 ( 0.00%)          if (arm_feature(env, ARM_FEATURE_V8)) {
         .                       /*
         .                        * For v8M we have to check whether the xPSR exception field
         .                        * matches the EXCRET value for return to handler/thread
         .                        * before we commit to changing the SP and xPSR.
         .                        */
         .                       bool will_be_handler = (xpsr & XPSR_EXCP) != 0;
         .                       if (return_to_handler != will_be_handler) {
         .                           /*
-- line 1736 ----------------------------------------
-- line 1745 ----------------------------------------
         .                           qemu_log_mask(CPU_LOG_INT, "...taking UsageFault on existing "
         .                                         "stackframe: failed exception return integrity "
         .                                         "check\n");
         .                           v7m_exception_taken(cpu, excret, true, false);
         .                           return;
         .                       }
         .                   }
         .           
   984,976 ( 0.00%)          if (!ftype) {
         .                       /* FP present and we need to handle it */
   787,704 ( 0.00%)              if (!return_to_secure &&
   196,926 ( 0.00%)                  (env->v7m.fpccr[M_REG_S] & R_V7M_FPCCR_LSPACT_MASK)) {
         .                           armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_SECURE, false);
         .                           env->v7m.sfsr |= R_V7M_SFSR_LSERR_MASK;
         .                           qemu_log_mask(CPU_LOG_INT,
         .                                         "...taking SecureFault on existing stackframe: "
         .                                         "Secure LSPACT set but exception return is "
         .                                         "not to secure state\n");
         .                           v7m_exception_taken(cpu, excret, true, false);
         .                           return;
         .                       }
         .           
   196,926 ( 0.00%)              restore_s16_s31 = return_to_secure &&
         .                           (env->v7m.fpccr[M_REG_S] & R_V7M_FPCCR_TS_MASK);
         .           
   590,778 ( 0.00%)              if (env->v7m.fpccr[return_to_secure] & R_V7M_FPCCR_LSPACT_MASK) {
         .                           /* State in FPU is still valid, just clear LSPACT */
   393,852 ( 0.00%)                  env->v7m.fpccr[return_to_secure] &= ~R_V7M_FPCCR_LSPACT_MASK;
         .                       } else {
         .                           int i;
         .                           uint32_t fpscr;
         .                           bool cpacr_pass, nsacr_pass;
         .           
         .                           cpacr_pass = v7m_cpacr_pass(env, return_to_secure,
         .                                                       return_to_priv);
         .                           nsacr_pass = return_to_secure ||
-- line 1780 ----------------------------------------
-- line 1841 ----------------------------------------
         .                               }
         .                               vfp_set_fpscr(env, 0);
         .                               if (cpu_isar_feature(aa32_mve, cpu)) {
         .                                   env->v7m.vpr = 0;
         .                               }
         .                           }
         .                       }
         .                   }
   492,488 ( 0.00%)          env->v7m.control[M_REG_S] = FIELD_DP32(env->v7m.control[M_REG_S],
         .                                                          V7M_CONTROL, FPCA, !ftype);
         .           
         .                   /* Commit to consuming the stack frame */
   295,562 ( 0.00%)          frameptr += 0x20;
         .                   if (!ftype) {
   393,852 ( 0.00%)              frameptr += 0x48;
   393,852 ( 0.00%)              if (restore_s16_s31) {
   196,926 ( 0.00%)                  frameptr += 0x40;
         .                       }
         .                   }
         .                   /*
         .                    * Undo stack alignment (the SPREALIGN bit indicates that the original
         .                    * pre-exception SP was not 8-aligned and we added a padding word to
         .                    * align it, so we undo this by ORing in the bit that increases it
         .                    * from the current 8-aligned value to the 8-unaligned value. (Adding 4
         .                    * would work too but a logical OR is how the pseudocode specifies it.)
         .                    */
   492,488 ( 0.00%)          if (xpsr & XPSR_SPREALIGN) {
 1,969,952 ( 0.00%)              frameptr |= 4;
         .                   }
   984,976 ( 0.00%)          *frame_sp_p = frameptr;
         .               }
         .           
         .               xpsr_mask = ~(XPSR_SPREALIGN | XPSR_SFPA);
   984,976 ( 0.00%)      if (!arm_feature(env, ARM_FEATURE_THUMB_DSP)) {
         .                   xpsr_mask &= ~XPSR_GE;
         .               }
         .               /* This xpsr_write() will invalidate frame_sp_p as it may switch stack */
         .               xpsr_write(env, xpsr, xpsr_mask);
         .           
 1,477,464 ( 0.00%)      if (env->v7m.secure) {
         .                   bool sfpa = xpsr & XPSR_SFPA;
         .           
         .                   env->v7m.control[M_REG_S] = FIELD_DP32(env->v7m.control[M_REG_S],
         .                                                          V7M_CONTROL, SFPA, sfpa);
         .               }
         .           
         .               /*
         .                * The restored xPSR exception field will be zero if we're
         .                * resuming in Thread mode. If that doesn't match what the
         .                * exception return excret specified then this is a UsageFault.
         .                * v7M requires we make this check here; v8M did it earlier.
         .                */
   984,976 ( 0.00%)      if (return_to_handler != arm_v7m_is_handler_mode(env)) {
         .                   /*
         .                    * Take an INVPC UsageFault by pushing the stack again;
         .                    * we know we're v7M so this is never a Secure UsageFault.
         .                    */
         .                   bool ignore_stackfaults;
         .           
         .                   assert(!arm_feature(env, ARM_FEATURE_V8));
         .                   armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_USAGE, false);
-- line 1901 ----------------------------------------
-- line 1904 ----------------------------------------
         .                   qemu_log_mask(CPU_LOG_INT, "...taking UsageFault on new stackframe: "
         .                                 "failed exception return integrity check\n");
         .                   v7m_exception_taken(cpu, excret, false, ignore_stackfaults);
         .                   return;
         .               }
         .           
         .               /* Otherwise, we have a successful exception exit. */
         .               arm_clear_exclusive(env);
 1,969,952 ( 0.00%)      arm_rebuild_hflags(env);
         .               qemu_log_mask(CPU_LOG_INT, "...successful exception return\n");
         .           }
         .           
         .           static bool do_v7m_function_return(ARMCPU *cpu)
         .           {
         .               /*
         .                * v8M security extensions magic function return.
         .                * We may either:
-- line 1920 ----------------------------------------
-- line 1977 ----------------------------------------
         .               env->v7m.exception = newpsr_exc;
         .               env->v7m.control[M_REG_S] &= ~R_V7M_CONTROL_SFPA_MASK;
         .               if (newpsr & XPSR_SFPA) {
         .                   env->v7m.control[M_REG_S] |= R_V7M_CONTROL_SFPA_MASK;
         .               }
         .               xpsr_write(env, 0, XPSR_IT);
         .               env->thumb = newpc & 1;
         .               env->regs[15] = newpc & ~1;
   492,488 ( 0.00%)      arm_rebuild_hflags(env);
96,035,160 ( 0.13%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:arm_rebuild_hflags (492,488x)
         .           
         .               qemu_log_mask(CPU_LOG_INT, "...function return successful\n");
         .               return true;
         .           }
         .           
         .           static bool v7m_read_half_insn(ARMCPU *cpu, ARMMMUIdx mmu_idx, bool secure,
         .                                          uint32_t addr, uint16_t *insn)
         .           {
-- line 1993 ----------------------------------------
-- line 2189 ----------------------------------------
         .               env->v7m.sfsr |= R_V7M_SFSR_INVEP_MASK;
         .               armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_SECURE, false);
         .               qemu_log_mask(CPU_LOG_INT,
         .                             "...really SecureFault with SFSR.INVEP\n");
         .               return false;
         .           }
         .           
         .           void arm_v7m_cpu_do_interrupt(CPUState *cs)
11,819,712 ( 0.02%)  {
         .               ARMCPU *cpu = ARM_CPU(cs);
         .               CPUARMState *env = &cpu->env;
         .               uint32_t lr;
         .               bool ignore_stackfaults;
         .               bool should_continue = true;
 3,939,904 ( 0.01%)      if(do_arm_interrupt_func)
 1,969,952 ( 0.00%)  	    should_continue = do_arm_interrupt_func(cs->exception_index);
18,714,544 ( 0.03%)  => ???:arm_cpu_do_interrupt_hook (984,976x)
 1,969,952 ( 0.00%)      if(!should_continue)
         .           	    return;
 1,969,952 ( 0.00%)      arm_log_exception(cs);
 1,969,952 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:arm_log_exception (984,976x)
         .           
         .               /*
         .                * For exceptions we just mark as pending on the NVIC, and let that
         .                * handle it.
         .                */
 7,879,808 ( 0.01%)      switch (cs->exception_index) {
         .               case EXCP_UDEF:
         .                   armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_USAGE, env->v7m.secure);
         .                   env->v7m.cfsr[env->v7m.secure] |= R_V7M_CFSR_UNDEFINSTR_MASK;
         .                   break;
         .               case EXCP_NOCP:
         .               {
         .                   /*
         .                    * NOCP might be directed to something other than the current
-- line 2221 ----------------------------------------
-- line 2251 ----------------------------------------
         .                   env->v7m.cfsr[env->v7m.secure] |= R_V7M_CFSR_UNALIGNED_MASK;
         .                   break;
         .               case EXCP_DIVBYZERO:
         .                   armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_USAGE, env->v7m.secure);
         .                   env->v7m.cfsr[env->v7m.secure] |= R_V7M_CFSR_DIVBYZERO_MASK;
         .                   break;
         .               case EXCP_SWI:
         .                   /* The PC already points to the next instruction.  */
 2,179,576 ( 0.00%)          armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_SVC, env->v7m.secure);
267,404,440 ( 0.37%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:armv7m_nvic_set_pending (311,368x)
   311,368 ( 0.00%)          break;
         .               case EXCP_PREFETCH_ABORT:
         .               case EXCP_DATA_ABORT:
         .                   /*
         .                    * Note that for M profile we don't have a guest facing FSR, but
         .                    * the env->exception.fsr will be populated by the code that
         .                    * raises the fault, in the A profile short-descriptor format.
         .                    *
         .                    * Log the exception.vaddress now regardless of subtype, because
-- line 2268 ----------------------------------------
-- line 2372 ----------------------------------------
         .                   env->regs[15] += env->thumb ? 2 : 4;
         .                   return;
         .               case EXCP_BKPT:
         .                   armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_DEBUG, false);
         .                   break;
         .               case EXCP_IRQ:
         .                   break;
         .               case EXCP_EXCEPTION_EXIT:
 1,477,464 ( 0.00%)          if (env->regs[15] < EXC_RETURN_MIN_MAGIC) {
         .                       /* Must be v8M security extension function return */
         .                       assert(env->regs[15] >= FNC_RETURN_MIN_MAGIC);
         .                       assert(arm_feature(env, ARM_FEATURE_M_SECURITY));
         .                       if (do_v7m_function_return(cpu)) {
         .                           return;
         .                       }
         .                   } else {
         .                       do_v7m_exception_exit(cpu);
-- line 2388 ----------------------------------------
-- line 2395 ----------------------------------------
         .                    * v7m_preserve_fp_state() helper function.
         .                    */
         .                   break;
         .               default:
         .                   cpu_abort(cs, "Unhandled exception 0x%x\n", cs->exception_index);
         .                   return; /* Never happens.  Keep compiler happy.  */
         .               }
         .           
   984,976 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_V8)) {
         .                   lr = R_V7M_EXCRET_RES1_MASK |
         .                       R_V7M_EXCRET_DCRS_MASK;
         .                   /*
         .                    * The S bit indicates whether we should return to Secure
         .                    * or NonSecure (ie our current state).
         .                    * The ES bit indicates whether we're taking this exception
         .                    * to Secure or NonSecure (ie our target state). We set it
         .                    * later, in v7m_exception_taken().
-- line 2411 ----------------------------------------
-- line 2418 ----------------------------------------
         .                   if (env->v7m.secure) {
         .                       lr |= R_V7M_EXCRET_S_MASK;
         .                   }
         .               } else {
         .                   lr = R_V7M_EXCRET_RES1_MASK |
         .                       R_V7M_EXCRET_S_MASK |
         .                       R_V7M_EXCRET_DCRS_MASK |
         .                       R_V7M_EXCRET_ES_MASK;
   984,976 ( 0.00%)          if (env->v7m.control[M_REG_NS] & R_V7M_CONTROL_SPSEL_MASK) {
 1,969,952 ( 0.00%)              lr |= R_V7M_EXCRET_SPSEL_MASK;
         .                   }
         .               }
         .               if (!(env->v7m.control[M_REG_S] & R_V7M_CONTROL_FPCA_MASK)) {
 1,969,952 ( 0.00%)          lr |= R_V7M_EXCRET_FTYPE_MASK;
         .               }
 1,477,464 ( 0.00%)      if (!arm_v7m_is_handler_mode(env)) {
   492,488 ( 0.00%)          lr |= R_V7M_EXCRET_MODE_MASK;
         .               }
         .           
   984,976 ( 0.00%)      ignore_stackfaults = v7m_push_stack(cpu);
2,981,370,400 ( 4.09%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:v7m_push_stack (492,488x)
 2,954,928 ( 0.00%)      v7m_exception_taken(cpu, lr, false, ignore_stackfaults);
 6,894,832 ( 0.01%)  }
         .           
         .           uint32_t HELPER(v7m_mrs)(CPUARMState *env, uint32_t reg)
 6,763,926 ( 0.01%)  {
         .               unsigned el = arm_current_el(env);
         .           
         .               /* First handle registers which unprivileged can read */
11,217,404 ( 0.02%)      switch (reg) {
         .               case 0 ... 7: /* xPSR sub-fields */
   329,970 ( 0.00%)          return v7m_mrs_xpsr(env, reg, el);
         .               case 20: /* CONTROL */
         .                   return v7m_mrs_control(env, env->v7m.secure);
         .               case 0x94: /* CONTROL_NS */
         .                   /*
         .                    * We have to handle this here because unprivileged Secure code
         .                    * can read the NS CONTROL register.
         .                    */
         .                   if (!env->v7m.secure) {
-- line 2456 ----------------------------------------
-- line 2518 ----------------------------------------
         .                           return env->v7m.other_ss_msp;
         .                       }
         .                   }
         .                   default:
         .                       break;
         .                   }
         .               }
         .           
13,342,490 ( 0.02%)      switch (reg) {
         .               case 8: /* MSP */
 1,022,180 ( 0.00%)          return v7m_using_psp(env) ? env->v7m.other_sp : env->regs[13];
         .               case 9: /* PSP */
         .                   return v7m_using_psp(env) ? env->regs[13] : env->v7m.other_sp;
         .               case 10: /* MSPLIM */
         .                   if (!arm_feature(env, ARM_FEATURE_V8)) {
         .                       goto bad_reg;
         .                   }
         .                   return env->v7m.msplim[env->v7m.secure];
         .               case 11: /* PSPLIM */
         .                   if (!arm_feature(env, ARM_FEATURE_V8)) {
         .                       goto bad_reg;
         .                   }
         .                   return env->v7m.psplim[env->v7m.secure];
         .               case 16: /* PRIMASK */
 3,195,030 ( 0.00%)          return env->v7m.primask[env->v7m.secure];
         .               case 17: /* BASEPRI */
         .               case 18: /* BASEPRI_MAX */
   989,910 ( 0.00%)          return env->v7m.basepri[env->v7m.secure];
         .               case 19: /* FAULTMASK */
         .                   return env->v7m.faultmask[env->v7m.secure];
         .               default:
         .               bad_reg:
         .                   qemu_log_mask(LOG_GUEST_ERROR, "Attempt to read unknown special"
         .                                                  " register %d\n", reg);
         .                   return 0;
         .               }
         .           }
         .           
         .           void HELPER(v7m_msr)(CPUARMState *env, uint32_t maskreg, uint32_t val)
 4,762,056 ( 0.01%)  {
         .               /*
         .                * We're passed bits [11..0] of the instruction; extract
         .                * SYSm and the mask bits.
         .                * Invalid combinations of SYSm and mask are UNPREDICTABLE;
         .                * we choose to treat them as if the mask bits were valid.
         .                * NB that the pseudocode 'mask' variable is bits [11..10],
         .                * whereas ours is [11..8].
         .                */
-- line 2565 ----------------------------------------
-- line 2570 ----------------------------------------
         .               if (cur_el == 0 && reg > 7 && reg != 20) {
         .                   /*
         .                    * only xPSR sub-fields and CONTROL.SFPA may be written by
         .                    * unprivileged code
         .                    */
         .                   return;
         .               }
         .           
 1,587,352 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_M_SECURITY)) {
         .                   switch (reg) {
         .                   case 0x88: /* MSP_NS */
         .                       if (!env->v7m.secure) {
         .                           return;
         .                       }
    40,034 ( 0.00%)              env->v7m.other_ss_msp = val & ~3;
         .                       return;
         .                   case 0x89: /* PSP_NS */
         .                       if (!env->v7m.secure) {
         .                           return;
         .                       }
         .                       env->v7m.other_ss_psp = val & ~3;
         .                       return;
         .                   case 0x8a: /* MSPLIM_NS */
-- line 2592 ----------------------------------------
-- line 2669 ----------------------------------------
         .                       }
         .                       return;
         .                   }
         .                   default:
         .                       break;
         .                   }
         .               }
         .           
 4,762,056 ( 0.01%)      switch (reg) {
         .               case 0 ... 7: /* xPSR sub-fields */
         .                   v7m_msr_xpsr(env, mask, reg, val);
         .                   break;
         .               case 8: /* MSP */
         .                   if (v7m_using_psp(env)) {
         .                       env->v7m.other_sp = val & ~3;
         .                   } else {
         .                       env->regs[13] = val & ~3;
         .                   }
         .                   break;
         .               case 9: /* PSP */
         .                   if (v7m_using_psp(env)) {
         .                       env->regs[13] = val & ~3;
         .                   } else {
    80,068 ( 0.00%)              env->v7m.other_sp = val & ~3;
         .                   }
         .                   break;
         .               case 10: /* MSPLIM */
         .                   if (!arm_feature(env, ARM_FEATURE_V8)) {
         .                       goto bad_reg;
         .                   }
         .                   env->v7m.msplim[env->v7m.secure] = val & ~7;
         .                   break;
         .               case 11: /* PSPLIM */
         .                   if (!arm_feature(env, ARM_FEATURE_V8)) {
         .                       goto bad_reg;
         .                   }
         .                   env->v7m.psplim[env->v7m.secure] = val & ~7;
         .                   break;
         .               case 16: /* PRIMASK */
 2,205,120 ( 0.00%)          env->v7m.primask[env->v7m.secure] = val & 1;
   735,040 ( 0.00%)          break;
         .               case 17: /* BASEPRI */
         .                   if (!arm_feature(env, ARM_FEATURE_M_MAIN)) {
         .                       goto bad_reg;
         .                   }
         .                   env->v7m.basepri[env->v7m.secure] = val & 0xff;
         .                   break;
         .               case 18: /* BASEPRI_MAX */
         .                   if (!arm_feature(env, ARM_FEATURE_M_MAIN)) {
-- line 2717 ----------------------------------------
-- line 2735 ----------------------------------------
         .                    * thread mode; other bits can be updated by any privileged code.
         .                    * write_v7m_control_spsel() deals with updating the SPSEL bit in
         .                    * env->v7m.control, so we only need update the others.
         .                    * For v7M, we must just ignore explicit writes to SPSEL in handler
         .                    * mode; for v8M the write is permitted but will have no effect.
         .                    * All these bits are writes-ignored from non-privileged code,
         .                    * except for SFPA.
         .                    */
   130,214 ( 0.00%)          if (cur_el > 0 && (arm_feature(env, ARM_FEATURE_V8) ||
         .                                      !arm_v7m_is_handler_mode(env))) {
         .                       write_v7m_control_spsel(env, (val & R_V7M_CONTROL_SPSEL_MASK) != 0);
         .                   }
    37,204 ( 0.00%)          if (cur_el > 0 && arm_feature(env, ARM_FEATURE_M_MAIN)) {
    37,204 ( 0.00%)              env->v7m.control[env->v7m.secure] &= ~R_V7M_CONTROL_NPRIV_MASK;
   111,612 ( 0.00%)              env->v7m.control[env->v7m.secure] |= val & R_V7M_CONTROL_NPRIV_MASK;
         .                   }
    37,204 ( 0.00%)          if (cpu_isar_feature(aa32_vfp_simd, env_archcpu(env))) {
         .                       /*
         .                        * SFPA is RAZ/WI from NS or if no FPU.
         .                        * FPCA is RO if NSACR.CP10 == 0, RES0 if the FPU is not present.
         .                        * Both are stored in the S bank.
         .                        */
    55,806 ( 0.00%)              if (env->v7m.secure) {
    37,204 ( 0.00%)                  env->v7m.control[M_REG_S] &= ~R_V7M_CONTROL_SFPA_MASK;
         .                           env->v7m.control[M_REG_S] |= val & R_V7M_CONTROL_SFPA_MASK;
         .                       }
    37,204 ( 0.00%)              if (cur_el > 0 &&
    37,204 ( 0.00%)                  (env->v7m.secure || !arm_feature(env, ARM_FEATURE_M_SECURITY) ||
         .                            extract32(env->v7m.nsacr, 10, 1))) {
    18,602 ( 0.00%)                  env->v7m.control[M_REG_S] &= ~R_V7M_CONTROL_FPCA_MASK;
    74,408 ( 0.00%)                  env->v7m.control[M_REG_S] |= val & R_V7M_CONTROL_FPCA_MASK;
         .                       }
         .                   }
         .                   break;
         .               default:
         .               bad_reg:
         .                   qemu_log_mask(LOG_GUEST_ERROR, "Attempt to write unknown special"
         .                                                  " register %d\n", reg);
         .                   return;
         .               }
 2,381,028 ( 0.00%)  }
         .           
         .           uint32_t HELPER(v7m_tt)(CPUARMState *env, uint32_t addr, uint32_t op)
         .           {
         .               /* Implement the TT instruction. op is bits [7:6] of the insn. */
         .               bool forceunpriv = op & 1;
         .               bool alt = op & 2;
         .               V8M_SAttributes sattrs = {};
         .               uint32_t tt_resp;
-- line 2783 ----------------------------------------
-- line 2862 ----------------------------------------
         .           
         .               return tt_resp;
         .           }
         .           
         .           #endif /* !CONFIG_USER_ONLY */
         .           
         .           ARMMMUIdx arm_v7m_mmu_idx_all(CPUARMState *env,
         .                                         bool secstate, bool priv, bool negpri)
 3,371,959 ( 0.00%)  {
         .               ARMMMUIdx mmu_idx = ARM_MMU_IDX_M;
         .           
 6,743,918 ( 0.01%)      if (priv) {
         .                   mmu_idx |= ARM_MMU_IDX_M_PRIV;
         .               }
         .           
         .               if (negpri) {
13,487,836 ( 0.02%)          mmu_idx |= ARM_MMU_IDX_M_NEGPRI;
         .               }
         .           
         .               if (secstate) {
13,487,836 ( 0.02%)          mmu_idx |= ARM_MMU_IDX_M_S;
         .               }
         .           
         .               return mmu_idx;
 3,371,959 ( 0.00%)  }
         .           
         .           ARMMMUIdx arm_v7m_mmu_idx_for_secstate_and_priv(CPUARMState *env,
         .                                                           bool secstate, bool priv)
20,214,774 ( 0.03%)  {
13,476,516 ( 0.02%)      bool negpri = armv7m_nvic_neg_prio_requested(env->nvic, secstate);
50,536,935 ( 0.07%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:armv7m_nvic_neg_prio_requested (3,369,129x)
         .           
16,845,645 ( 0.02%)      return arm_v7m_mmu_idx_all(env, secstate, priv, negpri);
40,429,548 ( 0.06%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:arm_v7m_mmu_idx_all (3,369,129x)
10,107,387 ( 0.01%)  }
         .           
         .           /* Return the MMU index for a v7M CPU in the specified security state */
         .           ARMMMUIdx arm_v7m_mmu_idx_for_secstate(CPUARMState *env, bool secstate)
 2,384,153 ( 0.00%)  {
14,868,281 ( 0.02%)      bool priv = arm_v7m_is_handler_mode(env) ||
 4,161,376 ( 0.01%)          !(env->v7m.control[secstate] & 1);
         .           
 2,384,153 ( 0.00%)      return arm_v7m_mmu_idx_for_secstate_and_priv(env, secstate, priv);
107,286,885 ( 0.15%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:arm_v7m_mmu_idx_for_secstate_and_priv (2,384,153x)
         .           }

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/internals.h
--------------------------------------------------------------------------------
Ir                   

-- line 35 ----------------------------------------
          .           #define BANK_ABT    2
          .           #define BANK_UND    3
          .           #define BANK_IRQ    4
          .           #define BANK_FIQ    5
          .           #define BANK_HYP    6
          .           #define BANK_MON    7
          .           
          .           static inline bool excp_is_internal(int excp)
  3,215,424 ( 0.00%)  {
          .               /* Return true if this exception number represents a QEMU-internal
          .                * exception that will not be passed to the guest.
          .                */
          .               return excp == EXCP_INTERRUPT
          .                   || excp == EXCP_HLT
          .                   || excp == EXCP_DEBUG
          .                   || excp == EXCP_HALTED
          .                   || excp == EXCP_EXCEPTION_EXIT
          .                   || excp == EXCP_KERNEL_TRAP
  4,019,280 ( 0.01%)          || excp == EXCP_SEMIHOST;
    803,856 ( 0.00%)  }
          .           
          .           /* Scale factor for generic timers, ie number of ns per tick.
          .            * This gives a 62.5MHz timer.
          .            */
          .           #define GTIMER_SCALE 16
          .           
          .           /* Bit definitions for the v7M CONTROL register */
          .           FIELD(V7M_CONTROL, NPRIV, 0, 1)
-- line 62 ----------------------------------------
-- line 312 ----------------------------------------
          .           
          .           /**
          .            * arm_clear_exclusive: clear the exclusive monitor
          .            * @env: CPU env
          .            * Clear the CPU's exclusive monitor, like the guest CLREX instruction.
          .            */
          .           static inline void arm_clear_exclusive(CPUARMState *env)
          .           {
    984,978 ( 0.00%)      env->exclusive_addr = -1;
          .           }
          .           
          .           /**
          .            * ARMFaultType: type of an ARM MMU fault
          .            * This corresponds to the v8A pseudocode's Fault enumeration,
          .            * with extensions for QEMU internal conditions.
          .            */
          .           typedef enum ARMFaultType {
-- line 328 ----------------------------------------
-- line 568 ----------------------------------------
          .           #else
          .           bool arm_cpu_tlb_fill(CPUState *cs, vaddr address, int size,
          .                                 MMUAccessType access_type, int mmu_idx,
          .                                 bool probe, uintptr_t retaddr);
          .           #endif
          .           
          .           static inline int arm_to_core_mmu_idx(ARMMMUIdx mmu_idx)
          .           {
      2,326 ( 0.00%)      return mmu_idx & ARM_MMU_IDX_COREIDX_MASK;
          .           }
          .           
          .           static inline ARMMMUIdx core_to_arm_mmu_idx(CPUARMState *env, int mmu_idx)
          .           {
      1,492 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_M)) {
    710,126 ( 0.00%)          return mmu_idx | ARM_MMU_IDX_M;
          .               } else {
          .                   return mmu_idx | ARM_MMU_IDX_A;
          .               }
          .           }
          .           
          .           static inline ARMMMUIdx core_to_aa64_mmu_idx(int mmu_idx)
          .           {
          .               /* AArch64 is always a-profile. */
-- line 590 ----------------------------------------
-- line 684 ----------------------------------------
          .           static inline bool regime_is_stage2(ARMMMUIdx mmu_idx)
          .           {
          .               return mmu_idx == ARMMMUIdx_Stage2 || mmu_idx == ARMMMUIdx_Stage2_S;
          .           }
          .           
          .           /* Return the exception level which controls this address translation regime */
          .           static inline uint32_t regime_el(CPUARMState *env, ARMMMUIdx mmu_idx)
          .           {
    224,128 ( 0.00%)      switch (mmu_idx) {
          .               case ARMMMUIdx_E20_0:
          .               case ARMMMUIdx_E20_2:
          .               case ARMMMUIdx_E20_2_PAN:
          .               case ARMMMUIdx_Stage2:
          .               case ARMMMUIdx_Stage2_S:
          .               case ARMMMUIdx_E2:
          .                   return 2;
          .               case ARMMMUIdx_E3:
-- line 700 ----------------------------------------
-- line 717 ----------------------------------------
          .                   return 1;
          .               default:
          .                   g_assert_not_reached();
          .               }
          .           }
          .           
          .           static inline bool regime_is_user(CPUARMState *env, ARMMMUIdx mmu_idx)
          .           {
144,830,664 ( 0.20%)      switch (mmu_idx) {
          .               case ARMMMUIdx_E20_0:
          .               case ARMMMUIdx_Stage1_E0:
          .               case ARMMMUIdx_MUser:
          .               case ARMMMUIdx_MSUser:
          .               case ARMMMUIdx_MUserNegPri:
          .               case ARMMMUIdx_MSUserNegPri:
          .                   return true;
          .               default:
 24,138,444 ( 0.03%)          return false;
          .               case ARMMMUIdx_E10_0:
          .               case ARMMMUIdx_E10_1:
          .               case ARMMMUIdx_E10_1_PAN:
          .                   g_assert_not_reached();
          .               }
          .           }
          .           
          .           /* Return the SCTLR value which controls this address translation regime */
-- line 742 ----------------------------------------
-- line 826 ----------------------------------------
          .            */
          .           static inline bool v7m_using_psp(CPUARMState *env)
          .           {
          .               /* Handler mode always uses the main stack; for thread mode
          .                * the CONTROL.SPSEL bit determines the answer.
          .                * Note that in v7M it is not possible to be in Handler mode with
          .                * CONTROL.SPSEL non-zero, but in v8M it is, so we must check both.
          .                */
 11,846,804 ( 0.02%)      return !arm_v7m_is_handler_mode(env) &&
  1,969,952 ( 0.00%)          env->v7m.control[env->v7m.secure] & R_V7M_CONTROL_SPSEL_MASK;
          .           }
          .           
          .           /**
          .            * v7m_sp_limit: Return SP limit for current CPU state
          .            * Return the SP limit value for the current CPU security state
          .            * and stack pointer.
          .            */
          .           static inline uint32_t v7m_sp_limit(CPUARMState *env)
-- line 843 ----------------------------------------
-- line 852 ----------------------------------------
          .           /**
          .            * v7m_cpacr_pass:
          .            * Return true if the v7M CPACR permits access to the FPU for the specified
          .            * security state and privilege level.
          .            */
          .           static inline bool v7m_cpacr_pass(CPUARMState *env,
          .                                             bool is_secure, bool is_priv)
          .           {
 13,255,805 ( 0.02%)      switch (extract32(env->v7m.cpacr[is_secure], 20, 2)) {
          .               case 0:
          .               case 2: /* UNPREDICTABLE: we treat like 0 */
          .                   return false;
          .               case 1:
          .                   return is_priv;
          .               case 3:
          .                   return true;
          .               default:
-- line 868 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cpu-exec.c
--------------------------------------------------------------------------------
Ir                     

-- line 67 ----------------------------------------
            .           
            .           static int64_t max_delay;
            .           static int64_t max_advance;
            .           
            .           static void align_clocks(SyncClocks *sc, CPUState *cpu)
            .           {
            .               int64_t cpu_icount;
            .           
  652,654,704 ( 0.89%)      if (!icount_align_option) {
            .                   return;
            .               }
            .           
            .               cpu_icount = cpu->icount_extra + cpu_neg(cpu)->icount_decr.u16.low;
            .               sc->diff_clk += icount_to_ns(sc->last_cpu_icount - cpu_icount);
            .               sc->last_cpu_icount = cpu_icount;
            .           
            .               if (sc->diff_clk > VM_CLOCK_ADVANCE) {
            .           #ifndef _WIN32
            .                   struct timespec sleep_delay, rem_delay;
            .                   sleep_delay.tv_sec = sc->diff_clk / 1000000000LL;
            .                   sleep_delay.tv_nsec = sc->diff_clk % 1000000000LL;
            .                   if (nanosleep(&sleep_delay, &rem_delay) < 0) {
            .                       sc->diff_clk = rem_delay.tv_sec * 1000000000LL + rem_delay.tv_nsec;
            .                   } else {
    3,014,928 ( 0.00%)              sc->diff_clk = 0;
            .                   }
            .           #else
            .                   Sleep(sc->diff_clk / SCALE_MS);
            .                   sc->diff_clk = 0;
            .           #endif
            .               }
            .           }
            .           
-- line 99 ----------------------------------------
-- line 116 ----------------------------------------
            .                       nb_prints++;
            .                       last_realtime_clock = sc->realtime_clock;
            .                   }
            .               }
            .           }
            .           
            .           static void init_delay_params(SyncClocks *sc, CPUState *cpu)
            .           {
      724,484 ( 0.00%)      if (!icount_align_option) {
            .                   return;
            .               }
            .               sc->realtime_clock = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL_RT);
            .               sc->diff_clk = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) - sc->realtime_clock;
            .               sc->last_cpu_icount
            .                   = cpu->icount_extra + cpu_neg(cpu)->icount_decr.u16.low;
            .               if (sc->diff_clk < max_delay) {
            .                   max_delay = sc->diff_clk;
-- line 132 ----------------------------------------
-- line 145 ----------------------------------------
            .           }
            .           
            .           static void init_delay_params(SyncClocks *sc, const CPUState *cpu)
            .           {
            .           }
            .           #endif /* CONFIG USER ONLY */
            .           
            .           uint32_t curr_cflags(CPUState *cpu)
  178,860,278 ( 0.25%)  {
  178,860,278 ( 0.25%)      uint32_t cflags = cpu->tcg_cflags;
            .           
            .               /*
            .                * Record gdb single-step.  We should be exiting the TB by raising
            .                * EXCP_DEBUG, but to simplify other tests, disable chaining too.
            .                *
            .                * For singlestep and -d nochain, suppress goto_tb so that
            .                * we can log -d cpu,exec after every TB.
            .                */
  536,580,834 ( 0.74%)      if (unlikely(cpu->singlestep_enabled)) {
            .                   cflags |= CF_NO_GOTO_TB | CF_NO_GOTO_PTR | CF_SINGLE_STEP | 1;
            .               } else if (singlestep) {
1,073,161,668 ( 1.47%)          cflags |= CF_NO_GOTO_TB | 1;
            .               } else if (qemu_loglevel_mask(CPU_LOG_TB_NOCHAIN)) {
            .                   cflags |= CF_NO_GOTO_TB;
            .               }
            .           
            .               return cflags;
  178,860,278 ( 0.25%)  }
            .           
            .           struct tb_desc {
            .               target_ulong pc;
            .               target_ulong cs_base;
            .               CPUArchState *env;
            .               tb_page_addr_t page_addr0;
            .               uint32_t flags;
            .               uint32_t cflags;
            .               uint32_t trace_vcpu_dstate;
            .           };
            .           
            .           static bool tb_lookup_cmp(const void *p, const void *d)
   11,458,888 ( 0.02%)  {
            .               const TranslationBlock *tb = p;
            .               const struct tb_desc *desc = d;
            .           
   18,582,117 ( 0.03%)      if ((TARGET_TB_PCREL || tb_pc(tb) == desc->pc) &&
   18,582,117 ( 0.03%)          tb_page_addr0(tb) == desc->page_addr0 &&
   15,794,547 ( 0.02%)          tb->cs_base == desc->cs_base &&
   15,794,547 ( 0.02%)          tb->flags == desc->flags &&
   10,529,698 ( 0.01%)          tb->trace_vcpu_dstate == desc->trace_vcpu_dstate &&
            .                   tb_cflags(tb) == desc->cflags) {
            .                   /* check next page if needed */
            .                   tb_page_addr_t tb_phys_page1 = tb_page_addr1(tb);
   10,529,698 ( 0.01%)          if (tb_phys_page1 == -1) {
    5,264,849 ( 0.01%)              return true;
            .                   } else {
            .                       tb_page_addr_t phys_page1;
            .                       target_ulong virt_page1;
            .           
            .                       /*
            .                        * We know that the first page matched, and an otherwise valid TB
            .                        * encountered an incomplete instruction at the end of that page,
            .                        * therefore we know that generating a new TB from the current PC
            .                        * must also require reading from the next page -- even if the
            .                        * second pages do not match, and therefore the resulting insn
            .                        * is different for the new TB.  Therefore any exception raised
            .                        * here by the faulting lookup is not premature.
            .                        */
        2,334 ( 0.00%)              virt_page1 = TARGET_PAGE_ALIGN(desc->pc);
            .                       phys_page1 = get_page_addr_code(desc->env, virt_page1);
          778 ( 0.00%)              if (tb_phys_page1 == phys_page1) {
            .                           return true;
            .                       }
            .                   }
            .               }
      929,190 ( 0.00%)      return false;
   11,458,888 ( 0.02%)  }
            .           
            .           static TranslationBlock *tb_htable_lookup(CPUState *cpu, target_ulong pc,
            .                                                     target_ulong cs_base, uint32_t flags,
            .                                                     uint32_t cflags)
   52,659,020 ( 0.07%)  {
            .               tb_page_addr_t phys_pc;
            .               struct tb_desc desc;
            .               uint32_t h;
            .           
   10,531,804 ( 0.01%)      desc.env = cpu->env_ptr;
    5,265,902 ( 0.01%)      desc.cs_base = cs_base;
    5,265,902 ( 0.01%)      desc.flags = flags;
    5,265,902 ( 0.01%)      desc.cflags = cflags;
   10,531,804 ( 0.01%)      desc.trace_vcpu_dstate = *cpu->trace_dstate;
    5,265,902 ( 0.01%)      desc.pc = pc;
            .               phys_pc = get_page_addr_code(desc.env, pc);
   10,531,804 ( 0.01%)      if (phys_pc == -1) {
            .                   return NULL;
            .               }
    5,265,902 ( 0.01%)      desc.page_addr0 = phys_pc;
            .               h = tb_hash_func(phys_pc, (TARGET_TB_PCREL ? 0 : pc),
            .                                flags, cflags, *cpu->trace_dstate);
   21,063,608 ( 0.03%)      return qht_lookup_custom(&tb_ctx.htable, &desc, h, tb_lookup_cmp);
  417,799,264 ( 0.57%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qht.c:qht_lookup_custom (5,265,902x)
   42,127,216 ( 0.06%)  }
            .           
            .           /* Might cause an exception, so have a longjmp destination ready */
            .           static inline TranslationBlock *tb_lookup(CPUState *cpu, target_ulong pc,
            .                                                     target_ulong cs_base,
            .                                                     uint32_t flags, uint32_t cflags)
            .           {
            .               TranslationBlock *tb;
            .               CPUJumpCache *jc;
            .               uint32_t hash;
            .           
            .               /* we should never be trying to look up an INVALID tb */
            .               tcg_debug_assert(!(cflags & CF_INVALID));
            .           
            .               hash = tb_jmp_cache_hash_func(pc);
  178,860,278 ( 0.25%)      jc = cpu->tb_jmp_cache;
            .               tb = tb_jmp_cache_get_tb(jc, hash);
            .           
2,279,553,682 ( 3.13%)      if (likely(tb &&
            .                          tb_jmp_cache_get_pc(jc, hash, tb) == pc &&
            .                          tb->cs_base == cs_base &&
            .                          tb->flags == flags &&
            .                          tb->trace_vcpu_dstate == *cpu->trace_dstate &&
            .                          tb_cflags(tb) == cflags)) {
            .                   return tb;
            .               }
   36,501,758 ( 0.05%)      tb = tb_htable_lookup(cpu, pc, cs_base, flags, cflags);
  951,885,388 ( 1.31%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cpu-exec.c:tb_htable_lookup (3,087,630x)
   25,969,954 ( 0.04%)      if (tb == NULL) {
            .                   return NULL;
            .               }
            .               tb_jmp_cache_set(jc, hash, tb, pc);
    5,264,849 ( 0.01%)      return tb;
            .           }
            .           
            .           static void log_cpu_exec(target_ulong pc, CPUState *cpu,
            .                                    const TranslationBlock *tb)
            .           {
            .               if (qemu_log_in_addr_range(pc)) {
            .                   qemu_log_mask(CPU_LOG_EXEC,
            .                                 "Trace %d: %p [" TARGET_FMT_lx
-- line 283 ----------------------------------------
-- line 369 ----------------------------------------
            .                   *cflags = (*cflags & ~CF_COUNT_MASK) | CF_NO_GOTO_TB | 1;
            .               }
            .               return false;
            .           }
            .           
            .           static inline bool check_for_breakpoints(CPUState *cpu, target_ulong pc,
            .                                                    uint32_t *cflags)
            .           {
  372,412,182 ( 0.51%)      return unlikely(!QTAILQ_EMPTY(&cpu->breakpoints)) &&
            .                   check_for_breakpoints_slow(cpu, pc, cflags);
            .           }
            .           
            .           /**
            .            * helper_lookup_tb_ptr: quick check for next tb
            .            * @env: current cpu state
            .            *
            .            * Look for an existing TB matching the current cpu state.
            .            * If found, return the code pointer.  If not found, return
            .            * the tcg epilogue so that we return into cpu_tb_exec.
            .            */
            .           const void *HELPER(lookup_tb_ptr)(CPUArchState *env)
  176,299,512 ( 0.24%)  {
            .               CPUState *cpu = env_cpu(env);
            .               TranslationBlock *tb;
            .               target_ulong cs_base, pc;
            .               uint32_t flags, cflags;
            .           
   58,766,504 ( 0.08%)      cpu_get_tb_cpu_state(env, &pc, &cs_base, &flags);
  837,422,682 ( 1.15%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:cpu_get_tb_cpu_state (14,691,626x)
            .           
   44,074,878 ( 0.06%)      cflags = curr_cflags(cpu);
  176,299,512 ( 0.24%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cpu-exec.c:curr_cflags (14,691,626x)
   14,691,626 ( 0.02%)      if (check_for_breakpoints(cpu, pc, &cflags)) {
            .                   cpu_loop_exit(cpu);
            .               }
            .           
   29,383,252 ( 0.04%)      tb = tb_lookup(cpu, pc, cs_base, flags, cflags);
            .               if (tb == NULL) {
          921 ( 0.00%)          return tcg_code_gen_epilogue;
            .               }
            .           
            .               if (qemu_loglevel_mask(CPU_LOG_TB_CPU | CPU_LOG_EXEC)) {
            .                   log_cpu_exec(pc, cpu, tb);
            .               }
            .           
   14,691,319 ( 0.02%)      return tb->tc.ptr;
  161,607,886 ( 0.22%)  }
            .           
            .           /* Execute a TB, and fix up the CPU state afterwards if necessary */
            .           /*
            .            * Disable CFI checks.
            .            * TCG creates binary blobs at runtime, with the transformed code.
            .            * A TB is a blob of binary code, created at runtime and called with an
            .            * indirect function call. Since such function did not exist at compile time,
            .            * the CFI runtime has no way to verify its signature and would fail.
-- line 421 ----------------------------------------
-- line 430 ----------------------------------------
            .               TranslationBlock *last_tb;
            .               const void *tb_ptr = itb->tc.ptr;
            .           
            .               if (qemu_loglevel_mask(CPU_LOG_TB_CPU | CPU_LOG_EXEC)) {
            .                   log_cpu_exec(log_pc(cpu, itb), cpu, itb);
            .               }
            .               
            .               qemu_thread_jit_execute();
  656,674,608 ( 0.90%)      ret = tcg_qemu_tb_exec(env, tb_ptr);
34,160,870,724 (46.83%)  => ???:0x0000000058c5f000 (164,168,652x)
  163,163,676 ( 0.22%)      cpu->can_do_io = 1;
            .               /*
            .                * TODO: Delay swapping back to the read-write region of the TB
            .                * until we actually need to modify the TB.  The read-only copy,
            .                * coming from the rx region, shares the same host TLB entry as
            .                * the code that executed the exit_tb opcode that arrived here.
            .                * If we insist on touching both the RX and the RW pages, we
            .                * double the host TLB pressure.
            .                */
            .               last_tb = tcg_splitwx_to_rw((void *)(ret & ~TB_EXIT_MASK));
  326,327,352 ( 0.45%)      *tb_exit = ret & TB_EXIT_MASK;
            .           
            .               trace_exec_tb_exit(last_tb, *tb_exit);
            .           
  326,327,352 ( 0.45%)      if (*tb_exit > TB_EXIT_IDX1) {
            .                   /* We didn't start executing this TB (eg because the instruction
            .                    * counter hit zero); we must restore the guest PC to the address
            .                    * of the start of the TB.
            .                    */
            .                   CPUClass *cc = CPU_GET_CLASS(cpu);
            .           
            .                   if (cc->tcg_ops->synchronize_from_tb) {
            .                       cc->tcg_ops->synchronize_from_tb(cpu, last_tb);
-- line 461 ----------------------------------------
-- line 474 ----------------------------------------
            .                   }
            .               }
            .           
            .               /*
            .                * If gdb single-step, and we haven't raised another exception,
            .                * raise a debug exception.  Single-step with another exception
            .                * is handled in cpu_handle_exception.
            .                */
  489,491,028 ( 0.67%)      if (unlikely(cpu->singlestep_enabled) && cpu->exception_index == -1) {
            .                   cpu->exception_index = EXCP_DEBUG;
            .                   cpu_loop_exit(cpu);
            .               }
            .           
            .               return last_tb;
            .           }
            .           
            .           
            .           static void cpu_exec_enter(CPUState *cpu)
            .           {
            .               CPUClass *cc = CPU_GET_CLASS(cpu);
            .           
      724,484 ( 0.00%)      if (cc->tcg_ops->cpu_exec_enter) {
            .                   cc->tcg_ops->cpu_exec_enter(cpu);
            .               }
            .           }
            .           
            .           static void cpu_exec_exit(CPUState *cpu)
            .           {
            .               CPUClass *cc = CPU_GET_CLASS(cpu);
            .           
      724,480 ( 0.00%)      if (cc->tcg_ops->cpu_exec_exit) {
            .                   cc->tcg_ops->cpu_exec_exit(cpu);
            .               }
            .           }
            .           
            .           void cpu_exec_step_atomic(CPUState *cpu)
            .           {
            .               CPUArchState *env = cpu->env_ptr;
            .               TranslationBlock *tb;
-- line 512 ----------------------------------------
-- line 566 ----------------------------------------
            .                * the execution.
            .                */
            .               g_assert(cpu_in_exclusive_context(cpu));
            .               cpu->running = false;
            .               end_exclusive();
            .           }
            .           
            .           void tb_set_jmp_target(TranslationBlock *tb, int n, uintptr_t addr)
        1,021 ( 0.00%)  {
            .               if (TCG_TARGET_HAS_direct_jump) {
        1,021 ( 0.00%)          uintptr_t offset = tb->jmp_target_arg[n];
            .                   uintptr_t tc_ptr = (uintptr_t)tb->tc.ptr;
        2,042 ( 0.00%)          uintptr_t jmp_rx = tc_ptr + offset;
        3,063 ( 0.00%)          uintptr_t jmp_rw = jmp_rx - tcg_splitwx_diff;
            .                   tb_target_set_jmp_target(tc_ptr, jmp_rx, jmp_rw, addr);
            .               } else {
            .                   tb->jmp_target_arg[n] = addr;
            .               }
        1,021 ( 0.00%)  }
            .           
            .           static inline void tb_add_jump(TranslationBlock *tb, int n,
            .                                          TranslationBlock *tb_next)
            .           {
            .               uintptr_t old;
            .           
            .               qemu_thread_jit_write();
  318,323,422 ( 0.44%)      assert(n < ARRAY_SIZE(tb->jmp_list_next));
            .               qemu_spin_lock(&tb_next->jmp_lock);
            .           
            .               /* make sure the destination TB is valid */
  318,323,422 ( 0.44%)      if (tb_next->cflags & CF_INVALID) {
            .                   goto out_unlock_next;
            .               }
            .               /* Atomically claim the jump destination slot only if it was NULL */
  318,323,422 ( 0.44%)      old = qatomic_cmpxchg(&tb->jmp_dest[n], (uintptr_t)NULL,
            .                                     (uintptr_t)tb_next);
  477,485,133 ( 0.65%)      if (old) {
            .                   goto out_unlock_next;
            .               }
            .           
            .               /* patch the native jump address */
        1,572 ( 0.00%)      tb_set_jmp_target(tb, n, (uintptr_t)tb_next->tc.ptr);
        4,323 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cpu-exec.c:tb_set_jmp_target (393x)
            .           
            .               /* add in TB jmp list */
          786 ( 0.00%)      tb->jmp_list_next[n] = tb_next->jmp_list_head;
          786 ( 0.00%)      tb_next->jmp_list_head = (uintptr_t)tb | n;
            .           
            .               qemu_spin_unlock(&tb_next->jmp_lock);
            .           
          393 ( 0.00%)      qemu_log_mask(CPU_LOG_EXEC, "Linking TBs %p index %d -> %p\n",
            .                             tb->tc.ptr, n, tb_next->tc.ptr);
            .               return;
            .           
            .            out_unlock_next:
            .               qemu_spin_unlock(&tb_next->jmp_lock);
            .               return;
            .           }
            .           
            .           static inline bool cpu_handle_halt(CPUState *cpu)
            .           {
            .           #ifndef CONFIG_USER_ONLY
      543,363 ( 0.00%)      if (cpu->halted) {
            .           #if defined(TARGET_I386)
            .                   if (cpu->interrupt_request & CPU_INTERRUPT_POLL) {
            .                       X86CPU *x86_cpu = X86_CPU(cpu);
            .                       qemu_mutex_lock_iothread();
            .                       apic_poll_irq(x86_cpu->apic_state);
            .                       cpu_reset_interrupt(cpu, CPU_INTERRUPT_POLL);
            .                       qemu_mutex_unlock_iothread();
            .                   }
            .           #endif /* TARGET_I386 */
      362,240 ( 0.00%)          if (!cpu_has_work(cpu)) {
            .                       return true;
            .                   }
            .           
      543,360 ( 0.00%)          cpu->halted = 0;
            .               }
            .           #endif /* !CONFIG_USER_ONLY */
            .           
            .               return false;
            .           }
            .           
            .           static inline void cpu_handle_debug_exception(CPUState *cpu)
            .           {
-- line 649 ----------------------------------------
-- line 658 ----------------------------------------
            .           
            .               if (cc->tcg_ops->debug_excp_handler) {
            .                   cc->tcg_ops->debug_excp_handler(cpu);
            .               }
            .           }
            .           
            .           static inline bool cpu_handle_exception(CPUState *cpu, int *ret)
            .           {
    5,930,480 ( 0.01%)      if (cpu->exception_index < 0) {
            .           #ifndef CONFIG_USER_ONLY
      603,360 ( 0.00%)          if (replay_has_exception()
    1,206,720 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../replay/replay.c:replay_has_exception (201,120x)
            .                       && cpu_neg(cpu)->icount_decr.u16.low + cpu->icount_extra == 0) {
            .                       /* Execute just one insn to trigger exception pending in the log */
            .                       cpu->cflags_next_tb = (curr_cflags(cpu) & ~CF_USE_ICOUNT)
            .                           | CF_NOIRQ | 1;
            .                   }
            .           #endif
            .                   return false;
            .               }
    1,969,952 ( 0.00%)      if (cpu->exception_index >= EXCP_INTERRUPT) {
            .                   /* exit request from the cpu execution loop */
            .                   *ret = cpu->exception_index;
      362,240 ( 0.00%)          if (*ret == EXCP_DEBUG) {
            .                       cpu_handle_debug_exception(cpu);
            .                   }
      362,240 ( 0.00%)          cpu->exception_index = -1;
            .                   return true;
            .               } else {
            .           #if defined(CONFIG_USER_ONLY)
            .                   /* if user mode only, we simulate a fake exception
            .                      which will be handled outside the cpu execution
            .                      loop */
            .           #if defined(TARGET_I386)
            .                   CPUClass *cc = CPU_GET_CLASS(cpu);
            .                   cc->tcg_ops->fake_user_interrupt(cpu);
            .           #endif /* TARGET_I386 */
            .                   *ret = cpu->exception_index;
            .                   cpu->exception_index = -1;
            .                   return true;
            .           #else
    2,411,568 ( 0.00%)          if (replay_exception()) {
    8,842,416 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../replay/replay.c:replay_exception (803,856x)
            .                       CPUClass *cc = CPU_GET_CLASS(cpu);
    2,411,568 ( 0.00%)              qemu_mutex_lock_iothread();
   52,250,640 ( 0.07%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:qemu_mutex_lock_iothread_impl (803,856x)
    2,411,568 ( 0.00%)              cc->tcg_ops->do_interrupt(cpu);
5,561,843,910 ( 7.63%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:arm_v7m_cpu_do_interrupt (803,856x)
      803,856 ( 0.00%)              qemu_mutex_unlock_iothread();
   45,819,792 ( 0.06%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:qemu_mutex_unlock_iothread (803,856x)
      803,856 ( 0.00%)              cpu->exception_index = -1;
            .           
    2,411,568 ( 0.00%)              if (unlikely(cpu->singlestep_enabled)) {
            .                           /*
            .                            * After processing the exception, ensure an EXCP_DEBUG is
            .                            * raised when single-stepping so that GDB doesn't miss the
            .                            * next instruction.
            .                            */
            .                           *ret = EXCP_DEBUG;
            .                           cpu_handle_debug_exception(cpu);
            .                           return true;
-- line 713 ----------------------------------------
-- line 742 ----------------------------------------
            .           static inline bool cpu_handle_interrupt(CPUState *cpu,
            .                                                   TranslationBlock **last_tb)
            .           {
            .               /*
            .                * If we have requested custom cflags with CF_NOIRQ we should
            .                * skip checking here. Any pending interrupts will get picked up
            .                * by the next TB we execute under normal cflags.
            .                */
  492,505,956 ( 0.68%)      if (cpu->cflags_next_tb != -1 && cpu->cflags_next_tb & CF_NOIRQ) {
            .                   return false;
            .               }
            .           
            .               /* Clear the interrupt flag now since we're processing
            .                * cpu->interrupt_request and cpu->exit_request.
            .                * Ensure zeroing happens before reading cpu->exit_request or
            .                * cpu->interrupt_request (see also smp_wmb in cpu_exit())
            .                */
  328,337,304 ( 0.45%)      qatomic_mb_set(&cpu_neg(cpu)->icount_decr.u16.high, 0);
            .           
  492,505,956 ( 0.68%)      if (unlikely(qatomic_read(&cpu->interrupt_request))) {
            .                   int interrupt_request;
    5,433,630 ( 0.01%)          qemu_mutex_lock_iothread();
  117,728,650 ( 0.16%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:qemu_mutex_lock_iothread_impl (1,811,210x)
    1,811,210 ( 0.00%)          interrupt_request = cpu->interrupt_request;
            .                   if (unlikely(cpu->singlestep_enabled & SSTEP_NOIRQ)) {
            .                       /* Mask out external interrupts for this step. */
    7,244,840 ( 0.01%)              interrupt_request &= ~CPU_INTERRUPT_SSTEP_MASK;
            .                   }
    3,622,420 ( 0.00%)          if (interrupt_request & CPU_INTERRUPT_DEBUG) {
            .                       cpu->interrupt_request &= ~CPU_INTERRUPT_DEBUG;
            .                       cpu->exception_index = EXCP_DEBUG;
            .                       qemu_mutex_unlock_iothread();
            .                       return true;
            .                   }
            .           #if !defined(CONFIG_USER_ONLY)
    5,433,630 ( 0.01%)          if (replay_mode == REPLAY_MODE_PLAY && !replay_has_interrupt()) {
            .                       /* Do nothing */
    3,622,420 ( 0.00%)          } else if (interrupt_request & CPU_INTERRUPT_HALT) {
            .                       replay_interrupt();
            .                       cpu->interrupt_request &= ~CPU_INTERRUPT_HALT;
            .                       cpu->halted = 1;
            .                       cpu->exception_index = EXCP_HLT;
            .                       qemu_mutex_unlock_iothread();
            .                       return true;
            .                   }
            .           #if defined(TARGET_I386)
-- line 786 ----------------------------------------
-- line 790 ----------------------------------------
            .                       replay_interrupt();
            .                       cpu_svm_check_intercept_param(env, SVM_EXIT_INIT, 0, 0);
            .                       do_cpu_init(x86_cpu);
            .                       cpu->exception_index = EXCP_HALTED;
            .                       qemu_mutex_unlock_iothread();
            .                       return true;
            .                   }
            .           #else
    3,622,420 ( 0.00%)          else if (interrupt_request & CPU_INTERRUPT_RESET) {
            .                       replay_interrupt();
            .                       cpu_reset(cpu);
            .                       qemu_mutex_unlock_iothread();
            .                       return true;
            .                   }
            .           #endif /* !TARGET_I386 */
            .                   /* The target hook has 3 exit conditions:
            .                      False when the interrupt isn't processed,
            .                      True when it is, and we should restart on a new TB,
            .                      and via longjmp via cpu_loop_exit.  */
            .                   else {
            .                       CPUClass *cc = CPU_GET_CLASS(cpu);
            .           
   10,867,260 ( 0.01%)              if (cc->tcg_ops->cpu_exec_interrupt &&
    5,433,630 ( 0.01%)                  cc->tcg_ops->cpu_exec_interrupt(cpu, interrupt_request)) {
1,961,897,663 ( 2.69%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/cpu_tcg.c:arm_v7m_cpu_exec_interrupt (1,811,210x)
            .                           if (need_replay_interrupt(interrupt_request)) {
      181,120 ( 0.00%)                      replay_interrupt();
    1,992,320 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../replay/replay.c:replay_interrupt (181,120x)
            .                           }
            .                           /*
            .                            * After processing the interrupt, ensure an EXCP_DEBUG is
            .                            * raised when single-stepping so that GDB doesn't miss the
            .                            * next instruction.
            .                            */
      543,360 ( 0.00%)                  if (unlikely(cpu->singlestep_enabled)) {
            .                               cpu->exception_index = EXCP_DEBUG;
            .                               qemu_mutex_unlock_iothread();
            .                               return true;
            .                           }
      181,120 ( 0.00%)                  cpu->exception_index = -1;
      362,240 ( 0.00%)                  *last_tb = NULL;
            .                       }
            .                       /* The target hook may have updated the 'cpu->interrupt_request';
            .                        * reload the 'interrupt_request' value */
    1,811,210 ( 0.00%)              interrupt_request = cpu->interrupt_request;
            .                   }
            .           #endif /* !CONFIG_USER_ONLY */
    3,622,420 ( 0.00%)          if (interrupt_request & CPU_INTERRUPT_EXITTB) {
            .                       cpu->interrupt_request &= ~CPU_INTERRUPT_EXITTB;
            .                       /* ensure that no TB jump will be modified as
            .                          the program flow was changed */
            .                       *last_tb = NULL;
            .                   }
            .           
            .                   /* If we exit via cpu_loop_exit/longjmp it is reset in cpu_exec */
    3,622,420 ( 0.00%)          qemu_mutex_unlock_iothread();
  103,238,970 ( 0.14%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:qemu_mutex_unlock_iothread (1,811,210x)
            .               }
            .           
            .               /* Finally, check if we need to exit to the main loop.  */
  656,674,608 ( 0.90%)      if (unlikely(qatomic_read(&cpu->exit_request))
  656,674,608 ( 0.90%)          || (icount_enabled()
            .                       && (cpu->cflags_next_tb == -1 || cpu->cflags_next_tb & CF_USE_ICOUNT)
            .                       && cpu_neg(cpu)->icount_decr.u16.low + cpu->icount_extra == 0)) {
            .                   qatomic_set(&cpu->exit_request, 0);
            .                   if (cpu->exception_index == -1) {
            .                       cpu->exception_index = EXCP_INTERRUPT;
            .                   }
            .                   return true;
            .               }
-- line 856 ----------------------------------------
-- line 861 ----------------------------------------
            .           static inline void cpu_loop_exec_tb(CPUState *cpu, TranslationBlock *tb,
            .                                               target_ulong pc,
            .                                               TranslationBlock **last_tb, int *tb_exit)
            .           {
            .               int32_t insns_left;
            .           
            .               trace_exec_tb(tb, pc);
            .               tb = cpu_tb_exec(cpu, tb, tb_exit);
  326,327,352 ( 0.45%)      if (*tb_exit != TB_EXIT_REQUESTED) {
            .                   *last_tb = tb;
            .                   return;
            .               }
            .           
            .               *last_tb = NULL;
            .               insns_left = qatomic_read(&cpu_neg(cpu)->icount_decr.u32);
            .               if (insns_left < 0) {
            .                   /* Something asked us to stop executing chained TBs; just
-- line 877 ----------------------------------------
-- line 905 ----------------------------------------
            .                   cpu->cflags_next_tb = (tb->cflags & ~CF_COUNT_MASK) | insns_left;
            .               }
            .           #endif
            .           }
            .           
            .           /* main execution loop */
            .           
            .           int cpu_exec(CPUState *cpu)
    2,354,573 ( 0.00%)  {
            .               int ret;
      362,242 ( 0.00%)      SyncClocks sc = { 0 };
            .           
            .               /* replay_interrupt may need current_cpu */
      543,363 ( 0.00%)      current_cpu = cpu;
    2,535,694 ( 0.00%)  => ???:0x0000000004e3cc50 (181,121x)
            .           
            .               if (cpu_handle_halt(cpu)) {
            .                   return EXCP_HALTED;
            .               }
            .           
            .               rcu_read_lock();
            .           
            .               cpu_exec_enter(cpu);
-- line 926 ----------------------------------------
-- line 928 ----------------------------------------
            .               /* Calculate difference between guest clock and host clock.
            .                * This delay includes the delay of the last cycle, so
            .                * what we have to do is sleep until it is 0. As for the
            .                * advance/delay we gain here, we try to fix it next time.
            .                */
            .               init_delay_params(&sc, cpu);
            .           
            .               /* prepare setjmp context for exception handling */
    4,282,772 ( 0.01%)      if (sigsetjmp(cpu->jmp_env, 0) != 0) {
    5,976,993 ( 0.01%)  => ???:0x0000000004e3c6f0 (181,121x)
            .           #if defined(__clang__)
            .                   /*
            .                    * Some compilers wrongly smash all local variables after
            .                    * siglongjmp (the spec requires that only non-volatile locals
            .                    * which are changed between the sigsetjmp and siglongjmp are
            .                    * permitted to be trashed). There were bug reports for gcc
            .                    * 4.5.0 and clang.  The bug is fixed in all versions of gcc
            .                    * that we support, but is still unfixed in clang:
-- line 944 ----------------------------------------
-- line 946 ----------------------------------------
            .                    *
            .                    * Reload an essential local variable here for those compilers.
            .                    * Newer versions of gcc would complain about this code (-Wclobbered),
            .                    * so we only perform the workaround for clang.
            .                    */
            .                   cpu = current_cpu;
            .           #else
            .                   /* Non-buggy compilers preserve this; assert the correct value. */
    5,024,875 ( 0.01%)          g_assert(cpu == current_cpu);
   14,069,650 ( 0.02%)  => ???:0x0000000004e3cc50 (1,004,975x)
            .           #endif
            .           
            .           #ifndef CONFIG_SOFTMMU
            .                   clear_helper_retaddr();
            .                   if (have_mmap_lock()) {
            .                       mmap_unlock();
            .                   }
            .           #endif
    3,014,925 ( 0.00%)          if (qemu_mutex_iothread_locked()) {
   22,109,450 ( 0.03%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:qemu_mutex_iothread_locked (1,004,975x)
            1 ( 0.00%)              qemu_mutex_unlock_iothread();
           57 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:qemu_mutex_unlock_iothread (1x)
            .                   }
    2,009,951 ( 0.00%)          qemu_plugin_disable_mem_helpers(cpu);
    3,014,925 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../plugins/core.c:qemu_plugin_disable_mem_helpers (1,004,975x)
            .           
            .                   assert_no_pages_locked();
            .               }
            .           
            .               /* if an exception is pending, we execute it here */
            .               while (!cpu_handle_exception(cpu, &ret)) {
            .                   TranslationBlock *last_tb = NULL;
            .                   int tb_exit = 0;
            .                   while (!cpu_handle_interrupt(cpu, &last_tb)) {
            .                       TranslationBlock *tb;
            .                       target_ulong cs_base, pc;
            .                       uint32_t flags, cflags;
  820,843,260 ( 1.13%)              cpu_get_tb_cpu_state(cpu->env_ptr, &pc, &cs_base, &flags);
9,357,613,164 (12.83%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:cpu_get_tb_cpu_state (164,168,652x)
            .           	    /*
            .                        * When requested, use an exact setting for cflags for the next
            .                        * execution.  This is used for icount, precise smc, and stop-
            .                        * after-access watchpoints.  Since this request should never
            .                        * have CF_INVALID set, -1 is a convenient invalid value that
            .                        * does not require tcg headers for cpu_common_reset.
            .                        */
  328,337,304 ( 0.45%)              cflags = cpu->cflags_next_tb;
  328,337,304 ( 0.45%)              if (cflags == -1) {
  492,505,956 ( 0.68%)                  cflags = curr_cflags(cpu);
1,970,023,824 ( 2.70%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cpu-exec.c:curr_cflags (164,168,652x)
            .                       } else {
            .                           cpu->cflags_next_tb = -1;
            .                       }
            .           
  164,168,652 ( 0.23%)              if (check_for_breakpoints(cpu, pc, &cflags)) {
            .                           break;
            .                       }
            .           
  492,505,956 ( 0.68%)              tb = tb_lookup(cpu, pc, cs_base, flags, cflags);
            .                       if (tb == NULL) {
            .                           uint32_t h;
            .           
            .                           mmap_lock();
        5,222 ( 0.00%)                  tb = tb_gen_code(cpu, pc, cs_base, flags, cflags);
   39,690,646 ( 0.05%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/translate-all.c:tb_gen_code (746x)
            .                           mmap_unlock();
            .                           /*
            .                            * We add the TB in the virtual pc hash table
            .                            * for the fast lookup
            .                            */
          746 ( 0.00%)                  h = tb_jmp_cache_hash_func(pc);
            .                           tb_jmp_cache_set(cpu->tb_jmp_cache, h, tb, pc);
            .                       }
            .           
            .           #ifndef CONFIG_USER_ONLY
            .                       /*
            .                        * We don't take care of direct jumps when address mapping
            .                        * changes in system emulation.  So it's not safe to make a
            .                        * direct jump to a TB spanning two pages because the mapping
            .                        * for the second page can change.
            .                        */
            .                       if (tb_page_addr1(tb) != -1) {
            .                           last_tb = NULL;
            .                       }
            .           #endif
            .                       /* See if we can patch the calling TB. */
  656,533,916 ( 0.90%)              if (last_tb) {
            .                           tb_add_jump(last_tb, tb_exit, tb);
            .                       }
            .           
            .                       cpu_loop_exec_tb(cpu, tb, pc, &last_tb, &tb_exit);
            .           
            .                       /* Try to align the host and virtual clocks
            .                          if the guest is in advance */
            .                       align_clocks(&sc, cpu);
            .                   }
            .               }
            .               cpu_exec_exit(cpu);
            .               rcu_read_unlock();
            .           
            .               return ret;
    2,173,440 ( 0.00%)  }
            .           
            .           void tcg_exec_realizefn(CPUState *cpu, Error **errp)
            3 ( 0.00%)  {
            .               static bool tcg_target_initialized;
            .               CPUClass *cc = CPU_GET_CLASS(cpu);
            .           
            2 ( 0.00%)      if (!tcg_target_initialized) {
            2 ( 0.00%)          cc->tcg_ops->initialize();
        2,079 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/translate.c:arm_translate_init (1x)
            1 ( 0.00%)          tcg_target_initialized = true;
            .               }
            .           
            3 ( 0.00%)      cpu->tb_jmp_cache = g_new0(CPUJumpCache, 1);
       65,817 ( 0.00%)  => ???:0x0000000004e3cc20 (1x)
            2 ( 0.00%)      tlb_init(cpu);
      104,373 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:tlb_init (1x)
            .           #ifndef CONFIG_USER_ONLY
            2 ( 0.00%)      tcg_iommu_init_notifier_list(cpu);
          190 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:tcg_iommu_init_notifier_list (1x)
            .           #endif /* !CONFIG_USER_ONLY */
            .               /* qemu_plugin_vcpu_init_hook delayed until cpu_index assigned. */
            1 ( 0.00%)  }
            .           
            .           /* undo the initializations in reverse order */
            .           void tcg_exec_unrealizefn(CPUState *cpu)
            .           {
            .               qemu_plugin_vcpu_exit_hook(cpu);
            .           #ifndef CONFIG_USER_ONLY
            .               tcg_iommu_free_notifier_list(cpu);
            .           #endif /* !CONFIG_USER_ONLY */
-- line 1066 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/tcg-runtime.c
--------------------------------------------------------------------------------
Ir                   

-- line 33 ----------------------------------------
          .           
          .           /* 32-bit helpers */
          .           
          .           typedef bool (*exec_bbl_cb)(uint64_t pc,uint32_t id); 
          .           extern exec_bbl_cb exec_bbl_func;
          .           typedef void (*exec_ins_icmp_cb)(uint64_t val1,uint64_t val2, int used_bits);
          .           extern exec_ins_icmp_cb exec_ins_icmp_func;
          .           uint64_t HELPER(xx_bbl)(CPUArchState *env,uint64_t pc,uint32_t id)
894,299,855 ( 1.23%)  {
357,719,942 ( 0.49%)      bool should_exit = exec_bbl_func(pc,id);
9,516,080,761 (13.05%)  => ???:arm_exec_bbl (178,859,971x)
357,719,940 ( 0.49%)      if(should_exit)
          .               {
          .           	    CPUState *cpu = env_cpu(env);
     19,999 ( 0.00%)  	    cpu_loop_exit(cpu);
  1,579,921 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cpu-exec-common.c:cpu_loop_exit (19,999x)
          .               }
          .               return 1;
536,519,913 ( 0.74%)  }
          .           uint64_t HELPER(xx_icmp32_ins)(uint32_t val1,uint32_t val2)
          .           {
          .               exec_ins_icmp_func(val1,val2,32);
          .               return 1;
          .           }
          .           uint64_t HELPER(xx_icmp64_ins)(uint64_t val1,uint64_t val2)
          .           {
          .               exec_ins_icmp_func(val1,val2,64);
-- line 57 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/include/exec/ram_addr.h
--------------------------------------------------------------------------------
Ir                  

-- line 72 ----------------------------------------
         .           {
         .               uint8_t shift = rb->clear_bmap_shift;
         .           
         .               return bitmap_test_and_clear(rb->clear_bmap, page >> shift, 1);
         .           }
         .           
         .           static inline bool offset_in_ramblock(RAMBlock *b, ram_addr_t offset)
         .           {
44,223,195 ( 0.06%)      return (b && b->host && offset < b->used_length) ? true : false;
         .           }
         .           
         .           static inline void *ramblock_ptr(RAMBlock *block, ram_addr_t offset)
         .           {
         .               assert(offset_in_ramblock(block, offset));
 8,844,639 ( 0.01%)      return (char *)block->host + offset;
         .           }
         .           
         .           static inline unsigned long int ramblock_recv_bitmap_offset(void *host_addr,
         .                                                                       RAMBlock *rb)
         .           {
         .               uint64_t host_addr_offset =
         .                       (uint64_t)(uintptr_t)(host_addr - (void *)rb->host);
         .               return host_addr_offset >> TARGET_PAGE_BITS;
-- line 94 ----------------------------------------
-- line 154 ----------------------------------------
         .           {
         .               DirtyMemoryBlocks *blocks;
         .               unsigned long end, page;
         .               unsigned long idx, offset, base;
         .               bool dirty = false;
         .           
         .               assert(client < DIRTY_MEMORY_NUM);
         .           
 7,692,867 ( 0.01%)      end = TARGET_PAGE_ALIGN(start + length) >> TARGET_PAGE_BITS;
 1,378,778 ( 0.00%)      page = start >> TARGET_PAGE_BITS;
         .           
         .               WITH_RCU_READ_LOCK_GUARD() {
 1,378,778 ( 0.00%)          blocks = qatomic_rcu_read(&ram_list.dirty_memory[client]);
         .           
 1,378,778 ( 0.00%)          idx = page / DIRTY_MEMORY_BLOCK_SIZE;
 1,378,778 ( 0.00%)          offset = page % DIRTY_MEMORY_BLOCK_SIZE;
 1,476,408 ( 0.00%)          base = page - offset;
 2,729,506 ( 0.00%)          while (page < end) {
 3,446,945 ( 0.00%)              unsigned long next = MIN(end, base + DIRTY_MEMORY_BLOCK_SIZE);
 1,378,778 ( 0.00%)              unsigned long num = next - base;
 2,068,167 ( 0.00%)              unsigned long found = find_next_bit(blocks->blocks[idx],
 8,778,242 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/bitops.c:find_next_bit (298,869x)
         .                                                           num, offset);
 1,378,778 ( 0.00%)              if (found < num) {
   535,358 ( 0.00%)                  dirty = true;
         .                           break;
         .                       }
         .           
         .                       page = next;
         .                       idx++;
    56,401 ( 0.00%)              offset = 0;
         .                       base += DIRTY_MEMORY_BLOCK_SIZE;
         .                   }
         .               }
         .           
         .               return dirty;
         .           }
         .           
         .           static inline bool cpu_physical_memory_all_dirty(ram_addr_t start,
-- line 191 ----------------------------------------
-- line 194 ----------------------------------------
         .           {
         .               DirtyMemoryBlocks *blocks;
         .               unsigned long end, page;
         .               unsigned long idx, offset, base;
         .               bool dirty = true;
         .           
         .               assert(client < DIRTY_MEMORY_NUM);
         .           
83,051,880 ( 0.11%)      end = TARGET_PAGE_ALIGN(start + length) >> TARGET_PAGE_BITS;
16,610,376 ( 0.02%)      page = start >> TARGET_PAGE_BITS;
         .           
         .               RCU_READ_LOCK_GUARD();
         .           
16,610,376 ( 0.02%)      blocks = qatomic_rcu_read(&ram_list.dirty_memory[client]);
         .           
16,610,376 ( 0.02%)      idx = page / DIRTY_MEMORY_BLOCK_SIZE;
16,610,376 ( 0.02%)      offset = page % DIRTY_MEMORY_BLOCK_SIZE;
16,610,376 ( 0.02%)      base = page - offset;
82,228,980 ( 0.11%)      while (page < end) {
41,525,940 ( 0.06%)          unsigned long next = MIN(end, base + DIRTY_MEMORY_BLOCK_SIZE);
24,915,564 ( 0.03%)          unsigned long num = next - base;
41,525,940 ( 0.06%)          unsigned long found = find_next_zero_bit(blocks->blocks[idx], num, offset);
230,739,431 ( 0.32%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/bitops.c:find_next_zero_bit (8,305,188x)
25,080,144 ( 0.03%)          if (found < num) {
         .                       dirty = false;
         .                       break;
         .                   }
         .           
         .                   page = next;
         .                   idx++;
 8,140,608 ( 0.01%)          offset = 0;
         .                   base += DIRTY_MEMORY_BLOCK_SIZE;
         .               }
         .           
         .               return dirty;
         .           }
         .           
         .           static inline bool cpu_physical_memory_get_dirty_flag(ram_addr_t addr,
         .                                                                 unsigned client)
-- line 231 ----------------------------------------
-- line 234 ----------------------------------------
         .           }
         .           
         .           static inline bool cpu_physical_memory_is_clean(ram_addr_t addr)
         .           {
         .               bool vga = cpu_physical_memory_get_dirty_flag(addr, DIRTY_MEMORY_VGA);
         .               bool code = cpu_physical_memory_get_dirty_flag(addr, DIRTY_MEMORY_CODE);
         .               bool migration =
         .                   cpu_physical_memory_get_dirty_flag(addr, DIRTY_MEMORY_MIGRATION);
   733,034 ( 0.00%)      return !(vga && code && migration);
         .           }
         .           
         .           static inline uint8_t cpu_physical_memory_range_includes_clean(ram_addr_t start,
         .                                                                          ram_addr_t length,
         .                                                                          uint8_t mask)
         .           {
 3,988,014 ( 0.01%)      uint8_t ret = 0;
         .           
12,457,782 ( 0.02%)      if (mask & (1 << DIRTY_MEMORY_VGA) &&
         .                   !cpu_physical_memory_all_dirty(start, length, DIRTY_MEMORY_VGA)) {
         .                   ret |= (1 << DIRTY_MEMORY_VGA);
         .               }
16,610,376 ( 0.02%)      if (mask & (1 << DIRTY_MEMORY_CODE) &&
         .                   !cpu_physical_memory_all_dirty(start, length, DIRTY_MEMORY_CODE)) {
         .                   ret |= (1 << DIRTY_MEMORY_CODE);
         .               }
 8,305,188 ( 0.01%)      if (mask & (1 << DIRTY_MEMORY_MIGRATION) &&
         .                   !cpu_physical_memory_all_dirty(start, length, DIRTY_MEMORY_MIGRATION)) {
         .                   ret |= (1 << DIRTY_MEMORY_MIGRATION);
         .               }
         .               return ret;
         .           }
         .           
         .           static inline void cpu_physical_memory_set_dirty_flag(ram_addr_t addr,
         .                                                                 unsigned client)
-- line 267 ----------------------------------------
-- line 286 ----------------------------------------
         .                                                                  ram_addr_t length,
         .                                                                  uint8_t mask)
         .           {
         .               DirtyMemoryBlocks *blocks[DIRTY_MEMORY_NUM];
         .               unsigned long end, page;
         .               unsigned long idx, offset, base;
         .               int i;
         .           
 8,963,508 ( 0.01%)      if (!mask && !xen_enabled()) {
         .                   return;
         .               }
         .           
 3,048,950 ( 0.00%)      end = TARGET_PAGE_ALIGN(start + length) >> TARGET_PAGE_BITS;
   457,475 ( 0.00%)      page = start >> TARGET_PAGE_BITS;
         .           
         .               WITH_RCU_READ_LOCK_GUARD() {
 3,439,475 ( 0.00%)          for (i = 0; i < DIRTY_MEMORY_NUM; i++) {
 1,573,290 ( 0.00%)              blocks[i] = qatomic_rcu_read(&ram_list.dirty_memory[i]);
         .                   }
         .           
   689,010 ( 0.00%)          idx = page / DIRTY_MEMORY_BLOCK_SIZE;
   524,430 ( 0.00%)          offset = page % DIRTY_MEMORY_BLOCK_SIZE;
   689,010 ( 0.00%)          base = page - offset;
 3,012,653 ( 0.00%)          while (page < end) {
 1,408,710 ( 0.00%)              unsigned long next = MIN(end, base + DIRTY_MEMORY_BLOCK_SIZE);
         .           
   329,160 ( 0.00%)              if (likely(mask & (1 << DIRTY_MEMORY_MIGRATION))) {
   390,555 ( 0.00%)                  bitmap_set_atomic(blocks[DIRTY_MEMORY_MIGRATION]->blocks[idx],
 2,929,488 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/bitmap.c:bitmap_set_atomic (97,630x)
   195,272 ( 0.00%)                                    offset, next - page);
         .                       }
   329,160 ( 0.00%)              if (unlikely(mask & (1 << DIRTY_MEMORY_VGA))) {
 1,048,880 ( 0.00%)                  bitmap_set_atomic(blocks[DIRTY_MEMORY_VGA]->blocks[idx],
 2,929,488 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/bitmap.c:bitmap_set_atomic (97,630x)
   329,160 ( 0.00%)                                    offset, next - page);
         .                       }
   329,160 ( 0.00%)              if (unlikely(mask & (1 << DIRTY_MEMORY_CODE))) {
        60 ( 0.00%)                  bitmap_set_atomic(blocks[DIRTY_MEMORY_CODE]->blocks[idx],
   393,444 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/bitmap.c:bitmap_set_atomic (6x)
         .                                             offset, next - page);
         .                       }
         .           
         .                       page = next;
   164,586 ( 0.00%)              idx++;
   262,216 ( 0.00%)              offset = 0;
         .                       base += DIRTY_MEMORY_BLOCK_SIZE;
         .                   }
         .               }
         .           
         .               xen_hvm_modified_memory(start, length);
         .           }
         .           
         .           #if !defined(_WIN32)
-- line 335 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c
--------------------------------------------------------------------------------
Ir                   

-- line 168 ----------------------------------------
          .               ram_addr_t start;
          .               ram_addr_t end;
          .               unsigned long dirty[];
          .           };
          .           
          .           static void phys_map_node_reserve(PhysPageMap *map, unsigned nodes)
          .           {
          .               static unsigned alloc_hint = 16;
        369 ( 0.00%)      if (map->nodes_nb + nodes > map->nodes_nb_alloc) {
        168 ( 0.00%)          map->nodes_nb_alloc = MAX(alloc_hint, map->nodes_nb + nodes);
        168 ( 0.00%)          map->nodes = g_renew(Node, map->nodes, map->nodes_nb_alloc);
     12,319 ( 0.00%)  => ???:0x0000000004e3c800 (42x)
         84 ( 0.00%)          alloc_hint = map->nodes_nb_alloc;
          .               }
          .           }
          .           
          .           static uint32_t phys_map_node_alloc(PhysPageMap *map, bool leaf)
          .           {
          .               unsigned i;
          .               uint32_t ret;
          .               PhysPageEntry e;
          .               PhysPageEntry *p;
          .           
      1,148 ( 0.00%)      ret = map->nodes_nb++;
        574 ( 0.00%)      p = map->nodes[ret];
        574 ( 0.00%)      assert(ret != PHYS_MAP_NODE_NIL);
        574 ( 0.00%)      assert(ret != map->nodes_nb_alloc);
          .           
        574 ( 0.00%)      e.skip = leaf ? 0 : 1;
      1,435 ( 0.00%)      e.ptr = leaf ? PHYS_SECTION_UNASSIGNED : PHYS_MAP_NODE_NIL;
    441,693 ( 0.00%)      for (i = 0; i < P_L2_SIZE; ++i) {
          .                   memcpy(&p[i], &e, sizeof(e));
          .               }
          .               return ret;
          .           }
          .           
          .           static void phys_page_set_level(PhysPageMap *map, PhysPageEntry *lp,
          .                                           hwaddr *index, uint64_t *nb, uint16_t leaf,
          .                                           int level)
      7,040 ( 0.00%)  {
          .               PhysPageEntry *p;
      2,112 ( 0.00%)      hwaddr step = (hwaddr)1 << (level * P_L2_BITS);
          .           
      4,928 ( 0.00%)      if (lp->skip && lp->ptr == PHYS_MAP_NODE_NIL) {
      2,296 ( 0.00%)          lp->ptr = phys_map_node_alloc(map, level == 0);
          .               }
      1,825 ( 0.00%)      p = map->nodes[lp->ptr];
      3,520 ( 0.00%)      lp = &p[(*index >> (level * P_L2_BITS)) & (P_L2_SIZE - 1)];
          .           
     32,296 ( 0.00%)      while (*nb && lp < &p[P_L2_SIZE]) {
     34,196 ( 0.00%)          if ((*index & (step - 1)) == 0 && *nb >= step) {
     18,603 ( 0.00%)              lp->skip = 0;
          .                       lp->ptr = leaf;
      6,201 ( 0.00%)              *index += step;
     18,603 ( 0.00%)              *nb -= step;
          .                   } else {
      5,352 ( 0.00%)              phys_page_set_level(map, lp, index, nb, leaf, level - 1);
    662,546 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:phys_page_set_level'2 (123x)
          .                   }
      6,782 ( 0.00%)          ++lp;
          .               }
      5,632 ( 0.00%)  }
          .           
          .           static void phys_page_set(AddressSpaceDispatch *d,
          .                                     hwaddr index, uint64_t nb,
          .                                     uint16_t leaf)
      1,107 ( 0.00%)  {
          .               /* Wildly overreserve - it doesn't matter much. */
      1,230 ( 0.00%)      phys_map_node_reserve(&d->map, 3 * P_L2_LEVELS);
          .           
        861 ( 0.00%)      phys_page_set_level(&d->map, &d->phys_map, &index, &nb, leaf, P_L2_LEVELS - 1);
    742,902 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:phys_page_set_level (123x)
        738 ( 0.00%)  }
          .           
          .           /* Compact a non leaf page entry. Simply detect that the entry has a single child,
          .            * and update our entry so we can skip it and go directly to the destination.
          .            */
          .           static void phys_page_compact(PhysPageEntry *lp, Node *nodes)
      2,870 ( 0.00%)  {
        287 ( 0.00%)      unsigned valid_ptr = P_L2_SIZE;
        287 ( 0.00%)      int valid = 0;
          .               PhysPageEntry *p;
          .               int i;
          .           
      1,440 ( 0.00%)      if (lp->ptr == PHYS_MAP_NODE_NIL) {
          .                   return;
          .               }
          .           
      1,148 ( 0.00%)      p = nodes[lp->ptr];
    588,063 ( 0.00%)      for (i = 0; i < P_L2_SIZE; i++) {
    587,776 ( 0.00%)          if (p[i].ptr == PHYS_MAP_NODE_NIL) {
          .                       continue;
          .                   }
          .           
     31,557 ( 0.00%)          valid_ptr = i;
     31,557 ( 0.00%)          valid++;
     63,114 ( 0.00%)          if (p[i].skip) {
      1,008 ( 0.00%)              phys_page_compact(&p[i], nodes);
  1,171,234 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:phys_page_compact'2 (35x)
          .                   }
          .               }
          .           
          .               /* We can only compress if there's only one child. */
        574 ( 0.00%)      if (valid != 1) {
          .                   return;
          .               }
          .           
        356 ( 0.00%)      assert(valid_ptr < P_L2_SIZE);
          .           
          .               /* Don't compress if it won't fit in the # of bits we have. */
      1,958 ( 0.00%)      if (P_L2_LEVELS >= (1 << 6) &&
        178 ( 0.00%)          lp->skip + p[valid_ptr].skip >= (1 << 6)) {
          .                   return;
          .               }
          .           
      1,068 ( 0.00%)      lp->ptr = p[valid_ptr].ptr;
        534 ( 0.00%)      if (!p[valid_ptr].skip) {
          .                   /* If our only child is a leaf, make this a leaf. */
          .                   /* By design, we should have made this node a leaf to begin with so we
          .                    * should never reach here.
          .                    * But since it's so simple to handle this, let's do it just in case we
          .                    * change this rule.
          .                    */
         27 ( 0.00%)          lp->skip = 0;
          .               } else {
        906 ( 0.00%)          lp->skip += p[valid_ptr].skip;
          .               }
      2,297 ( 0.00%)  }
          .           
          .           void address_space_dispatch_compact(AddressSpaceDispatch *d)
         36 ( 0.00%)  {
         72 ( 0.00%)      if (d->phys_map.skip) {
        108 ( 0.00%)          phys_page_compact(&d->phys_map, d->map.nodes);
  1,317,005 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:phys_page_compact (36x)
          .               }
          .           }
          .           
          .           static inline bool section_covers_addr(const MemoryRegionSection *section,
          .                                                  hwaddr addr)
          .           {
          .               /* Memory topology clips a memory region to [0, 2^64); size.hi > 0 means
          .                * the section must cover the entire address space.
          .                */
 30,024,442 ( 0.04%)      return int128_gethi(section->size) ||
 10,008,146 ( 0.01%)             range_covers_byte(section->offset_within_address_space,
          .                                        int128_getlo(section->size), addr);
          .           }
          .           
          .           static MemoryRegionSection *phys_page_find(AddressSpaceDispatch *d, hwaddr addr)
  1,364,512 ( 0.00%)  {
  3,411,280 ( 0.00%)      PhysPageEntry lp = d->phys_map, *p;
    682,256 ( 0.00%)      Node *nodes = d->map.nodes;
    682,256 ( 0.00%)      MemoryRegionSection *sections = d->map.sections;
  2,729,024 ( 0.00%)      hwaddr index = addr >> TARGET_PAGE_BITS;
          .               int i;
          .           
 20,020,146 ( 0.03%)      for (i = P_L2_LEVELS; lp.skip && (i -= lp.skip) >= 0;) {
  3,944,358 ( 0.01%)          if (lp.ptr == PHYS_MAP_NODE_NIL) {
          .                       return &sections[PHYS_SECTION_UNASSIGNED];
          .                   }
  1,972,179 ( 0.00%)          p = nodes[lp.ptr];
 19,721,790 ( 0.03%)          lp = p[(index >> (i * P_L2_BITS)) & (P_L2_SIZE - 1)];
          .               }
          .           
  1,364,512 ( 0.00%)      if (section_covers_addr(&sections[lp.ptr], addr)) {
          .                   return &sections[lp.ptr];
          .               } else {
          .                   return &sections[PHYS_SECTION_UNASSIGNED];
          .               }
  2,046,768 ( 0.00%)  }
          .           
          .           /* Called from RCU critical section */
          .           static MemoryRegionSection *address_space_lookup_region(AddressSpaceDispatch *d,
          .                                                                   hwaddr addr,
          .                                                                   bool resolve_subpage)
          .           {
  9,325,894 ( 0.01%)      MemoryRegionSection *section = qatomic_read(&d->mru_section);
          .               subpage_t *subpage;
          .           
 37,303,570 ( 0.05%)      if (!section || section == &d->map.sections[PHYS_SECTION_UNASSIGNED] ||
          .                   !section_covers_addr(section, addr)) {
  2,046,759 ( 0.00%)          section = phys_page_find(d, addr);
 64,078,926 ( 0.09%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:phys_page_find (682,253x)
    682,253 ( 0.00%)          qatomic_set(&d->mru_section, section);
          .               }
 46,274,780 ( 0.06%)      if (resolve_subpage && section->mr->subpage) {
          .                   subpage = container_of(section->mr, subpage_t, iomem);
  5,604,012 ( 0.01%)          section = &d->map.sections[subpage->sub_section[SUBPAGE_IDX(addr)]];
          .               }
          .               return section;
          .           }
          .           
          .           /* Called from RCU critical section */
          .           static MemoryRegionSection *
          .           address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
          .                                            hwaddr *plen, bool resolve_subpage)
 93,258,940 ( 0.13%)  {
          .               MemoryRegionSection *section;
          .               MemoryRegion *mr;
          .               Int128 diff;
          .           
          .               section = address_space_lookup_region(d, addr, resolve_subpage);
          .               /* Compute offset within MemoryRegionSection */
  9,325,894 ( 0.01%)      addr -= section->offset_within_address_space;
          .           
          .               /* Compute offset within MemoryRegion */
 27,977,682 ( 0.04%)      *xlat = addr + section->offset_within_region;
          .           
          .               mr = section->mr;
          .           
          .               /* MMIO registers can be expected to perform full-width accesses based only
          .                * on their address, without considering adjacent registers that could
          .                * decode to completely different MemoryRegions.  When such registers
          .                * exist (e.g. I/O ports 0xcf8 and 0xcf9 on most PC chipsets), MMIO
          .                * regions overlap wildly.  For this reason we cannot clamp the accesses
          .                * here.
          .                *
          .                * If the length is small (as is the case for address_space_ldl/stl),
          .                * everything works fine.  If the incoming length is large, however,
          .                * the caller really has to do the clamping through memory_access_size.
          .                */
 18,651,788 ( 0.03%)      if (memory_region_is_ram(mr)) {
          .                   diff = int128_sub(section->size, int128_make64(addr));
  8,684,619 ( 0.01%)          *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
          .               }
          .               return section;
 55,955,364 ( 0.08%)  }
          .           
          .           /**
          .            * address_space_translate_iommu - translate an address through an IOMMU
          .            * memory region and then through the target address space.
          .            *
          .            * @iommu_mr: the IOMMU memory region that we start the translation from
          .            * @addr: the address to be translated through the MMU
          .            * @xlat: the translated address offset within the destination memory region.
-- line 396 ----------------------------------------
-- line 475 ----------------------------------------
          .            *            would tell. It can be @NULL if we don't care about it.
          .            * @is_write: whether the translation operation is for write
          .            * @is_mmio: whether this can be MMIO, set true if it can
          .            * @target_as: the address space targeted by the IOMMU
          .            * @attrs: memory transaction attributes
          .            *
          .            * This function is called from RCU critical section
          .            */
174,945,616 ( 0.24%)  static MemoryRegionSection flatview_do_translate(FlatView *fv,
          .                                                            hwaddr addr,
          .                                                            hwaddr *xlat,
          .                                                            hwaddr *plen_out,
          .                                                            hwaddr *page_mask_out,
          .                                                            bool is_write,
          .                                                            bool is_mmio,
          .                                                            AddressSpace **target_as,
          .                                                            MemTxAttrs attrs)
          .           {
          .               MemoryRegionSection *section;
          .               IOMMUMemoryRegion *iommu_mr;
  9,207,664 ( 0.01%)      hwaddr plen = (hwaddr)(-1);
          .           
          .               if (!plen_out) {
 27,622,992 ( 0.04%)          plen_out = &plen;
          .               }
          .           
 46,038,320 ( 0.06%)      section = address_space_translate_internal(
582,802,304 ( 0.80%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:address_space_translate_internal (9,207,664x)
          .                       flatview_to_dispatch(fv), addr, xlat,
          .                       plen_out, is_mmio);
          .           
  9,207,664 ( 0.01%)      iommu_mr = memory_region_get_iommu(section->mr);
          .               if (unlikely(iommu_mr)) {
          .                   return address_space_translate_iommu(iommu_mr, xlat,
          .                                                        plen_out, page_mask_out,
          .                                                        is_write, is_mmio,
          .                                                        target_as, attrs);
          .               }
 18,415,328 ( 0.03%)      if (page_mask_out) {
          .                   /* Not behind an IOMMU, use default page size. */
          .                   *page_mask_out = ~TARGET_PAGE_MASK;
          .               }
          .           
 82,868,976 ( 0.11%)      return *section;
110,491,968 ( 0.15%)  }
          .           
          .           /* Called from RCU critical section */
          .           IOMMUTLBEntry address_space_get_iotlb_entry(AddressSpace *as, hwaddr addr,
          .                                                       bool is_write, MemTxAttrs attrs)
          .           {
          .               MemoryRegionSection section;
          .               hwaddr xlat, page_mask;
          .           
-- line 526 ----------------------------------------
-- line 553 ----------------------------------------
          .           iotlb_fail:
          .               return (IOMMUTLBEntry) {0};
          .           }
          .           
          .           /* Called from RCU critical section */
          .           MemoryRegion *flatview_translate(FlatView *fv, hwaddr addr, hwaddr *xlat,
          .                                            hwaddr *plen, bool is_write,
          .                                            MemTxAttrs attrs)
 73,661,312 ( 0.10%)  {
          .               MemoryRegion *mr;
          .               MemoryRegionSection section;
  9,207,664 ( 0.01%)      AddressSpace *as = NULL;
          .           
          .               /* This can be MMIO, so setup MMIO bit. */
119,699,632 ( 0.16%)      section = flatview_do_translate(fv, addr, xlat, plen, NULL,
1,126,054,480 ( 1.54%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:flatview_do_translate.isra.0 (9,207,664x)
          .                                               is_write, true, &as, attrs);
  9,207,664 ( 0.01%)      mr = section.mr;
          .           
          .               if (xen_enabled() && memory_access_is_direct(mr, is_write)) {
          .                   hwaddr page = ((addr & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE) - addr;
          .                   *plen = MIN(page, *plen);
          .               }
          .           
  9,207,664 ( 0.01%)      return mr;
 55,245,984 ( 0.08%)  }
          .           
          .           typedef struct TCGIOMMUNotifier {
          .               IOMMUNotifier n;
          .               MemoryRegion *mr;
          .               CPUState *cpu;
          .               int iommu_idx;
          .               bool active;
          .           } TCGIOMMUNotifier;
-- line 585 ----------------------------------------
-- line 658 ----------------------------------------
          .                   notifier = g_array_index(cpu->iommu_notifiers, TCGIOMMUNotifier *, i);
          .                   memory_region_unregister_iommu_notifier(notifier->mr, &notifier->n);
          .                   g_free(notifier);
          .               }
          .               g_array_free(cpu->iommu_notifiers, true);
          .           }
          .           
          .           void tcg_iommu_init_notifier_list(CPUState *cpu)
          3 ( 0.00%)  {
          5 ( 0.00%)      cpu->iommu_notifiers = g_array_new(false, true, sizeof(TCGIOMMUNotifier *));
        180 ( 0.00%)  => ???:0x0000000004e3bd60 (1x)
          2 ( 0.00%)  }
          .           
          .           /* Called from RCU critical section */
          .           MemoryRegionSection *
          .           address_space_translate_for_iotlb(CPUState *cpu, int asidx, hwaddr orig_addr,
          .                                             hwaddr *xlat, hwaddr *plen,
          .                                             MemTxAttrs attrs, int *prot)
  1,891,680 ( 0.00%)  {
          .               MemoryRegionSection *section;
          .               IOMMUMemoryRegion *iommu_mr;
          .               IOMMUMemoryRegionClass *imrc;
          .               IOMMUTLBEntry iotlb;
          .               int iommu_idx;
    118,230 ( 0.00%)      hwaddr addr = orig_addr;
          .               AddressSpaceDispatch *d =
    709,380 ( 0.00%)          qatomic_rcu_read(&cpu->cpu_ases[asidx].memory_dispatch);
          .           
          .               for (;;) {
    709,380 ( 0.00%)          section = address_space_translate_internal(d, addr, &addr, plen, false);
 10,856,747 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:address_space_translate_internal (118,230x)
          .           
    354,690 ( 0.00%)          iommu_mr = memory_region_get_iommu(section->mr);
          .                   if (!iommu_mr) {
          .                       break;
          .                   }
          .           
          .                   imrc = memory_region_get_iommu_class_nocheck(iommu_mr);
          .           
          .                   iommu_idx = imrc->attrs_to_index(iommu_mr, attrs);
          .                   tcg_register_iommu_notifier(cpu, iommu_mr, iommu_idx);
-- line 696 ----------------------------------------
-- line 714 ----------------------------------------
          .                   if (!*prot) {
          .                       goto translate_fail;
          .                   }
          .           
          .                   d = flatview_to_dispatch(address_space_to_flatview(iotlb.target_as));
          .               }
          .           
          .               assert(!memory_region_is_iommu(section->mr));
    354,690 ( 0.00%)      *xlat = addr;
          .               return section;
          .           
          .           translate_fail:
          .               /*
          .                * We should be given a page-aligned address -- certainly
          .                * tlb_set_page_with_attrs() does so.  The page offset of xlat
          .                * is used to index sections[], and PHYS_SECTION_UNASSIGNED = 0.
          .                * The page portion of xlat will be logged by memory_region_access_valid()
          .                * when this memory access is rejected, so use the original untranslated
          .                * physical address.
          .                */
          .               assert((orig_addr & ~TARGET_PAGE_MASK) == 0);
          .               *xlat = orig_addr;
          .               return &d->map.sections[PHYS_SECTION_UNASSIGNED];
  1,300,530 ( 0.00%)  }
          .           
          .           void cpu_address_space_init(CPUState *cpu, int asidx,
          .                                       const char *prefix, MemoryRegion *mr)
         10 ( 0.00%)  {
          .               CPUAddressSpace *newas;
          2 ( 0.00%)      AddressSpace *as = g_new0(AddressSpace, 1);
        267 ( 0.00%)  => ???:0x0000000004e3cc20 (1x)
          .               char *as_name;
          .           
          2 ( 0.00%)      assert(mr);
          7 ( 0.00%)      as_name = g_strdup_printf("%s-%d", prefix, cpu->cpu_index);
      1,212 ( 0.00%)  => ???:0x0000000004e3b7e0 (1x)
          4 ( 0.00%)      address_space_init(as, mr, as_name);
        726 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:address_space_init (1x)
          2 ( 0.00%)      g_free(as_name);
         95 ( 0.00%)  => ???:0x0000000004e3a950 (1x)
          .           
          .               /* Target code should have set num_ases before calling us */
          3 ( 0.00%)      assert(asidx < cpu->num_ases);
          .           
          2 ( 0.00%)      if (asidx == 0) {
          .                   /* address space 0 gets the convenience alias */
          2 ( 0.00%)          cpu->as = as;
          .               }
          .           
          .               /* KVM cannot currently support multiple address spaces. */
          .               assert(asidx == 0 || !kvm_enabled());
          .           
          3 ( 0.00%)      if (!cpu->cpu_ases) {
          4 ( 0.00%)          cpu->cpu_ases = g_new0(CPUAddressSpace, cpu->num_ases);
        278 ( 0.00%)  => ???:0x0000000004e3ca40 (1x)
          .               }
          .           
          3 ( 0.00%)      newas = &cpu->cpu_ases[asidx];
          1 ( 0.00%)      newas->cpu = cpu;
          1 ( 0.00%)      newas->as = as;
          3 ( 0.00%)      if (tcg_enabled()) {
          2 ( 0.00%)          newas->tcg_as_listener.log_global_after_sync = tcg_log_global_after_sync;
          2 ( 0.00%)          newas->tcg_as_listener.commit = tcg_commit;
          2 ( 0.00%)          newas->tcg_as_listener.name = "tcg";
          3 ( 0.00%)          memory_listener_register(&newas->tcg_as_listener, as);
     16,877 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_listener_register (1x)
          .               }
          5 ( 0.00%)  }
          .           
          .           AddressSpace *cpu_get_address_space(CPUState *cpu, int asidx)
  8,420,406 ( 0.01%)  {
          .               /* Return the AddressSpace corresponding to the specified index */
 50,522,436 ( 0.07%)      return cpu->cpu_ases[asidx].as;
  8,420,406 ( 0.01%)  }
          .           
          .           /* Add a watchpoint.  */
          .           int cpu_watchpoint_insert(CPUState *cpu, vaddr addr, vaddr len,
          .                                     int flags, CPUWatchpoint **watchpoint)
          .           {
          .               CPUWatchpoint *wp;
          .               vaddr in_page;
          .           
-- line 789 ----------------------------------------
-- line 841 ----------------------------------------
          .           
          .               tlb_flush_page(cpu, watchpoint->vaddr);
          .           
          .               g_free(watchpoint);
          .           }
          .           
          .           /* Remove all matching watchpoints.  */
          .           void cpu_watchpoint_remove_all(CPUState *cpu, int mask)
         12 ( 0.00%)  {
          .               CPUWatchpoint *wp, *next;
          .           
          8 ( 0.00%)      QTAILQ_FOREACH_SAFE(wp, &cpu->watchpoints, entry, next) {
          .                   if (wp->flags & mask) {
          .                       cpu_watchpoint_remove_by_ref(cpu, wp);
          .                   }
          .               }
          8 ( 0.00%)  }
          .           
          .           #ifdef CONFIG_TCG
          .           /* Return true if this watchpoint address matches the specified
          .            * access (ie the address range covered by the watchpoint overlaps
          .            * partially or completely with the address range covered by the
          .            * access).
          .            */
          .           static inline bool watchpoint_address_matches(CPUWatchpoint *wp,
-- line 865 ----------------------------------------
-- line 873 ----------------------------------------
          .               vaddr wpend = wp->vaddr + wp->len - 1;
          .               vaddr addrend = addr + len - 1;
          .           
          .               return !(addr > wpend || wp->vaddr > addrend);
          .           }
          .           
          .           /* Return flags for watchpoints that match addr + prot.  */
          .           int cpu_watchpoint_address_matches(CPUState *cpu, vaddr addr, vaddr len)
    118,230 ( 0.00%)  {
          .               CPUWatchpoint *wp;
    118,230 ( 0.00%)      int ret = 0;
          .           
    354,690 ( 0.00%)      QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {
          .                   if (watchpoint_address_matches(wp, addr, len)) {
          .                       ret |= wp->flags;
          .                   }
          .               }
          .               return ret;
    236,460 ( 0.00%)  }
          .           
          .           /* Generate a debug exception if a watchpoint has been hit.  */
          .           void cpu_check_watchpoint(CPUState *cpu, vaddr addr, vaddr len,
          .                                     MemTxAttrs attrs, int flags, uintptr_t ra)
          .           {
          .               CPUClass *cc = CPU_GET_CLASS(cpu);
          .               CPUWatchpoint *wp;
          .           
-- line 899 ----------------------------------------
-- line 968 ----------------------------------------
          .                   }
          .               }
          .           }
          .           
          .           #endif /* CONFIG_TCG */
          .           
          .           /* Called from RCU critical section */
          .           RAMBlock *qemu_get_ram_block(ram_addr_t addr)
    400,067 ( 0.00%)  {
          .               RAMBlock *block;
          .           
    800,134 ( 0.00%)      block = qatomic_rcu_read(&ram_list.mru_block);
  2,400,386 ( 0.00%)      if (block && addr - block->offset < block->max_length) {
          .                   return block;
          .               }
    899,991 ( 0.00%)      RAMBLOCK_FOREACH(block) {
  1,199,988 ( 0.00%)          if (addr - block->offset < block->max_length) {
          .                       goto found;
          .                   }
          .               }
          .           
          .               fprintf(stderr, "Bad ram offset %" PRIx64 "\n", (uint64_t)addr);
          .               abort();
          .           
          .           found:
-- line 992 ----------------------------------------
-- line 1001 ----------------------------------------
          .                *                                        mru_block = NULL;
          .                *                                        call_rcu(reclaim_ramblock, xxx);
          .                *                  rcu_read_unlock()
          .                *
          .                * qatomic_rcu_set is not needed here.  The block was already published
          .                * when it was placed into the list.  Here we're just making an extra
          .                * copy of the pointer.
          .                */
     99,999 ( 0.00%)      ram_list.mru_block = block;
     99,999 ( 0.00%)      return block;
    300,068 ( 0.00%)  }
          .           
          .           void tlb_reset_dirty_range_all(ram_addr_t start, ram_addr_t length)
    960,126 ( 0.00%)  {
          .               CPUState *cpu;
          .               ram_addr_t start1;
          .               RAMBlock *block;
          .               ram_addr_t end;
          .           
    480,063 ( 0.00%)      assert(tcg_enabled());
  1,600,210 ( 0.00%)      end = TARGET_PAGE_ALIGN(start + length);
    320,042 ( 0.00%)      start &= TARGET_PAGE_MASK;
          .           
          .               RCU_READ_LOCK_GUARD();
    480,063 ( 0.00%)      block = qemu_get_ram_block(start);
  3,640,078 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:qemu_get_ram_block (160,021x)
    640,084 ( 0.00%)      assert(block == qemu_get_ram_block(end - 1));
  1,600,210 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:qemu_get_ram_block (160,021x)
    160,021 ( 0.00%)      start1 = (uintptr_t)ramblock_ptr(block, start - block->offset);
  1,280,152 ( 0.00%)      CPU_FOREACH(cpu) {
    640,068 ( 0.00%)          tlb_reset_dirty(cpu, start1, length);
4,077,996,591 ( 5.59%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:tlb_reset_dirty (160,017x)
          .               }
    960,126 ( 0.00%)  }
          .           
          .           
          .           /* Note: start and end must be within the same ram block.  */
          .           bool cpu_physical_memory_test_and_clear_dirty(ram_addr_t start,
          .                                                         ram_addr_t length,
          .                                                         unsigned client)
        290 ( 0.00%)  {
          .               DirtyMemoryBlocks *blocks;
          .               unsigned long end, page, start_page;
         29 ( 0.00%)      bool dirty = false;
          .               RAMBlock *ramblock;
          .               uint64_t mr_offset, mr_size;
          .           
         58 ( 0.00%)      if (length == 0) {
          .                   return false;
          .               }
          .           
        377 ( 0.00%)      end = TARGET_PAGE_ALIGN(start + length) >> TARGET_PAGE_BITS;
         58 ( 0.00%)      start_page = start >> TARGET_PAGE_BITS;
          .               page = start_page;
          .           
          .               WITH_RCU_READ_LOCK_GUARD() {
        116 ( 0.00%)          blocks = qatomic_rcu_read(&ram_list.dirty_memory[client]);
        116 ( 0.00%)          ramblock = qemu_get_ram_block(start);
        392 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:qemu_get_ram_block (29x)
          .                   /* Range sanity check on the ramblock */
        203 ( 0.00%)          assert(start >= ramblock->offset &&
          .                          start + length <= ramblock->offset + ramblock->used_length);
          .           
        145 ( 0.00%)          while (page < end) {
         58 ( 0.00%)              unsigned long idx = page / DIRTY_MEMORY_BLOCK_SIZE;
         58 ( 0.00%)              unsigned long offset = page % DIRTY_MEMORY_BLOCK_SIZE;
        232 ( 0.00%)              unsigned long num = MIN(end - page,
          .                                               DIRTY_MEMORY_BLOCK_SIZE - offset);
          .           
        116 ( 0.00%)              dirty |= bitmap_test_and_clear_atomic(blocks->blocks[idx],
      1,329 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/bitmap.c:bitmap_test_and_clear_atomic (29x)
          .                                                             offset, num);
         29 ( 0.00%)              page += num;
          .                   }
          .           
        174 ( 0.00%)          mr_offset = (ram_addr_t)(start_page << TARGET_PAGE_BITS) - ramblock->offset;
        145 ( 0.00%)          mr_size = (end - start_page) << TARGET_PAGE_BITS;
         87 ( 0.00%)          memory_region_clear_dirty_bitmap(ramblock->mr, mr_offset, mr_size);
        950 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_clear_dirty_bitmap (29x)
          .               }
          .           
        174 ( 0.00%)      if (dirty && tcg_enabled()) {
        145 ( 0.00%)          tlb_reset_dirty_range_all(start, length);
    640,295 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:tlb_reset_dirty_range_all (29x)
          .               }
          .           
          .               return dirty;
        261 ( 0.00%)  }
          .           
          .           DirtyBitmapSnapshot *cpu_physical_memory_snapshot_and_clear_dirty
          .               (MemoryRegion *mr, hwaddr offset, hwaddr length, unsigned client)
  1,119,944 ( 0.00%)  {
          .               DirtyMemoryBlocks *blocks;
    319,984 ( 0.00%)      ram_addr_t start = memory_region_get_ram_addr(mr) + offset;
    479,976 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_get_ram_addr (79,996x)
    399,980 ( 0.00%)      unsigned long align = 1UL << (TARGET_PAGE_BITS + BITS_PER_LEVEL);
    319,984 ( 0.00%)      ram_addr_t first = QEMU_ALIGN_DOWN(start, align);
    319,984 ( 0.00%)      ram_addr_t last  = QEMU_ALIGN_UP(start + length, align);
          .               DirtyBitmapSnapshot *snap;
          .               unsigned long page, end, dest;
          .               
    239,988 ( 0.00%)      snap = g_malloc0(sizeof(*snap) +
 15,523,052 ( 0.02%)  => ???:0x0000000004e3cc20 (79,996x)
    319,984 ( 0.00%)                       ((last - first) >> (TARGET_PAGE_BITS + 3)));
     79,996 ( 0.00%)      snap->start = first;
     79,996 ( 0.00%)      snap->end   = last;
          .           
    159,992 ( 0.00%)      page = first >> TARGET_PAGE_BITS;
     79,996 ( 0.00%)      end  = last  >> TARGET_PAGE_BITS;
          .               dest = 0;
          .           
          .               WITH_RCU_READ_LOCK_GUARD() {
    239,988 ( 0.00%)          blocks = qatomic_rcu_read(&ram_list.dirty_memory[client]);
          .           
    319,984 ( 0.00%)          while (page < end) {
    159,992 ( 0.00%)              unsigned long idx = page / DIRTY_MEMORY_BLOCK_SIZE;
    159,992 ( 0.00%)              unsigned long offset = page % DIRTY_MEMORY_BLOCK_SIZE;
    559,972 ( 0.00%)              unsigned long num = MIN(end - page,
          .                                               DIRTY_MEMORY_BLOCK_SIZE - offset);
          .           
    159,992 ( 0.00%)              assert(QEMU_IS_ALIGNED(offset, (1 << BITS_PER_LEVEL)));
    239,988 ( 0.00%)              assert(QEMU_IS_ALIGNED(num,    (1 << BITS_PER_LEVEL)));
     79,996 ( 0.00%)              offset >>= BITS_PER_LEVEL;
          .           
    639,968 ( 0.00%)              bitmap_copy_and_clear_atomic(snap->dirty + dest,
  2,539,873 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/bitmap.c:bitmap_copy_and_clear_atomic (79,996x)
          .                                                    blocks->blocks[idx] + offset,
          .                                                    num);
     79,996 ( 0.00%)              page += num;
    239,988 ( 0.00%)              dest += num >> BITS_PER_LEVEL;
          .                   }
          .               }
          .           
    239,988 ( 0.00%)      if (tcg_enabled()) {
    239,988 ( 0.00%)          tlb_reset_dirty_range_all(start, length);
2,049,099,769 ( 2.81%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:tlb_reset_dirty_range_all (79,996x)
          .               }
          .           
    319,984 ( 0.00%)      memory_region_clear_dirty_bitmap(mr, offset, length);
  2,719,864 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_clear_dirty_bitmap (79,996x)
          .           
          .               return snap;
    719,964 ( 0.00%)  }
          .           
          .           bool cpu_physical_memory_snapshot_get_dirty(DirtyBitmapSnapshot *snap,
          .                                                       ram_addr_t start,
          .                                                       ram_addr_t length)
          .           {
          .               unsigned long page, end;
          .           
          .               assert(start >= snap->start);
-- line 1139 ----------------------------------------
-- line 1149 ----------------------------------------
          .                   page++;
          .               }
          .               return false;
          .           }
          .           
          .           /* Called from RCU critical section */
          .           hwaddr memory_region_section_get_iotlb(CPUState *cpu,
          .                                                  MemoryRegionSection *section)
     18,607 ( 0.00%)  {
          .               AddressSpaceDispatch *d = flatview_to_dispatch(section->fv);
     74,428 ( 0.00%)      return section - d->map.sections;
     18,607 ( 0.00%)  }
          .           
          .           static int subpage_register(subpage_t *mmio, uint32_t start, uint32_t end,
          .                                       uint16_t section);
          .           static subpage_t *subpage_init(FlatView *fv, hwaddr base);
          .           
          .           static uint16_t phys_section_add(PhysPageMap *map,
          .                                            MemoryRegionSection *section)
        648 ( 0.00%)  {
          .               /* The physical section number is ORed with a page-aligned
          .                * pointer to produce the iotlb entries.  Thus it should
          .                * never overflow into the page-aligned value.
          .                */
      1,134 ( 0.00%)      assert(map->sections_nb < TARGET_PAGE_SIZE);
          .           
        324 ( 0.00%)      if (map->sections_nb == map->sections_nb_alloc) {
        180 ( 0.00%)          map->sections_nb_alloc = MAX(map->sections_nb_alloc * 2, 16);
        306 ( 0.00%)          map->sections = g_renew(MemoryRegionSection, map->sections,
     10,111 ( 0.00%)  => ???:0x0000000004e3c800 (36x)
          .                                           map->sections_nb_alloc);
          .               }
      1,656 ( 0.00%)      map->sections[map->sections_nb] = *section;
        324 ( 0.00%)      memory_region_ref(section->mr);
      1,224 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_ref (162x)
        486 ( 0.00%)      return map->sections_nb++;
        648 ( 0.00%)  }
          .           
          .           static void phys_section_destroy(MemoryRegion *mr)
          .           {
        134 ( 0.00%)      bool have_sub_page = mr->subpage;
          .           
        268 ( 0.00%)      memory_region_unref(mr);
      1,050 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_unref (134x)
          .           
        268 ( 0.00%)      if (have_sub_page) {
          .                   subpage_t *subpage = container_of(mr, subpage_t, iomem);
          .                   object_unref(OBJECT(&subpage->iomem));
          .                   g_free(subpage);
          .               }
          .           }
          .           
          .           static void phys_sections_free(PhysPageMap *map)
          .           {
        498 ( 0.00%)      while (map->sections_nb > 0) {
        434 ( 0.00%)          MemoryRegionSection *section = &map->sections[--map->sections_nb];
        268 ( 0.00%)          phys_section_destroy(section->mr);
          .               }
         32 ( 0.00%)      g_free(map->sections);
      4,590 ( 0.00%)  => ???:0x0000000004e3a950 (32x)
         64 ( 0.00%)      g_free(map->nodes);
     10,761 ( 0.00%)  => ???:0x0000000004e3a950 (32x)
          .           }
          .           
          .           static void register_subpage(FlatView *fv, MemoryRegionSection *section)
         36 ( 0.00%)  {
          .               AddressSpaceDispatch *d = flatview_to_dispatch(fv);
          .               subpage_t *subpage;
          9 ( 0.00%)      hwaddr base = section->offset_within_address_space
          9 ( 0.00%)          & TARGET_PAGE_MASK;
          9 ( 0.00%)      MemoryRegionSection *existing = phys_page_find(d, base);
        454 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:phys_page_find (3x)
         15 ( 0.00%)      MemoryRegionSection subsection = {
          .                   .offset_within_address_space = base,
         12 ( 0.00%)          .size = int128_make64(TARGET_PAGE_SIZE),
          .               };
          .               hwaddr start, end;
          .           
         15 ( 0.00%)      assert(existing->mr->subpage || existing->mr == &io_mem_unassigned);
          .           
          .               if (!(existing->mr->subpage)) {
          .                   subpage = subpage_init(fv, base);
          1 ( 0.00%)          subsection.fv = fv;
          1 ( 0.00%)          subsection.mr = &subpage->iomem;
          9 ( 0.00%)          phys_page_set(d, base >> TARGET_PAGE_BITS, 1,
        404 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:phys_page_set (1x)
          3 ( 0.00%)                        phys_section_add(&d->map, &subsection));
         40 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:phys_section_add (1x)
          .               } else {
          .                   subpage = container_of(existing->mr, subpage_t, iomem);
          .               }
         16 ( 0.00%)      start = section->offset_within_address_space & ~TARGET_PAGE_MASK;
          9 ( 0.00%)      end = start + int128_get64(section->size) - 1;
          .               subpage_register(subpage, start, end,
          9 ( 0.00%)                       phys_section_add(&d->map, section));
        147 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:phys_section_add (3x)
         33 ( 0.00%)  }
          .           
          .           
          .           static void register_multipage(FlatView *fv,
          .                                          MemoryRegionSection *section)
          .           {
          .               AddressSpaceDispatch *d = flatview_to_dispatch(fv);
        122 ( 0.00%)      hwaddr start_addr = section->offset_within_address_space;
        366 ( 0.00%)      uint16_t section_index = phys_section_add(&d->map, section);
      4,943 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:phys_section_add (122x)
          .               uint64_t num_pages = int128_get64(int128_rshift(section->size,
        122 ( 0.00%)                                                      TARGET_PAGE_BITS));
          .           
        244 ( 0.00%)      assert(num_pages);
        732 ( 0.00%)      phys_page_set(d, start_addr >> TARGET_PAGE_BITS, num_pages, section_index);
    759,542 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:phys_page_set (122x)
          .           }
          .           
          .           /*
          .            * The range in *section* may look like this:
          .            *
          .            *      |s|PPPPPPP|s|
          .            *
          .            * where s stands for subpage and P for page.
          .            */
          .           void flatview_add_to_dispatch(FlatView *fv, MemoryRegionSection *section)
      1,240 ( 0.00%)  {
      1,240 ( 0.00%)      MemoryRegionSection remain = *section;
        620 ( 0.00%)      Int128 page_size = int128_make64(TARGET_PAGE_SIZE);
          .           
          .               /* register first subpage */
        620 ( 0.00%)      if (remain.offset_within_address_space & ~TARGET_PAGE_MASK) {
          6 ( 0.00%)          uint64_t left = TARGET_PAGE_ALIGN(remain.offset_within_address_space)
          .                                   - remain.offset_within_address_space;
          .           
          6 ( 0.00%)          MemoryRegionSection now = remain;
          4 ( 0.00%)          now.size = int128_min(int128_make64(left), now.size);
          6 ( 0.00%)          register_subpage(fv, &now);
      5,592 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:register_subpage (2x)
         20 ( 0.00%)          if (int128_eq(remain.size, now.size)) {
          .                       return;
          .                   }
          2 ( 0.00%)          remain.size = int128_sub(remain.size, now.size);
          1 ( 0.00%)          remain.offset_within_address_space += int128_get64(now.size);
          2 ( 0.00%)          remain.offset_within_region += int128_get64(now.size);
          .               }
          .           
          .               /* register whole pages */
        736 ( 0.00%)      if (int128_ge(remain.size, page_size)) {
        732 ( 0.00%)          MemoryRegionSection now = remain;
          .                   now.size = int128_and(now.size, int128_neg(page_size));
          .                   register_multipage(fv, &now);
      1,220 ( 0.00%)          if (int128_eq(remain.size, now.size)) {
          .                       return;
          .                   }
          .                   remain.size = int128_sub(remain.size, now.size);
          .                   remain.offset_within_address_space += int128_get64(now.size);
          .                   remain.offset_within_region += int128_get64(now.size);
          .               }
          .           
          .               /* register last subpage */
          3 ( 0.00%)      register_subpage(fv, &remain);
     10,337 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:register_subpage (1x)
      1,116 ( 0.00%)  }
          .           
          .           void qemu_flush_coalesced_mmio_buffer(void)
         18 ( 0.00%)  {
          .               if (kvm_enabled())
          .                   kvm_flush_coalesced_mmio_buffer();
         18 ( 0.00%)  }
          .           
          .           void qemu_mutex_lock_ramlist(void)
          5 ( 0.00%)  {
         30 ( 0.00%)      qemu_mutex_lock(&ram_list.mutex);
         10 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_mutex_lock_impl (5x)
          .           }
          .           
          .           void qemu_mutex_unlock_ramlist(void)
          5 ( 0.00%)  {
         20 ( 0.00%)      qemu_mutex_unlock(&ram_list.mutex);
         10 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_mutex_unlock_impl (5x)
          .           }
          .           
          .           GString *ram_block_format(void)
          .           {
          .               RAMBlock *block;
          .               char *psize;
          .               GString *buf = g_string_new("");
          .           
-- line 1318 ----------------------------------------
-- line 1607 ----------------------------------------
          .           
          .           /* Allocate space within the ram_addr_t space that governs the
          .            * dirty bitmaps.
          .            * Called with the ramlist lock held.
          .            */
          .           static ram_addr_t find_ram_offset(ram_addr_t size)
          .           {
          .               RAMBlock *block, *next_block;
          8 ( 0.00%)      ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;
          .           
         10 ( 0.00%)      assert(size != 0); /* it would hand out same offset multiple times */
          .           
         15 ( 0.00%)      if (QLIST_EMPTY_RCU(&ram_list.blocks)) {
          .                   return 0;
          .               }
          .           
         42 ( 0.00%)      RAMBLOCK_FOREACH(block) {
         10 ( 0.00%)          ram_addr_t candidate, next = RAM_ADDR_MAX;
          .           
          .                   /* Align blocks to start on a 'long' in the bitmap
          .                    * which makes the bitmap sync'ing take the fast path.
          .                    */
          .                   candidate = block->offset + block->max_length;
         68 ( 0.00%)          candidate = ROUND_UP(candidate, BITS_PER_LONG << TARGET_PAGE_BITS);
          .           
          .                   /* Search for the closest following block
          .                    * and find the gap.
          .                    */
        130 ( 0.00%)          RAMBLOCK_FOREACH(next_block) {
         30 ( 0.00%)              if (next_block->offset >= candidate) {
        150 ( 0.00%)                  next = MIN(next, next_block->offset);
          .                       }
          .                   }
          .           
          .                   /* If it fits remember our place and remember the size
          .                    * of gap, but keep going so that we might find a smaller
          .                    * gap to fill so avoiding fragmentation.
          .                    */
         80 ( 0.00%)          if (next - candidate >= size && next - candidate < mingap) {
          .                       offset = candidate;
          .                       mingap = next - candidate;
          .                   }
          .           
          .                   trace_find_ram_offset_loop(size, candidate, offset, next, mingap);
          .               }
          .           
          8 ( 0.00%)      if (offset == RAM_ADDR_MAX) {
          .                   fprintf(stderr, "Failed to find gap of requested size: %" PRIu64 "\n",
          .                           (uint64_t)size);
          .                   abort();
          .               }
          .           
          .               trace_find_ram_offset(size, offset);
          .           
          .               return offset;
          .           }
          .           
          .           static unsigned long last_ram_page(void)
          .           {
          .               RAMBlock *block;
          4 ( 0.00%)      ram_addr_t last = 0;
          .           
          .               RCU_READ_LOCK_GUARD();
         54 ( 0.00%)      RAMBLOCK_FOREACH(block) {
         40 ( 0.00%)          last = MAX(last, block->offset + block->max_length);
          .               }
         20 ( 0.00%)      return last >> TARGET_PAGE_BITS;
          .           }
          .           
          .           static void qemu_ram_setup_dump(void *addr, ram_addr_t size)
         25 ( 0.00%)  {
          .               int ret;
          .           
          .               /* Use MADV_DONTDUMP, if user doesn't want the guest memory in the core */
         25 ( 0.00%)      if (!machine_dump_guest_core(current_machine)) {
         15 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/machine.c:machine_dump_guest_core (5x)
          .                   ret = qemu_madvise(addr, size, QEMU_MADV_DONTDUMP);
          .                   if (ret) {
          .                       perror("qemu_madvise");
          .                       fprintf(stderr, "madvise doesn't support MADV_DONTDUMP, "
          .                                       "but dump_guest_core=off specified\n");
          .                   }
          .               }
         20 ( 0.00%)  }
          .           
          .           const char *qemu_ram_get_idstr(RAMBlock *rb)
          .           {
          .               return rb->idstr;
          .           }
          .           
          .           void *qemu_ram_get_host_addr(RAMBlock *rb)
          .           {
-- line 1697 ----------------------------------------
-- line 1709 ----------------------------------------
          .           }
          .           
          .           ram_addr_t qemu_ram_get_max_length(RAMBlock *rb)
          .           {
          .               return rb->max_length;
          .           }
          .           
          .           bool qemu_ram_is_shared(RAMBlock *rb)
          5 ( 0.00%)  {
         15 ( 0.00%)      return rb->flags & RAM_SHARED;
          5 ( 0.00%)  }
          .           
          .           bool qemu_ram_is_noreserve(RAMBlock *rb)
          5 ( 0.00%)  {
         10 ( 0.00%)      return rb->flags & RAM_NORESERVE;
          5 ( 0.00%)  }
          .           
          .           /* Note: Only set at the start of postcopy */
          .           bool qemu_ram_is_uf_zeroable(RAMBlock *rb)
          .           {
          .               return rb->flags & RAM_UF_ZEROPAGE;
          .           }
          .           
          .           void qemu_ram_set_uf_zeroable(RAMBlock *rb)
-- line 1732 ----------------------------------------
-- line 1735 ----------------------------------------
          .           }
          .           
          .           bool qemu_ram_is_migratable(RAMBlock *rb)
          .           {
          .               return rb->flags & RAM_MIGRATABLE;
          .           }
          .           
          .           void qemu_ram_set_migratable(RAMBlock *rb)
          5 ( 0.00%)  {
          5 ( 0.00%)      rb->flags |= RAM_MIGRATABLE;
          5 ( 0.00%)  }
          .           
          .           void qemu_ram_unset_migratable(RAMBlock *rb)
          .           {
          .               rb->flags &= ~RAM_MIGRATABLE;
          .           }
          .           
          .           int qemu_ram_get_fd(RAMBlock *rb)
          .           {
          .               return rb->fd;
          .           }
          .           
          .           /* Called with iothread lock held.  */
          .           void qemu_ram_set_idstr(RAMBlock *new_block, const char *name, DeviceState *dev)
         35 ( 0.00%)  {
          .               RAMBlock *block;
          .           
         10 ( 0.00%)      assert(new_block);
         20 ( 0.00%)      assert(!new_block->idstr[0]);
          .           
         10 ( 0.00%)      if (dev) {
          .                   char *id = qdev_get_dev_path(dev);
          .                   if (id) {
          5 ( 0.00%)              snprintf(new_block->idstr, sizeof(new_block->idstr), "%s/", id);
          .                       g_free(id);
          .                   }
          .               }
         20 ( 0.00%)      pstrcat(new_block->idstr, sizeof(new_block->idstr), name);
        576 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/cutils.c:pstrcat (5x)
          .           
          .               RCU_READ_LOCK_GUARD();
         70 ( 0.00%)      RAMBLOCK_FOREACH(block) {
         50 ( 0.00%)          if (block != new_block &&
         30 ( 0.00%)              !strcmp(block->idstr, new_block->idstr)) {
        230 ( 0.00%)  => ???:0x0000000004e3c5d0 (10x)
          .                       fprintf(stderr, "RAMBlock \"%s\" already registered, abort!\n",
          .                               new_block->idstr);
          .                       abort();
          .                   }
          .               }
         30 ( 0.00%)  }
          .           
          .           /* Called with iothread lock held.  */
          .           void qemu_ram_unset_idstr(RAMBlock *block)
          .           {
          .               /* FIXME: arch_init.c assumes that this is not called throughout
          .                * migration.  Ignore the problem since hot-unplug during migration
          .                * does not work anyway.
          .                */
-- line 1791 ----------------------------------------
-- line 1809 ----------------------------------------
          .                   largest = MAX(largest, qemu_ram_pagesize(block));
          .               }
          .           
          .               return largest;
          .           }
          .           
          .           static int memory_try_enable_merging(void *addr, size_t len)
          .           {
         25 ( 0.00%)      if (!machine_mem_merge(current_machine)) {
         15 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/machine.c:machine_mem_merge (5x)
          .                   /* disabled by the user */
          .                   return 0;
          .               }
          .           
         20 ( 0.00%)      return qemu_madvise(addr, len, QEMU_MADV_MERGEABLE);
         60 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/osdep.c:qemu_madvise (5x)
          .           }
          .           
          .           /*
          .            * Resizing RAM while migrating can result in the migration being canceled.
          .            * Care has to be taken if the guest might have already detected the memory.
          .            *
          .            * As memory core doesn't know how is memory accessed, it is up to
          .            * resize callback to update device state and/or add assertions to detect
-- line 1830 ----------------------------------------
-- line 1918 ----------------------------------------
          .                   }
          .               }
          .           }
          .           
          .           /* Called with ram_list.mutex held */
          .           static void dirty_memory_extend(ram_addr_t old_ram_size,
          .                                           ram_addr_t new_ram_size)
          .           {
         15 ( 0.00%)      ram_addr_t old_num_blocks = DIV_ROUND_UP(old_ram_size,
          .                                                        DIRTY_MEMORY_BLOCK_SIZE);
         10 ( 0.00%)      ram_addr_t new_num_blocks = DIV_ROUND_UP(new_ram_size,
          .                                                        DIRTY_MEMORY_BLOCK_SIZE);
          .               int i;
          .           
          .               /* Only need to extend if block count increased */
         10 ( 0.00%)      if (new_num_blocks <= old_num_blocks) {
          .                   return;
          .               }
          .           
         22 ( 0.00%)      for (i = 0; i < DIRTY_MEMORY_NUM; i++) {
          .                   DirtyMemoryBlocks *old_blocks;
          .                   DirtyMemoryBlocks *new_blocks;
          .                   int j;
          .           
         12 ( 0.00%)          old_blocks = qatomic_rcu_read(&ram_list.dirty_memory[i]);
         22 ( 0.00%)          new_blocks = g_malloc(sizeof(*new_blocks) +
        342 ( 0.00%)  => ???:0x0000000004e3b870 (6x)
          .                                         sizeof(new_blocks->blocks[0]) * new_num_blocks);
          .           
         12 ( 0.00%)          if (old_num_blocks) {
          8 ( 0.00%)              memcpy(new_blocks->blocks, old_blocks->blocks,
          .                              old_num_blocks * sizeof(old_blocks->blocks[0]));
          .                   }
          .           
         70 ( 0.00%)          for (j = old_num_blocks; j < new_num_blocks; j++) {
         18 ( 0.00%)              new_blocks->blocks[j] = bitmap_new(DIRTY_MEMORY_BLOCK_SIZE);
          .                   }
          .           
          6 ( 0.00%)          qatomic_rcu_set(&ram_list.dirty_memory[i], new_blocks);
          .           
         12 ( 0.00%)          if (old_blocks) {
         12 ( 0.00%)              g_free_rcu(old_blocks, rcu);
         61 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/rcu.c:call_rcu1 (3x)
          .                   }
          .               }
          .           }
          .           
          .           static void ram_block_add(RAMBlock *new_block, Error **errp)
         60 ( 0.00%)  {
         10 ( 0.00%)      const bool noreserve = qemu_ram_is_noreserve(new_block);
         20 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:qemu_ram_is_noreserve (5x)
         15 ( 0.00%)      const bool shared = qemu_ram_is_shared(new_block);
         25 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:qemu_ram_is_shared (5x)
          .               RAMBlock *block;
          .               RAMBlock *last_block = NULL;
          .               ram_addr_t old_ram_size, new_ram_size;
          .               Error *err = NULL;
          .           
          .               old_ram_size = last_ram_page();
          .           
          5 ( 0.00%)      qemu_mutex_lock_ramlist();
         45 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:qemu_mutex_lock_ramlist (5x)
         10 ( 0.00%)      new_block->offset = find_ram_offset(new_block->max_length);
          .           
         14 ( 0.00%)      if (!new_block->host) {
          .                   if (xen_enabled()) {
          .                       xen_ram_alloc(new_block->offset, new_block->max_length,
          .                                     new_block->mr, &err);
          .                       if (err) {
          .                           error_propagate(errp, err);
          .                           qemu_mutex_unlock_ramlist();
          .                           return;
          .                       }
          .                   } else {
         40 ( 0.00%)              new_block->host = qemu_anon_ram_alloc(new_block->max_length,
        890 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/oslib-posix.c:qemu_anon_ram_alloc (5x)
          .                                                             &new_block->mr->align,
          .                                                             shared, noreserve);
         10 ( 0.00%)              if (!new_block->host) {
          .                           error_setg_errno(errp, errno,
          .                                            "cannot set up guest memory '%s'",
          .                                            memory_region_name(new_block->mr));
          .                           qemu_mutex_unlock_ramlist();
          .                           return;
          .                       }
          5 ( 0.00%)              memory_try_enable_merging(new_block->host, new_block->max_length);
          .                   }
          .               }
          .           
         40 ( 0.00%)      new_ram_size = MAX(old_ram_size,
          .                         (new_block->offset + new_block->max_length) >> TARGET_PAGE_BITS);
         10 ( 0.00%)      if (new_ram_size > old_ram_size) {
          .                   dirty_memory_extend(old_ram_size, new_ram_size);
          .               }
          .               /* Keep the list sorted from biggest to smallest block.  Unlike QTAILQ,
          .                * QLIST (which has an RCU-friendly variant) does not have insertion at
          .                * tail, so save the last element in last_block.
          .                */
         54 ( 0.00%)      RAMBLOCK_FOREACH(block) {
          .                   last_block = block;
         30 ( 0.00%)          if (block->max_length < new_block->max_length) {
          .                       break;
          .                   }
          .               }
          .               if (block) {
         14 ( 0.00%)          QLIST_INSERT_BEFORE_RCU(block, new_block, next);
          .               } else if (last_block) {
         14 ( 0.00%)          QLIST_INSERT_AFTER_RCU(last_block, new_block, next);
          .               } else { /* list is empty */
          9 ( 0.00%)          QLIST_INSERT_HEAD_RCU(&ram_list.blocks, new_block, next);
          .               }
          5 ( 0.00%)      ram_list.mru_block = NULL;
          .           
          .               /* Write list before version */
          .               smp_wmb();
          5 ( 0.00%)      ram_list.version++;
          5 ( 0.00%)      qemu_mutex_unlock_ramlist();
         35 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:qemu_mutex_unlock_ramlist (5x)
          .           
          5 ( 0.00%)      cpu_physical_memory_set_dirty_range(new_block->offset,
          .                                                   new_block->used_length,
          .                                                   DIRTY_CLIENTS_ALL);
          .           
         15 ( 0.00%)      if (new_block->host) {
         10 ( 0.00%)          qemu_ram_setup_dump(new_block->host, new_block->max_length);
         85 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:qemu_ram_setup_dump (5x)
         20 ( 0.00%)          qemu_madvise(new_block->host, new_block->max_length, QEMU_MADV_HUGEPAGE);
         60 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/osdep.c:qemu_madvise (5x)
          .                   /*
          .                    * MADV_DONTFORK is also needed by KVM in absence of synchronous MMU
          .                    * Configure it unless the machine is a qtest server, in which case
          .                    * KVM is not used and it may be forked (eg for fuzzing purposes).
          .                    */
         10 ( 0.00%)          if (!qtest_enabled()) {
         25 ( 0.00%)              qemu_madvise(new_block->host, new_block->max_length,
         60 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/osdep.c:qemu_madvise (5x)
          .                                    QEMU_MADV_DONTFORK);
          .                   }
         35 ( 0.00%)          ram_block_notify_add(new_block->host, new_block->used_length,
        135 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/numa.c:ram_block_notify_add (5x)
          .                                        new_block->max_length);
          .               }
         35 ( 0.00%)  }
          .           
          .           #ifdef CONFIG_POSIX
          .           RAMBlock *qemu_ram_alloc_from_fd(ram_addr_t size, MemoryRegion *mr,
          .                                            uint32_t ram_flags, int fd, off_t offset,
          .                                            bool readonly, Error **errp)
          .           {
          .               RAMBlock *new_block;
          .               Error *local_err = NULL;
-- line 2057 ----------------------------------------
-- line 2141 ----------------------------------------
          .           
          .           static
          .           RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,
          .                                             void (*resized)(const char*,
          .                                                             uint64_t length,
          .                                                             void *host),
          .                                             void *host, uint32_t ram_flags,
          .                                             MemoryRegion *mr, Error **errp)
         70 ( 0.00%)  {
          .               RAMBlock *new_block;
          5 ( 0.00%)      Error *local_err = NULL;
          .           
         10 ( 0.00%)      assert((ram_flags & ~(RAM_SHARED | RAM_RESIZEABLE | RAM_PREALLOC |
          .                                     RAM_NORESERVE)) == 0);
         40 ( 0.00%)      assert(!host ^ (ram_flags & RAM_PREALLOC));
          .           
         35 ( 0.00%)      size = HOST_PAGE_ALIGN(size);
         10 ( 0.00%)      max_size = HOST_PAGE_ALIGN(max_size);
         20 ( 0.00%)      new_block = g_malloc0(sizeof(*new_block));
      1,465 ( 0.00%)  => ???:0x0000000004e3cc20 (5x)
         10 ( 0.00%)      new_block->mr = mr;
          5 ( 0.00%)      new_block->resized = resized;
          5 ( 0.00%)      new_block->used_length = size;
          5 ( 0.00%)      new_block->max_length = max_size;
         10 ( 0.00%)      assert(max_size >= size);
          5 ( 0.00%)      new_block->fd = -1;
          .               new_block->page_size = qemu_real_host_page_size();
          5 ( 0.00%)      new_block->host = host;
          5 ( 0.00%)      new_block->flags = ram_flags;
         15 ( 0.00%)      ram_block_add(new_block, &local_err);
  1,187,728 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:ram_block_add (5x)
         10 ( 0.00%)      if (local_err) {
          .                   g_free(new_block);
          .                   error_propagate(errp, local_err);
          .                   return NULL;
          .               }
          .               return new_block;
         60 ( 0.00%)  }
          .           
          .           RAMBlock *qemu_ram_alloc_from_ptr(ram_addr_t size, void *host,
          .                                              MemoryRegion *mr, Error **errp)
          .           {
          .               return qemu_ram_alloc_internal(size, size, NULL, host, RAM_PREALLOC, mr,
          .                                              errp);
          .           }
          .           
          .           RAMBlock *qemu_ram_alloc(ram_addr_t size, uint32_t ram_flags,
          .                                    MemoryRegion *mr, Error **errp)
         10 ( 0.00%)  {
         10 ( 0.00%)      assert((ram_flags & ~(RAM_SHARED | RAM_NORESERVE)) == 0);
         40 ( 0.00%)      return qemu_ram_alloc_internal(size, size, NULL, NULL, ram_flags, mr, errp);
  1,189,573 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:qemu_ram_alloc_internal (5x)
         10 ( 0.00%)  }
          .           
          .           RAMBlock *qemu_ram_alloc_resizeable(ram_addr_t size, ram_addr_t maxsz,
          .                                                void (*resized)(const char*,
          .                                                                uint64_t length,
          .                                                                void *host),
          .                                                MemoryRegion *mr, Error **errp)
          .           {
          .               return qemu_ram_alloc_internal(size, maxsz, resized, NULL,
-- line 2198 ----------------------------------------
-- line 2283 ----------------------------------------
          .           /* Return a host pointer to ram allocated with qemu_ram_alloc.
          .            * This should not be used for general purpose DMA.  Use address_space_map
          .            * or address_space_rw instead. For local memory (e.g. video ram) that the
          .            * device owns, use memory_region_get_ram_ptr.
          .            *
          .            * Called within RCU critical section.
          .            */
          .           void *qemu_map_ram_ptr(RAMBlock *ram_block, ram_addr_t addr)
 25,560,102 ( 0.04%)  {
          .               RAMBlock *block = ram_block;
          .           
 17,040,068 ( 0.02%)      if (block == NULL) {
          .                   block = qemu_get_ram_block(addr);
          .                   addr -= block->offset;
          .               }
          .           
          .               if (xen_enabled() && block->host == NULL) {
          .                   /* We need to check if the requested address is in the RAM
          .                    * because we don't want to map the entire memory in QEMU.
          .                    * In that case just map until the end of the page.
-- line 2302 ----------------------------------------
-- line 2303 ----------------------------------------
          .                    */
          .                   if (block->offset == 0) {
          .                       return xen_map_cache(addr, 0, 0, false);
          .                   }
          .           
          .                   block->host = xen_map_cache(block->offset, block->max_length, 1, false);
          .               }
          .               return ramblock_ptr(block, addr);
 17,040,068 ( 0.02%)  }
          .           
          .           /* Return a host pointer to guest's ram. Similar to qemu_map_ram_ptr
          .            * but takes a size argument.
          .            *
          .            * Called within RCU critical section.
          .            */
    493,752 ( 0.00%)  static void *qemu_ram_ptr_length(RAMBlock *ram_block, ram_addr_t addr,
          .                                            hwaddr *size, bool lock)
          .           {
          .               RAMBlock *block = ram_block;
    493,752 ( 0.00%)      if (*size == 0) {
          .                   return NULL;
          .               }
          .           
    329,168 ( 0.00%)      if (block == NULL) {
          .                   block = qemu_get_ram_block(addr);
          .                   addr -= block->offset;
          .               }
    822,920 ( 0.00%)      *size = MIN(*size, block->max_length - addr);
          .           
          .               if (xen_enabled() && block->host == NULL) {
          .                   /* We need to check if the requested address is in the RAM
          .                    * because we don't want to map the entire memory in QEMU.
          .                    * In that case just map the requested area.
          .                    */
          .                   if (block->offset == 0) {
          .                       return xen_map_cache(addr, *size, lock, lock);
          .                   }
          .           
          .                   block->host = xen_map_cache(block->offset, block->max_length, 1, lock);
          .               }
          .           
          .               return ramblock_ptr(block, addr);
    493,752 ( 0.00%)  }
          .           
          .           /* Return the offset of a hostpointer within a ramblock */
          .           ram_addr_t qemu_ram_block_host_offset(RAMBlock *rb, void *host)
          .           {
          .               ram_addr_t res = (uint8_t *)host - (uint8_t *)rb->host;
          .               assert((uintptr_t)host >= (uintptr_t)rb->host);
          .               assert(res < rb->max_length);
          .           
-- line 2353 ----------------------------------------
-- line 2368 ----------------------------------------
          .            * By the time this function returns, the returned pointer is not protected
          .            * by RCU anymore.  If the caller is not within an RCU critical section and
          .            * does not hold the iothread lock, it must have other means of protecting the
          .            * pointer, such as a reference to the region that includes the incoming
          .            * ram_addr_t.
          .            */
          .           RAMBlock *qemu_ram_block_from_host(void *ptr, bool round_offset,
          .                                              ram_addr_t *offset)
  5,267,041 ( 0.01%)  {
          .               RAMBlock *block;
          .               uint8_t *host = ptr;
          .           
          .               if (xen_enabled()) {
          .                   ram_addr_t ram_addr;
          .                   RCU_READ_LOCK_GUARD();
          .                   ram_addr = xen_ram_addr_from_mapcache(ptr);
          .                   block = qemu_get_ram_block(ram_addr);
          .                   if (block) {
          .                       *offset = ram_addr - block->offset;
          .                   }
          .                   return block;
          .               }
          .           
          .               RCU_READ_LOCK_GUARD();
 10,534,082 ( 0.01%)      block = qatomic_rcu_read(&ram_list.mru_block);
 47,403,369 ( 0.06%)      if (block && block->host && host - block->host < block->max_length) {
          .                   goto found;
          .               }
          .           
 36,860,572 ( 0.05%)      RAMBLOCK_FOREACH(block) {
          .                   /* This case append when the block is not mapped. */
 31,594,776 ( 0.04%)          if (block->host == NULL) {
          .                       continue;
          .                   }
 42,126,368 ( 0.06%)          if (host - block->host < block->max_length) {
          .                       goto found;
          .                   }
          .               }
          .           
          .               return NULL;
          .           
          .           found:
  5,267,041 ( 0.01%)      *offset = (host - block->host);
 10,534,082 ( 0.01%)      if (round_offset) {
          .                   *offset &= TARGET_PAGE_MASK;
          .               }
          .               return block;
  5,267,041 ( 0.01%)  }
          .           
          .           /*
          .            * Finds the named RAMBlock
          .            *
          .            * name: The name of RAMBlock to find
          .            *
          .            * Returns: RAMBlock (or NULL if not found)
          .            */
-- line 2423 ----------------------------------------
-- line 2432 ----------------------------------------
          .               }
          .           
          .               return NULL;
          .           }
          .           
          .           /* Some of the softmmu routines need to translate from a host pointer
          .              (typically a TLB entry) back to a ram offset.  */
          .           ram_addr_t qemu_ram_addr_from_host(void *ptr)
 26,335,205 ( 0.04%)  {
          .               RAMBlock *block;
          .               ram_addr_t offset;
          .           
 15,801,123 ( 0.02%)      block = qemu_ram_block_from_host(ptr, false, &offset);
194,854,372 ( 0.27%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:qemu_ram_block_from_host (5,267,041x)
 10,534,082 ( 0.01%)      if (!block) {
          .                   return RAM_ADDR_INVALID;
          .               }
          .           
 15,801,123 ( 0.02%)      return block->offset + offset;
 26,335,205 ( 0.04%)  }
          .           
          .           ram_addr_t qemu_ram_addr_from_host_nofail(void *ptr)
 15,801,123 ( 0.02%)  {
          .               ram_addr_t ram_addr;
          .           
  5,267,041 ( 0.01%)      ram_addr = qemu_ram_addr_from_host(ptr);
289,661,110 ( 0.40%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:qemu_ram_addr_from_host (5,267,041x)
 10,534,082 ( 0.01%)      if (ram_addr == RAM_ADDR_INVALID) {
          .                   error_report("Bad ram pointer %p", ptr);
          .                   abort();
          .               }
          .               return ram_addr;
 10,534,082 ( 0.01%)  }
          .           
          .           static MemTxResult flatview_read(FlatView *fv, hwaddr addr,
          .                                            MemTxAttrs attrs, void *buf, hwaddr len);
          .           static MemTxResult flatview_write(FlatView *fv, hwaddr addr, MemTxAttrs attrs,
          .                                             const void *buf, hwaddr len);
          .           static bool flatview_access_valid(FlatView *fv, hwaddr addr, hwaddr len,
          .                                             bool is_write, MemTxAttrs attrs);
          .           
          .           static MemTxResult subpage_read(void *opaque, hwaddr addr, uint64_t *data,
          .                                           unsigned len, MemTxAttrs attrs)
  2,183,240 ( 0.00%)  {
          .               subpage_t *subpage = opaque;
          .               uint8_t buf[8];
          .               MemTxResult res;
          .           
          .           #if defined(DEBUG_SUBPAGE)
          .               printf("%s: subpage %p len %u addr " TARGET_FMT_plx "\n", __func__,
          .                      subpage, len, addr);
          .           #endif
  1,091,620 ( 0.00%)      res = flatview_read(subpage->fv, addr + subpage->base, attrs, buf, len);
170,329,834 ( 0.23%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:flatview_read (218,324x)
    436,648 ( 0.00%)      if (res) {
          .                   return res;
          .               }
    218,324 ( 0.00%)      *data = ldn_p(buf, len);
    218,324 ( 0.00%)      return MEMTX_OK;
  1,528,268 ( 0.00%)  }
          .           
          .           static MemTxResult subpage_write(void *opaque, hwaddr addr,
          .                                            uint64_t value, unsigned len, MemTxAttrs attrs)
    744,080 ( 0.00%)  {
          .               subpage_t *subpage = opaque;
          .               uint8_t buf[8];
          .           
          .           #if defined(DEBUG_SUBPAGE)
          .               printf("%s: subpage %p len %u addr " TARGET_FMT_plx
          .                      " value %"PRIx64"\n",
          .                      __func__, subpage, len, addr, value);
          .           #endif
          .               stn_p(buf, len, value);
    558,060 ( 0.00%)      return flatview_write(subpage->fv, addr + subpage->base, attrs, buf, len);
 80,603,644 ( 0.11%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:flatview_write (93,010x)
    465,050 ( 0.00%)  }
          .           
          .           static bool subpage_accepts(void *opaque, hwaddr addr,
          .                                       unsigned len, bool is_write,
          .                                       MemTxAttrs attrs)
    311,334 ( 0.00%)  {
          .               subpage_t *subpage = opaque;
          .           #if defined(DEBUG_SUBPAGE)
          .               printf("%s: subpage %p %c len %u addr " TARGET_FMT_plx "\n",
          .                      __func__, subpage, is_write ? 'w' : 'r', len, addr);
          .           #endif
          .           
  1,556,670 ( 0.00%)      return flatview_access_valid(subpage->fv, addr + subpage->base,
101,254,773 ( 0.14%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:flatview_access_valid (311,334x)
          .                                            len, is_write, attrs);
          .           }
          .           
          .           static const MemoryRegionOps subpage_ops = {
          .               .read_with_attrs = subpage_read,
          .               .write_with_attrs = subpage_write,
          .               .impl.min_access_size = 1,
          .               .impl.max_access_size = 8,
-- line 2523 ----------------------------------------
-- line 2527 ----------------------------------------
          .               .endianness = DEVICE_NATIVE_ENDIAN,
          .           };
          .           
          .           static int subpage_register(subpage_t *mmio, uint32_t start, uint32_t end,
          .                                       uint16_t section)
          .           {
          .               int idx, eidx;
          .           
         18 ( 0.00%)      if (start >= TARGET_PAGE_SIZE || end >= TARGET_PAGE_SIZE)
          .                   return -1;
          6 ( 0.00%)      idx = SUBPAGE_IDX(start);
          6 ( 0.00%)      eidx = SUBPAGE_IDX(end);
          .           #if defined(DEBUG_SUBPAGE)
          .               printf("%s: %p start %08x end %08x idx %08x eidx %08x section %d\n",
          .                      __func__, mmio, start, end, idx, eidx, section);
          .           #endif
      3,081 ( 0.00%)      for (; idx <= eidx; idx++) {
      2,048 ( 0.00%)          mmio->sub_section[idx] = section;
          .               }
          .           
          .               return 0;
          .           }
          .           
          .           static subpage_t *subpage_init(FlatView *fv, hwaddr base)
          .           {
          .               subpage_t *mmio;
          .           
          .               /* mmio->sub_section is set to PHYS_SECTION_UNASSIGNED with g_malloc0 */
          4 ( 0.00%)      mmio = g_malloc0(sizeof(subpage_t) + TARGET_PAGE_SIZE * sizeof(uint16_t));
      2,614 ( 0.00%)  => ???:0x0000000004e3cc20 (1x)
          1 ( 0.00%)      mmio->fv = fv;
          1 ( 0.00%)      mmio->base = base;
          7 ( 0.00%)      memory_region_init_io(&mmio->iomem, NULL, &subpage_ops, mmio,
      6,896 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_init_io (1x)
          .                                     NULL, TARGET_PAGE_SIZE);
          1 ( 0.00%)      mmio->iomem.subpage = true;
          .           #if defined(DEBUG_SUBPAGE)
          .               printf("%s: %p base " TARGET_FMT_plx " len %08x\n", __func__,
          .                      mmio, base, TARGET_PAGE_SIZE);
          .           #endif
          .           
          .               return mmio;
          .           }
          .           
          .           static uint16_t dummy_section(PhysPageMap *map, FlatView *fv, MemoryRegion *mr)
          .           {
         72 ( 0.00%)      assert(fv);
        360 ( 0.00%)      MemoryRegionSection section = {
          .                   .fv = fv,
          .                   .mr = mr,
          .                   .offset_within_address_space = 0,
          .                   .offset_within_region = 0,
          .                   .size = int128_2_64(),
          .               };
          .           
         72 ( 0.00%)      return phys_section_add(map, &section);
     11,911 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:phys_section_add (36x)
          .           }
          .           
          .           MemoryRegionSection *iotlb_to_section(CPUState *cpu,
          .                                                 hwaddr index, MemTxAttrs attrs)
 22,488,277 ( 0.03%)  {
  3,212,611 ( 0.00%)      int asidx = cpu_asidx_from_attrs(cpu, attrs);
 64,252,220 ( 0.09%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/cpu-sysemu.c:cpu_asidx_from_attrs (3,212,611x)
  3,212,611 ( 0.00%)      CPUAddressSpace *cpuas = &cpu->cpu_ases[asidx];
 16,063,055 ( 0.02%)      AddressSpaceDispatch *d = qatomic_rcu_read(&cpuas->memory_dispatch);
          .               MemoryRegionSection *sections = d->map.sections;
          .           
 22,488,277 ( 0.03%)      return &sections[index & ~TARGET_PAGE_MASK];
 12,850,444 ( 0.02%)  }
          .           
          .           static void io_mem_init(void)
          .           {
          7 ( 0.00%)      memory_region_init_io(&io_mem_unassigned, NULL, &unassigned_mem_ops, NULL,
      6,681 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_init_io (1x)
          .                                     NULL, UINT64_MAX);
          .           }
          .           
          .           AddressSpaceDispatch *address_space_dispatch_new(FlatView *fv)
        288 ( 0.00%)  {
         72 ( 0.00%)      AddressSpaceDispatch *d = g_new0(AddressSpaceDispatch, 1);
      9,485 ( 0.00%)  => ???:0x0000000004e3cc20 (36x)
          .               uint16_t n;
          .           
          .               n = dummy_section(&d->map, fv, &io_mem_unassigned);
         72 ( 0.00%)      assert(n == PHYS_SECTION_UNASSIGNED);
          .           
         36 ( 0.00%)      d->phys_map  = (PhysPageEntry) { .ptr = PHYS_MAP_NODE_NIL, .skip = 1 };
          .           
          .               return d;
        288 ( 0.00%)  }
          .           
          .           void address_space_dispatch_free(AddressSpaceDispatch *d)
        192 ( 0.00%)  {
          .               phys_sections_free(&d->map);
         64 ( 0.00%)      g_free(d);
      3,816 ( 0.00%)  => ???:0x0000000004e3a950 (32x)
         96 ( 0.00%)  }
          .           
          .           static void do_nothing(CPUState *cpu, run_on_cpu_data d)
     79,996 ( 0.00%)  {
     79,996 ( 0.00%)  }
          .           
          .           static void tcg_log_global_after_sync(MemoryListener *listener)
     79,996 ( 0.00%)  {
          .               CPUAddressSpace *cpuas;
          .           
          .               /* Wait for the CPU to end the current TB.  This avoids the following
          .                * incorrect race:
          .                *
          .                *      vCPU                         migration
          .                *      ----------------------       -------------------------
          .                *      TLB check -> slow path
-- line 2632 ----------------------------------------
-- line 2636 ----------------------------------------
          .                *                                   clear dirty flag
          .                *      TLB check -> fast path
          .                *                                   read memory
          .                *        write to RAM
          .                *
          .                * by pushing the migration thread's memory read after the vCPU thread has
          .                * written the memory.
          .                */
    319,984 ( 0.00%)      if (replay_mode == REPLAY_MODE_NONE) {
          .                   /*
          .                    * VGA can make calls to this function while updating the screen.
          .                    * In record/replay mode this causes a deadlock, because
          .                    * run_on_cpu waits for rr mutex. Therefore no races are possible
          .                    * in this case and no need for making run_on_cpu when
          .                    * record/replay is enabled.
          .                    */
          .                   cpuas = container_of(listener, CPUAddressSpace, tcg_as_listener);
    319,984 ( 0.00%)          run_on_cpu(cpuas->cpu, do_nothing, RUN_ON_CPU_NULL);
  4,079,796 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:run_on_cpu (79,996x)
          .               }
          .           }
          .           
          .           static void tcg_commit(MemoryListener *listener)
          8 ( 0.00%)  {
          .               CPUAddressSpace *cpuas;
          .               AddressSpaceDispatch *d;
          .           
         16 ( 0.00%)      assert(tcg_enabled());
          .               /* since each CPU stores ram addresses in its TLB cache, we must
          .                  reset the modified entries */
          .               cpuas = container_of(listener, CPUAddressSpace, tcg_as_listener);
          4 ( 0.00%)      cpu_reloading_memory_map();
        104 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cpu-exec-common.c:cpu_reloading_memory_map (4x)
          .               /* The CPU and TLB are protected by the iothread lock.
          .                * We reload the dispatch pointer now because cpu_reloading_memory_map()
          .                * may have split the RCU critical section.
          .                */
          .               d = address_space_to_dispatch(cpuas->as);
          8 ( 0.00%)      qatomic_rcu_set(&cpuas->memory_dispatch, d);
          8 ( 0.00%)      tlb_flush(cpuas->cpu);
     66,161 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:tlb_flush (4x)
          4 ( 0.00%)  }
          .           
          .           static void memory_map_init(void)
          .           {
          4 ( 0.00%)      system_memory = g_malloc(sizeof(*system_memory));
        213 ( 0.00%)  => ???:0x0000000004e3b870 (1x)
          .           
          4 ( 0.00%)      memory_region_init(system_memory, NULL, "system", UINT64_MAX);
     17,501 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_init (1x)
          4 ( 0.00%)      address_space_init(&address_space_memory, system_memory, "memory");
      2,370 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:address_space_init (1x)
          .           
          4 ( 0.00%)      system_io = g_malloc(sizeof(*system_io));
        213 ( 0.00%)  => ???:0x0000000004e3b870 (1x)
          6 ( 0.00%)      memory_region_init_io(system_io, NULL, &unassigned_io_ops, NULL, "io",
     14,979 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_init_io (1x)
          .                                     65536);
          4 ( 0.00%)      address_space_init(&address_space_io, system_io, "I/O");
     43,486 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:address_space_init (1x)
          .           }
          .           
          .           MemoryRegion *get_system_memory(void)
          3 ( 0.00%)  {
          .               return system_memory;
          6 ( 0.00%)  }
          .           
          .           MemoryRegion *get_system_io(void)
          1 ( 0.00%)  {
          .               return system_io;
          2 ( 0.00%)  }
          .           
          .           static void invalidate_and_set_dirty(MemoryRegion *mr, hwaddr addr,
          .                                                hwaddr length)
 53,983,722 ( 0.07%)  {
  8,305,188 ( 0.01%)      uint8_t dirty_log_mask = memory_region_get_dirty_log_mask(mr);
 99,662,256 ( 0.14%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_get_dirty_log_mask (4,152,594x)
 12,457,782 ( 0.02%)      addr += memory_region_get_ram_addr(mr);
 24,915,564 ( 0.03%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_get_ram_addr (4,152,594x)
          .           
          .               /* No early return if dirty_log_mask is or becomes 0, because
          .                * cpu_physical_memory_set_dirty_range will still call
          .                * xen_modified_memory.
          .                */
  8,305,188 ( 0.01%)      if (dirty_log_mask) {
          .                   dirty_log_mask =
          .                       cpu_physical_memory_range_includes_clean(addr, length, dirty_log_mask);
          .               }
  8,305,188 ( 0.01%)      if (dirty_log_mask & (1 << DIRTY_MEMORY_CODE)) {
          .                   assert(tcg_enabled());
          .                   tb_invalidate_phys_range(addr, addr + length);
          .                   dirty_log_mask &= ~(1 << DIRTY_MEMORY_CODE);
          .               }
          .               cpu_physical_memory_set_dirty_range(addr, length, dirty_log_mask);
 45,678,534 ( 0.06%)  }
          .           
          .           void memory_region_flush_rom_device(MemoryRegion *mr, hwaddr addr, hwaddr size)
          .           {
          .               /*
          .                * In principle this function would work on other memory region types too,
          .                * but the ROM device use case is the only one where this operation is
          .                * necessary.  Other memory regions should use the
          .                * address_space_read/write() APIs.
          .                */
          .               assert(memory_region_is_romd(mr));
          .           
          .               invalidate_and_set_dirty(mr, addr, size);
          .           }
          .           
          .           int memory_access_size(MemoryRegion *mr, unsigned l, hwaddr addr)
    622,668 ( 0.00%)  {
  1,245,336 ( 0.00%)      unsigned access_size_max = mr->ops->valid.max_access_size;
          .           
          .               /* Regions are assumed to support 1-4 byte accesses unless
          .                  otherwise specified.  */
          .               if (access_size_max == 0) {
  1,868,004 ( 0.00%)          access_size_max = 4;
          .               }
          .           
          .               /* Bound the maximum access by the alignment of the address.  */
  1,245,336 ( 0.00%)      if (!mr->ops->impl.unaligned) {
  1,245,336 ( 0.00%)          unsigned align_size_max = addr & -addr;
  2,016,820 ( 0.00%)          if (align_size_max != 0 && align_size_max < access_size_max) {
          .                       access_size_max = align_size_max;
          .                   }
          .               }
          .           
          .               /* Don't attempt accesses larger than the maximum.  */
          .               if (l > access_size_max) {
          .                   l = access_size_max;
          .               }
  2,490,672 ( 0.00%)      l = pow2floor(l);
          .           
  1,245,336 ( 0.00%)      return l;
    622,668 ( 0.00%)  }
          .           
          .           bool prepare_mmio_access(MemoryRegion *mr)
  1,868,004 ( 0.00%)  {
          .               bool release_lock = false;
          .           
    934,002 ( 0.00%)      if (!qemu_mutex_iothread_locked()) {
  6,849,348 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:qemu_mutex_iothread_locked (311,334x)
          .                   qemu_mutex_lock_iothread();
          .                   release_lock = true;
          .               }
    622,668 ( 0.00%)      if (mr->flush_coalesced_mmio) {
          .                   qemu_flush_coalesced_mmio_buffer();
          .               }
          .           
          .               return release_lock;
  1,556,670 ( 0.00%)  }
          .           
          .           /**
          .            * flatview_access_allowed
          .            * @mr: #MemoryRegion to be accessed
          .            * @attrs: memory transaction attributes
          .            * @addr: address within that memory region
          .            * @len: the number of bytes to access
          .            *
          .            * Check if a memory transaction is allowed.
          .            *
          .            * Returns: true if transaction is allowed, false if denied.
          .            */
          .           static bool flatview_access_allowed(MemoryRegion *mr, MemTxAttrs attrs,
          .                                               hwaddr addr, hwaddr len)
          .           {
  3,589,016 ( 0.00%)      if (likely(!attrs.memory)) {
          .                   return true;
          .               }
          .               if (memory_region_is_ram(mr)) {
          .                   return true;
          .               }
          .               qemu_log_mask(LOG_GUEST_ERROR,
          .                             "Invalid access to non-RAM device at "
          .                             "addr 0x%" HWADDR_PRIX ", size %" HWADDR_PRIu ", "
-- line 2798 ----------------------------------------
-- line 2801 ----------------------------------------
          .           }
          .           
          .           /* Called within RCU critical section.  */
          .           static MemTxResult flatview_write_continue(FlatView *fv, hwaddr addr,
          .                                                      MemTxAttrs attrs,
          .                                                      const void *ptr,
          .                                                      hwaddr len, hwaddr addr1,
          .                                                      hwaddr l, MemoryRegion *mr)
  3,606,260 ( 0.00%)  {
          .               uint8_t *ram_ptr;
          .               uint64_t val;
    257,590 ( 0.00%)      MemTxResult result = MEMTX_OK;
          .               bool release_lock = false;
          .               const uint8_t *buf = ptr;
          .           
          .               for (;;) {
          .                   if (!flatview_access_allowed(mr, attrs, addr1, l)) {
          .                       result |= MEMTX_ACCESS_ERROR;
          .                       /* Keep going. */
          .                   } else if (!memory_access_is_direct(mr, true)) {
    279,030 ( 0.00%)              release_lock |= prepare_mmio_access(mr);
  3,534,380 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:prepare_mmio_access (93,010x)
    558,060 ( 0.00%)              l = memory_access_size(mr, l, addr1);
  2,250,842 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:memory_access_size (93,010x)
          .                       /* XXX: could force current_cpu to NULL to avoid
          .                          potential bugs */
          .                       val = ldn_he_p(buf, l);
    465,050 ( 0.00%)              result |= memory_region_dispatch_write(mr, addr1, val,
 52,310,002 ( 0.07%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_dispatch_write'2 (93,010x)
          .                                                              size_memop(l), attrs);
          .                   } else {
          .                       /* RAM case */
    822,900 ( 0.00%)              ram_ptr = qemu_ram_ptr_length(mr->ram_block, addr1, &l, false);
  3,620,760 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:qemu_ram_ptr_length.constprop.0 (164,580x)
          .                       memcpy(ram_ptr, buf, l);
    658,320 ( 0.00%)              invalidate_and_set_dirty(mr, addr1, l);
 53,159,347 ( 0.07%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:invalidate_and_set_dirty (164,580x)
          .                   }
          .           
    350,600 ( 0.00%)          if (release_lock) {
          .                       qemu_mutex_unlock_iothread();
          .                       release_lock = false;
          .                   }
          .           
          .                   len -= l;
    257,590 ( 0.00%)          buf += l;
    257,590 ( 0.00%)          addr += l;
          .           
    515,180 ( 0.00%)          if (!len) {
          .                       break;
          .                   }
          .           
          .                   l = len;
          .                   mr = flatview_translate(fv, addr, &addr1, &l, true, attrs);
          .               }
          .           
          .               return result;
  2,318,310 ( 0.00%)  }
          .           
          .           /* Called from RCU critical section.  */
          .           static MemTxResult flatview_write(FlatView *fv, hwaddr addr, MemTxAttrs attrs,
          .                                             const void *buf, hwaddr len)
  3,606,260 ( 0.00%)  {
          .               hwaddr l;
          .               hwaddr addr1;
          .               MemoryRegion *mr;
          .           
    257,590 ( 0.00%)      l = len;
  1,287,950 ( 0.00%)      mr = flatview_translate(fv, addr, &addr1, &l, true, attrs);
 40,188,560 ( 0.06%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:flatview_translate (257,590x)
          .               if (!flatview_access_allowed(mr, attrs, addr, len)) {
          .                   return MEMTX_ACCESS_ERROR;
          .               }
  2,833,490 ( 0.00%)      return flatview_write_continue(fv, addr, attrs, buf, len,
151,331,280 ( 0.21%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:flatview_write_continue (257,590x)
          .                                              addr1, l, mr);
  2,575,900 ( 0.00%)  }
          .           
          .           /* Called within RCU critical section.  */
          .           MemTxResult flatview_read_continue(FlatView *fv, hwaddr addr,
          .                                              MemTxAttrs attrs, void *ptr,
          .                                              hwaddr len, hwaddr addr1, hwaddr l,
          .                                              MemoryRegion *mr)
  3,929,904 ( 0.01%)  {
          .               uint8_t *ram_ptr;
          .               uint64_t val;
    218,328 ( 0.00%)      MemTxResult result = MEMTX_OK;
          .               bool release_lock = false;
          .               uint8_t *buf = ptr;
          .           
          .               fuzz_dma_read_cb(addr, len, mr);
          .               for (;;) {
          .                   if (!flatview_access_allowed(mr, attrs, addr1, l)) {
          .                       result |= MEMTX_ACCESS_ERROR;
          .                       /* Keep going. */
          .                   } else if (!memory_access_is_direct(mr, false)) {
          .                       /* I/O case */
    654,972 ( 0.00%)              release_lock |= prepare_mmio_access(mr);
  8,296,312 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:prepare_mmio_access (218,324x)
  1,528,268 ( 0.00%)              l = memory_access_size(mr, l, addr1);
  5,058,656 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:memory_access_size (218,324x)
  1,309,944 ( 0.00%)              result |= memory_region_dispatch_read(mr, addr1, &val,
100,647,274 ( 0.14%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_dispatch_read'2 (218,324x)
          .                                                             size_memop(l), attrs);
    654,972 ( 0.00%)              stn_he_p(buf, l, val);
          .                   } else {
          .                       /* RAM case */
         20 ( 0.00%)              ram_ptr = qemu_ram_ptr_length(mr->ram_block, addr1, &l, false);
         88 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:qemu_ram_ptr_length.constprop.0 (4x)
          4 ( 0.00%)              memcpy(buf, ram_ptr, l);
          .                   }
          .           
    436,648 ( 0.00%)          if (release_lock) {
          .                       qemu_mutex_unlock_iothread();
          .                       release_lock = false;
          .                   }
          .           
          .                   len -= l;
    218,328 ( 0.00%)          buf += l;
    218,328 ( 0.00%)          addr += l;
          .           
    436,656 ( 0.00%)          if (!len) {
          .                       break;
          .                   }
          .           
          .                   l = len;
          .                   mr = flatview_translate(fv, addr, &addr1, &l, false, attrs);
          .               }
          .           
          .               return result;
  2,619,936 ( 0.00%)  }
          .           
          .           /* Called from RCU critical section.  */
          .           static MemTxResult flatview_read(FlatView *fv, hwaddr addr,
          .                                            MemTxAttrs attrs, void *buf, hwaddr len)
  3,056,592 ( 0.00%)  {
          .               hwaddr l;
          .               hwaddr addr1;
          .               MemoryRegion *mr;
          .           
    218,328 ( 0.00%)      l = len;
  1,091,640 ( 0.00%)      mr = flatview_translate(fv, addr, &addr1, &l, false, attrs);
 30,566,228 ( 0.04%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:flatview_translate (218,328x)
          .               if (!flatview_access_allowed(mr, attrs, addr, len)) {
          .                   return MEMTX_ACCESS_ERROR;
          .               }
  2,401,608 ( 0.00%)      return flatview_read_continue(fv, addr, attrs, buf, len,
131,196,002 ( 0.18%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:flatview_read_continue (218,328x)
          .                                             addr1, l, mr);
  2,183,280 ( 0.00%)  }
          .           
          .           MemTxResult address_space_read_full(AddressSpace *as, hwaddr addr,
          .                                               MemTxAttrs attrs, void *buf, hwaddr len)
          4 ( 0.00%)  {
          .               MemTxResult result = MEMTX_OK;
          .               FlatView *fv;
          .           
          8 ( 0.00%)      if (len > 0) {
          .                   RCU_READ_LOCK_GUARD();
          .                   fv = address_space_to_flatview(as);
          4 ( 0.00%)          result = flatview_read(fv, addr, attrs, buf, len);
    820,500 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:flatview_read (4x)
          .               }
          .           
          .               return result;
          .           }
          .           
          .           MemTxResult address_space_write(AddressSpace *as, hwaddr addr,
          .                                           MemTxAttrs attrs,
          .                                           const void *buf, hwaddr len)
    164,580 ( 0.00%)  {
          .               MemTxResult result = MEMTX_OK;
          .               FlatView *fv;
          .           
    329,160 ( 0.00%)      if (len > 0) {
          .                   RCU_READ_LOCK_GUARD();
          .                   fv = address_space_to_flatview(as);
    164,580 ( 0.00%)          result = flatview_write(fv, addr, attrs, buf, len);
121,992,566 ( 0.17%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:flatview_write (164,580x)
          .               }
          .           
          .               return result;
          .           }
          .           
          .           MemTxResult address_space_rw(AddressSpace *as, hwaddr addr, MemTxAttrs attrs,
          .                                        void *buf, hwaddr len, bool is_write)
          .           {
-- line 2972 ----------------------------------------
-- line 3120 ----------------------------------------
          .               QLIST_INSERT_HEAD(&map_client_list, client, link);
          .               if (!qatomic_read(&bounce.in_use)) {
          .                   cpu_notify_map_clients_locked();
          .               }
          .               qemu_mutex_unlock(&map_client_list_lock);
          .           }
          .           
          .           void cpu_exec_init_all(void)
          2 ( 0.00%)  {
          2 ( 0.00%)      qemu_mutex_init(&ram_list.mutex);
         42 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_mutex_init (1x)
          .               /* The data structures we set up here depend on knowing the page size,
          .                * so no more changes can be made after this point.
          .                * In an ideal world, nothing we did before we had finished the
          .                * machine setup would care about the target page size, and we could
          .                * do this much later, rather than requiring board models to state
          .                * up front what their requirements are.
          .                */
          1 ( 0.00%)      finalize_target_page_bits();
         15 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../page-vary.c:finalize_target_page_bits (1x)
          .               io_mem_init();
          .               memory_map_init();
          2 ( 0.00%)      qemu_mutex_init(&map_client_list_lock);
         42 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_mutex_init (1x)
          1 ( 0.00%)  }
          .           
          .           void cpu_unregister_map_client(QEMUBH *bh)
          .           {
          .               MapClient *client;
          .           
          .               qemu_mutex_lock(&map_client_list_lock);
          .               QLIST_FOREACH(client, &map_client_list, link) {
          .                   if (client->bh == bh) {
-- line 3149 ----------------------------------------
-- line 3158 ----------------------------------------
          .           {
          .               qemu_mutex_lock(&map_client_list_lock);
          .               cpu_notify_map_clients_locked();
          .               qemu_mutex_unlock(&map_client_list_lock);
          .           }
          .           
          .           static bool flatview_access_valid(FlatView *fv, hwaddr addr, hwaddr len,
          .                                             bool is_write, MemTxAttrs attrs)
  3,736,008 ( 0.01%)  {
          .               MemoryRegion *mr;
          .               hwaddr l, xlat;
          .           
  3,424,674 ( 0.00%)      while (len > 0) {
    311,334 ( 0.00%)          l = len;
  2,490,672 ( 0.00%)          mr = flatview_translate(fv, addr, &xlat, &l, is_write, attrs);
 65,637,383 ( 0.09%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:flatview_translate (311,334x)
          .                   if (!memory_access_is_direct(mr, is_write)) {
  2,179,338 ( 0.00%)              l = memory_access_size(mr, l, addr);
  7,783,350 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:memory_access_size (311,334x)
  2,490,672 ( 0.00%)              if (!memory_region_access_valid(mr, xlat, l, is_write, attrs)) {
  7,472,016 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_access_valid'2 (311,334x)
          .                           return false;
          .                       }
          .                   }
          .           
          .                   len -= l;
    311,334 ( 0.00%)          addr += l;
          .               }
    311,334 ( 0.00%)      return true;
  3,424,674 ( 0.00%)  }
          .           
          .           bool address_space_access_valid(AddressSpace *as, hwaddr addr,
          .                                           hwaddr len, bool is_write,
          .                                           MemTxAttrs attrs)
          .           {
          .               FlatView *fv;
          .           
          .               RCU_READ_LOCK_GUARD();
-- line 3192 ----------------------------------------
-- line 3523 ----------------------------------------
          .               return 0;
          .           }
          .           
          .           /*
          .            * Allows code that needs to deal with migration bitmaps etc to still be built
          .            * target independent.
          .            */
          .           size_t qemu_target_page_size(void)
          1 ( 0.00%)  {
          4 ( 0.00%)      return TARGET_PAGE_SIZE;
          1 ( 0.00%)  }
          .           
          .           int qemu_target_page_bits(void)
          .           {
          .               return TARGET_PAGE_BITS;
          .           }
          .           
          .           int qemu_target_page_bits_min(void)
          .           {
-- line 3541 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../replay/replay.c
--------------------------------------------------------------------------------
Ir                 

-- line 95 ----------------------------------------
        .                   g_assert(replay_mutex_locked());
        .                   if (replay_state.instruction_count > 0) {
        .                       replay_advance_current_icount(replay_get_current_icount());
        .                   }
        .               }
        .           }
        .           
        .           bool replay_exception(void)
1,607,712 ( 0.00%)  {
        .           
3,215,424 ( 0.00%)      if (replay_mode == REPLAY_MODE_RECORD) {
        .                   g_assert(replay_mutex_locked());
        .                   replay_save_instructions();
        .                   replay_put_event(EVENT_EXCEPTION);
        .                   return true;
1,607,712 ( 0.00%)      } else if (replay_mode == REPLAY_MODE_PLAY) {
        .                   g_assert(replay_mutex_locked());
        .                   bool res = replay_has_exception();
        .                   if (res) {
        .                       replay_finish_event();
        .                   }
        .                   return res;
        .               }
        .           
  803,856 ( 0.00%)      return true;
1,607,712 ( 0.00%)  }
        .           
        .           bool replay_has_exception(void)
  201,120 ( 0.00%)  {
        .               bool res = false;
  603,360 ( 0.00%)      if (replay_mode == REPLAY_MODE_PLAY) {
        .                   g_assert(replay_mutex_locked());
        .                   replay_account_executed_instructions();
        .                   res = replay_next_event_is(EVENT_EXCEPTION);
        .               }
        .           
        .               return res;
  402,240 ( 0.00%)  }
        .           
        .           bool replay_interrupt(void)
  362,240 ( 0.00%)  {
  724,480 ( 0.00%)      if (replay_mode == REPLAY_MODE_RECORD) {
        .                   g_assert(replay_mutex_locked());
        .                   replay_save_instructions();
        .                   replay_put_event(EVENT_INTERRUPT);
        .                   return true;
  362,240 ( 0.00%)      } else if (replay_mode == REPLAY_MODE_PLAY) {
        .                   g_assert(replay_mutex_locked());
        .                   bool res = replay_has_interrupt();
        .                   if (res) {
        .                       replay_finish_event();
        .                   }
        .                   return res;
        .               }
        .           
  181,120 ( 0.00%)      return true;
  362,240 ( 0.00%)  }
        .           
        .           bool replay_has_interrupt(void)
        .           {
        .               bool res = false;
        .               if (replay_mode == REPLAY_MODE_PLAY) {
        .                   g_assert(replay_mutex_locked());
        .                   replay_account_executed_instructions();
        .                   res = replay_next_event_is(EVENT_INTERRUPT);
-- line 159 ----------------------------------------
-- line 165 ----------------------------------------
        .           {
        .               if (replay_mode == REPLAY_MODE_RECORD) {
        .                   g_assert(replay_mutex_locked());
        .                   replay_put_event(EVENT_SHUTDOWN + cause);
        .               }
        .           }
        .           
        .           bool replay_checkpoint(ReplayCheckpoint checkpoint)
        8 ( 0.00%)  {
        8 ( 0.00%)      assert(EVENT_CHECKPOINT + checkpoint <= EVENT_CHECKPOINT_LAST);
        .           
        2 ( 0.00%)      replay_save_instructions();
       10 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../replay/replay-internal.c:replay_save_instructions (2x)
        .           
        8 ( 0.00%)      if (replay_mode == REPLAY_MODE_PLAY) {
        .                   g_assert(replay_mutex_locked());
        .                   if (replay_next_event_is(EVENT_CHECKPOINT + checkpoint)) {
        .                       replay_finish_event();
        .                   } else {
        .                       return false;
        .                   }
        4 ( 0.00%)      } else if (replay_mode == REPLAY_MODE_RECORD) {
        .                   g_assert(replay_mutex_locked());
        .                   replay_put_event(EVENT_CHECKPOINT + checkpoint);
        .               }
        2 ( 0.00%)      return true;
        8 ( 0.00%)  }
        .           
        .           void replay_async_events(void)
        .           {
        .               static bool processing = false;
        .               /*
        .                * If we are already processing the events, recursion may occur
        .                * in case of incorrect implementation when HW event modifies timers.
        .                * Timer modification may invoke the icount warp, event processing,
-- line 198 ----------------------------------------
-- line 274 ----------------------------------------
        .                   fseek(replay_file, HEADER_SIZE, SEEK_SET);
        .                   replay_fetch_data_kind();
        .               }
        .           
        .               replay_init_events();
        .           }
        .           
        .           void replay_configure(QemuOpts *opts)
       10 ( 0.00%)  {
        .               const char *fname;
        .               const char *rr;
        .               ReplayMode mode = REPLAY_MODE_NONE;
        .               Location loc;
        .           
        2 ( 0.00%)      if (!opts) {
        .                   return;
        .               }
        .           
        .               loc_push_none(&loc);
        .               qemu_opts_loc_restore(opts);
        .           
        .               rr = qemu_opt_get(opts, "rr");
        .               if (!rr) {
-- line 296 ----------------------------------------
-- line 312 ----------------------------------------
        .               }
        .           
        .               replay_snapshot = g_strdup(qemu_opt_get(opts, "rrsnapshot"));
        .               replay_vmstate_register();
        .               replay_enable(fname, mode);
        .           
        .           out:
        .               loc_pop(&loc);
       10 ( 0.00%)  }
        .           
        .           void replay_start(void)
        1 ( 0.00%)  {
        4 ( 0.00%)      if (replay_mode == REPLAY_MODE_NONE) {
        .                   return;
        .               }
        .           
        .               if (replay_blockers) {
        .                   error_reportf_err(replay_blockers->data, "Record/replay: ");
        .                   exit(1);
        .               }
        .               if (!icount_enabled()) {
        .                   error_report("Please enable icount to use record/replay");
        .                   exit(1);
        .               }
        .           
        .               /* Timer for snapshotting will be set up here. */
        .           
        1 ( 0.00%)      replay_enable_events();
        .           }
        .           
        .           void replay_finish(void)
        .           {
        .               if (replay_mode == REPLAY_MODE_NONE) {
        .                   return;
        .               }
        .           
-- line 347 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/ptw.c
--------------------------------------------------------------------------------
Ir                   

-- line 122 ----------------------------------------
          .               } else {
          .                   return env->cp15.ttbr1_el[regime_el(env, mmu_idx)];
          .               }
          .           }
          .           
          .           /* Return true if the specified stage of address translation is disabled */
          .           static bool regime_translation_disabled(CPUARMState *env, ARMMMUIdx mmu_idx,
          .                                                   bool is_secure)
 40,230,740 ( 0.06%)  {
          .               uint64_t hcr_el2;
          .           
 16,092,296 ( 0.02%)      if (arm_feature(env, ARM_FEATURE_M)) {
 64,369,184 ( 0.09%)          switch (env->v7m.mpu_ctrl[is_secure] &
          .                           (R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK)) {
          .                   case R_V7M_MPU_CTRL_ENABLE_MASK:
          .                       /* Enabled, but not for HardFault and NMI */
          .                       return mmu_idx & ARM_MMU_IDX_M_NEGPRI;
          .                   case R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK:
          .                       /* Enabled for all cases */
          .                       return false;
          .                   case 0:
-- line 142 ----------------------------------------
-- line 157 ----------------------------------------
          .                   /* HCR.DC means HCR.VM behaves as 1 */
          .                   return (hcr_el2 & (HCR_DC | HCR_VM)) == 0;
          .           
          .               case ARMMMUIdx_E10_0:
          .               case ARMMMUIdx_E10_1:
          .               case ARMMMUIdx_E10_1_PAN:
          .                   /* TGE means that EL0/1 act as if SCTLR_EL1.M is zero */
          .                   if (hcr_el2 & HCR_TGE) {
  8,046,148 ( 0.01%)              return true;
          .                   }
          .                   break;
          .           
          .               case ARMMMUIdx_Stage1_E0:
          .               case ARMMMUIdx_Stage1_E1:
          .               case ARMMMUIdx_Stage1_E1_PAN:
          .                   /* HCR.DC means SCTLR_EL1.M behaves as 0 */
          .                   if (hcr_el2 & HCR_DC) {
-- line 173 ----------------------------------------
-- line 187 ----------------------------------------
          .                   /* No translation for physical address spaces. */
          .                   return true;
          .           
          .               default:
          .                   g_assert_not_reached();
          .               }
          .           
          .               return (regime_sctlr(env, mmu_idx) & SCTLR_M) == 0;
 32,184,592 ( 0.04%)  }
          .           
          .           static bool S2_attrs_are_device(uint64_t hcr, uint8_t attrs)
          .           {
          .               /*
          .                * For an S1 page table walk, the stage 1 attributes are always
          .                * some form of "this is Normal memory". The combined S1+S2
          .                * attributes are therefore only Device if stage 2 specifies Device.
          .                * With HCR_EL2.FWB == 0 this is when descriptor bits [5:4] are 0b00,
-- line 203 ----------------------------------------
-- line 1684 ----------------------------------------
          .                   return true;
          .               }
          .               result->f.prot |= PAGE_EXEC;
          .               return false;
          .           }
          .           
          .           static void get_phys_addr_pmsav7_default(CPUARMState *env, ARMMMUIdx mmu_idx,
          .                                                    int32_t address, uint8_t *prot)
  8,046,148 ( 0.01%)  {
 16,092,296 ( 0.02%)      if (!arm_feature(env, ARM_FEATURE_M)) {
          .                   *prot = PAGE_READ | PAGE_WRITE;
          .                   switch (address) {
          .                   case 0xF0000000 ... 0xFFFFFFFF:
          .                       if (regime_sctlr(env, mmu_idx) & SCTLR_V) {
          .                           /* hivecs execing is ok */
          .                           *prot |= PAGE_EXEC;
          .                       }
          .                       break;
          .                   case 0x00000000 ... 0x7FFFFFFF:
  8,027,541 ( 0.01%)              *prot |= PAGE_EXEC;
  8,027,541 ( 0.01%)              break;
          .                   }
          .               } else {
          .                   /* Default system address map for M profile cores.
          .                    * The architecture specifies which regions are execute-never;
          .                    * at the MPU level no other checks are defined.
          .                    */
 40,212,135 ( 0.06%)          switch (address) {
          .                   case 0x00000000 ... 0x1fffffff: /* ROM */
          .                   case 0x20000000 ... 0x3fffffff: /* SRAM */
          .                   case 0x60000000 ... 0x7fffffff: /* RAM */
          .                   case 0x80000000 ... 0x9fffffff: /* RAM */
          .                       *prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;
          .                       break;
          .                   case 0x40000000 ... 0x5fffffff: /* Peripheral */
          .                   case 0xa0000000 ... 0xbfffffff: /* Device */
          .                   case 0xc0000000 ... 0xdfffffff: /* Device */
          .                   case 0xe0000000 ... 0xffffffff: /* System */
     18,607 ( 0.00%)              *prot = PAGE_READ | PAGE_WRITE;
          .                       break;
          .                   default:
     37,212 ( 0.00%)              g_assert_not_reached();
          .                   }
          .               }
          .           }
          .           
          .           static bool m_is_ppb_region(CPUARMState *env, uint32_t address)
          .           {
          .               /* True if address is in the M profile PPB region 0xe0000000 - 0xe00fffff */
          .               return arm_feature(env, ARM_FEATURE_M) &&
-- line 1733 ----------------------------------------
-- line 1767 ----------------------------------------
          .                                            MMUAccessType access_type, ARMMMUIdx mmu_idx,
          .                                            bool secure, GetPhysAddrResult *result,
          .                                            ARMMMUFaultInfo *fi)
          .           {
          .               ARMCPU *cpu = env_archcpu(env);
          .               int n;
          .               bool is_user = regime_is_user(env, mmu_idx);
          .           
 16,092,296 ( 0.02%)      result->f.phys_addr = address;
          .               result->f.lg_page_size = TARGET_PAGE_BITS;
  8,046,148 ( 0.01%)      result->f.prot = 0;
          .           
 64,369,184 ( 0.09%)      if (regime_translation_disabled(env, mmu_idx, secure) ||
160,922,960 ( 0.22%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/ptw.c:regime_translation_disabled (8,046,148x)
          .                   m_is_ppb_region(env, address)) {
          .                   /*
          .                    * MPU disabled or M profile PPB access: use default memory map.
          .                    * The other case which uses the default memory map in the
          .                    * v7M ARM ARM pseudocode is exception vector reads from the vector
          .                    * table. In QEMU those accesses are done in arm_v7m_load_vector(),
          .                    * which always does a direct read using address_space_ldl(), rather
          .                    * than going via this function, so we don't need to check that here.
-- line 1787 ----------------------------------------
-- line 1872 ----------------------------------------
          .                   }
          .           
          .                   if (n == -1) { /* no hits */
          .                       if (!pmsav7_use_background_region(cpu, mmu_idx, secure, is_user)) {
          .                           /* background fault */
          .                           fi->type = ARMFault_Background;
          .                           return true;
          .                       }
 40,230,740 ( 0.06%)              get_phys_addr_pmsav7_default(env, mmu_idx, address,
 80,461,480 ( 0.11%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/ptw.c:get_phys_addr_pmsav7_default (8,046,148x)
          .                                                    &result->f.prot);
          .                   } else { /* a MPU hit! */
          .                       uint32_t ap = extract32(env->pmsav7.dracr[n], 8, 3);
          .                       uint32_t xn = extract32(env->pmsav7.dracr[n], 12, 1);
          .           
          .                       if (m_is_system_region(env, address)) {
          .                           /* System space is always execute never */
          .                           xn = 1;
-- line 1888 ----------------------------------------
-- line 1942 ----------------------------------------
          .           
          .                       /* execute never */
          .                       if (xn) {
          .                           result->f.prot &= ~PAGE_EXEC;
          .                       }
          .                   }
          .               }
          .           
 16,092,296 ( 0.02%)      fi->type = ARMFault_Permission;
  8,046,148 ( 0.01%)      fi->level = 1;
 56,323,036 ( 0.08%)      return !(result->f.prot & (1 << access_type));
          .           }
          .           
          .           bool pmsav8_mpu_lookup(CPUARMState *env, uint32_t address,
          .                                  MMUAccessType access_type, ARMMMUIdx mmu_idx,
          .                                  bool secure, GetPhysAddrResult *result,
          .                                  ARMMMUFaultInfo *fi, uint32_t *mregion)
          .           {
          .               /*
-- line 1960 ----------------------------------------
-- line 2693 ----------------------------------------
          .               return false;
          .           }
          .           
          .           static bool get_phys_addr_with_struct(CPUARMState *env, S1Translate *ptw,
          .                                                 target_ulong address,
          .                                                 MMUAccessType access_type,
          .                                                 GetPhysAddrResult *result,
          .                                                 ARMMMUFaultInfo *fi)
128,738,368 ( 0.18%)  {
  8,046,148 ( 0.01%)      ARMMMUIdx mmu_idx = ptw->in_mmu_idx;
  8,046,148 ( 0.01%)      bool is_secure = ptw->in_secure;
          .               ARMMMUIdx s1_mmu_idx;
          .           
          .               /*
          .                * The page table entries may downgrade secure to non-secure, but
          .                * cannot upgrade an non-secure translation regime's attributes
          .                * to secure.
          .                */
 56,323,036 ( 0.08%)      result->f.attrs.secure = is_secure;
          .           
 32,184,592 ( 0.04%)      switch (mmu_idx) {
          .               case ARMMMUIdx_Phys_S:
          .               case ARMMMUIdx_Phys_NS:
          .                   /* Checking Phys early avoids special casing later vs regime_el. */
          .                   return get_phys_addr_disabled(env, address, access_type, mmu_idx,
          .                                                 is_secure, result, fi);
          .           
          .               case ARMMMUIdx_Stage1_E0:
          .               case ARMMMUIdx_Stage1_E1:
          .               case ARMMMUIdx_Stage1_E1_PAN:
          .                   /* First stage lookup uses second stage for ptw. */
  8,046,148 ( 0.01%)          ptw->in_ptw_idx = is_secure ? ARMMMUIdx_Stage2_S : ARMMMUIdx_Stage2;
          .                   break;
          .           
          .               case ARMMMUIdx_E10_0:
          .                   s1_mmu_idx = ARMMMUIdx_Stage1_E0;
          .                   goto do_twostage;
          .               case ARMMMUIdx_E10_1:
          .                   s1_mmu_idx = ARMMMUIdx_Stage1_E1;
          .                   goto do_twostage;
-- line 2732 ----------------------------------------
-- line 2743 ----------------------------------------
          .                       !regime_translation_disabled(env, ARMMMUIdx_Stage2, is_secure)) {
          .                       return get_phys_addr_twostage(env, ptw, address, access_type,
          .                                                     result, fi);
          .                   }
          .                   /* fall through */
          .           
          .               default:
          .                   /* Single stage and second stage uses physical for ptw. */
  8,046,148 ( 0.01%)          ptw->in_ptw_idx = is_secure ? ARMMMUIdx_Phys_S : ARMMMUIdx_Phys_NS;
          .                   break;
          .               }
          .           
 40,230,740 ( 0.06%)      result->f.attrs.user = regime_is_user(env, mmu_idx);
          .           
          .               /*
          .                * Fast Context Switch Extension. This doesn't exist at all in v8.
          .                * In v7 and earlier it affects all stage 1 translations.
          .                */
 16,148,328 ( 0.02%)      if (address < 0x02000000 && mmu_idx != ARMMMUIdx_Stage2
     56,032 ( 0.00%)          && !arm_feature(env, ARM_FEATURE_V8)) {
          .                   if (regime_el(env, mmu_idx) == 3) {
          .                       address += env->cp15.fcseidr_s;
          .                   } else {
     56,032 ( 0.00%)              address += env->cp15.fcseidr_ns;
          .                   }
          .               }
          .           
 24,138,444 ( 0.03%)      if (arm_feature(env, ARM_FEATURE_PMSA)) {
          .                   bool ret;
 24,138,444 ( 0.03%)          result->f.lg_page_size = TARGET_PAGE_BITS;
          .           
 32,184,592 ( 0.04%)          if (arm_feature(env, ARM_FEATURE_V8)) {
          .                       /* PMSAv8 */
          .                       ret = get_phys_addr_pmsav8(env, address, access_type, mmu_idx,
          .                                                  is_secure, result, fi);
 16,092,296 ( 0.02%)          } else if (arm_feature(env, ARM_FEATURE_V7)) {
          .                       /* PMSAv7 */
          .                       ret = get_phys_addr_pmsav7(env, address, access_type, mmu_idx,
          .                                                  is_secure, result, fi);
          .                   } else {
          .                       /* Pre-v7 MPU */
          .                       ret = get_phys_addr_pmsav5(env, address, access_type, mmu_idx,
          .                                                  is_secure, result, fi);
          .                   }
-- line 2786 ----------------------------------------
-- line 2808 ----------------------------------------
          .                   return get_phys_addr_lpae(env, ptw, address, access_type, false,
          .                                             result, fi);
          .               } else if (arm_feature(env, ARM_FEATURE_V7) ||
          .                          regime_sctlr(env, mmu_idx) & SCTLR_XP) {
          .                   return get_phys_addr_v6(env, ptw, address, access_type, result, fi);
          .               } else {
          .                   return get_phys_addr_v5(env, ptw, address, access_type, result, fi);
          .               }
 96,553,776 ( 0.13%)  }
          .           
          .           bool get_phys_addr_with_secure(CPUARMState *env, target_ulong address,
          .                                          MMUAccessType access_type, ARMMMUIdx mmu_idx,
          .                                          bool is_secure, GetPhysAddrResult *result,
          .                                          ARMMMUFaultInfo *fi)
 64,369,184 ( 0.09%)  {
 48,276,888 ( 0.07%)      S1Translate ptw = {
          .                   .in_mmu_idx = mmu_idx,
          .                   .in_secure = is_secure,
          .               };
 48,276,888 ( 0.07%)      return get_phys_addr_with_struct(env, &ptw, address, access_type,
1,159,037,536 ( 1.59%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/ptw.c:get_phys_addr_with_struct (8,046,148x)
          .                                                result, fi);
 40,230,740 ( 0.06%)  }
          .           
          .           bool get_phys_addr(CPUARMState *env, target_ulong address,
          .                              MMUAccessType access_type, ARMMMUIdx mmu_idx,
          .                              GetPhysAddrResult *result, ARMMMUFaultInfo *fi)
152,876,812 ( 0.21%)  {
          .               bool is_secure;
          .           
          .               switch (mmu_idx) {
          .               case ARMMMUIdx_E10_0:
          .               case ARMMMUIdx_E10_1:
          .               case ARMMMUIdx_E10_1_PAN:
          .               case ARMMMUIdx_E20_0:
          .               case ARMMMUIdx_E20_2:
-- line 2842 ----------------------------------------
-- line 2862 ----------------------------------------
          .               case ARMMMUIdx_MSUserNegPri:
          .               case ARMMMUIdx_MSPriv:
          .               case ARMMMUIdx_MSUser:
          .                   is_secure = true;
          .                   break;
          .               default:
          .                   g_assert_not_reached();
          .               }
 40,230,740 ( 0.06%)      return get_phys_addr_with_secure(env, address, access_type, mmu_idx,
1,360,191,236 ( 1.86%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/ptw.c:get_phys_addr_with_secure (8,046,148x)
          .                                                is_secure, result, fi);
 16,092,296 ( 0.02%)  }
          .           
          .           hwaddr arm_cpu_get_phys_page_attrs_debug(CPUState *cs, vaddr addr,
          .                                                    MemTxAttrs *attrs)
          .           {
          .               ARMCPU *cpu = ARM_CPU(cs);
          .               CPUARMState *env = &cpu->env;
          .               S1Translate ptw = {
          .                   .in_mmu_idx = arm_mmu_idx(env),
-- line 2880 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/lockcnt.c
--------------------------------------------------------------------------------
Ir                 

-- line 24 ----------------------------------------
        .           #define QEMU_LOCKCNT_STATE_FREE    0   /* free, uncontended */
        .           #define QEMU_LOCKCNT_STATE_LOCKED  1   /* locked, uncontended */
        .           #define QEMU_LOCKCNT_STATE_WAITING 2   /* locked, contended */
        .           
        .           #define QEMU_LOCKCNT_COUNT_STEP    4
        .           #define QEMU_LOCKCNT_COUNT_SHIFT   2
        .           
        .           void qemu_lockcnt_init(QemuLockCnt *lockcnt)
        2 ( 0.00%)  {
        2 ( 0.00%)      lockcnt->count = 0;
        2 ( 0.00%)  }
        .           
        .           void qemu_lockcnt_destroy(QemuLockCnt *lockcnt)
        .           {
        .           }
        .           
        .           /* *val is the current value of lockcnt->count.
        .            *
        .            * If the lock is free, try a cmpxchg from *val to new_if_free; return
-- line 42 ----------------------------------------
-- line 50 ----------------------------------------
        .            * If *waited is true on return, new_if_free's bottom two bits must not
        .            * be QEMU_LOCKCNT_STATE_LOCKED on subsequent calls, because the caller
        .            * does not know if there are other waiters.  Furthermore, after *waited
        .            * is set the caller has effectively acquired the lock.  If it returns
        .            * with the lock not taken, it must wake another futex waiter.
        .            */
        .           static bool qemu_lockcnt_cmpxchg_or_wait(QemuLockCnt *lockcnt, int *val,
        .                                                    int new_if_free, bool *waited)
2,897,944 ( 0.00%)  {
        .               /* Fast path for when the lock is free.  */
1,448,972 ( 0.00%)      if ((*val & QEMU_LOCKCNT_STATE_MASK) == QEMU_LOCKCNT_STATE_FREE) {
        .                   int expected = *val;
        .           
        .                   trace_lockcnt_fast_path_attempt(lockcnt, expected, new_if_free);
1,086,729 ( 0.00%)          *val = qatomic_cmpxchg(&lockcnt->count, expected, new_if_free);
  724,486 ( 0.00%)          if (*val == expected) {
        .                       trace_lockcnt_fast_path_success(lockcnt, expected, new_if_free);
  362,243 ( 0.00%)              *val = new_if_free;
  362,243 ( 0.00%)              return true;
        .                   }
        .               }
        .           
        .               /* The slow path moves from locked to waiting if necessary, then
        .                * does a futex wait.  Both steps can be repeated ad nauseam,
        .                * only getting out of the loop if we can have another shot at the
        .                * fast path.  Once we can, get out to compute the new destination
        .                * value for the fast path.
-- line 76 ----------------------------------------
-- line 95 ----------------------------------------
        .                       *val = qatomic_read(&lockcnt->count);
        .                       trace_lockcnt_futex_wait_resume(lockcnt, *val);
        .                       continue;
        .                   }
        .           
        .                   abort();
        .               }
        .               return false;
2,173,458 ( 0.00%)  }
        .           
        .           static void lockcnt_wake(QemuLockCnt *lockcnt)
        .           {
        .               trace_lockcnt_futex_wake(lockcnt);
        .               qemu_futex_wake(&lockcnt->count, 1);
        .           }
        .           
        .           void qemu_lockcnt_inc(QemuLockCnt *lockcnt)
2,897,920 ( 0.00%)  {
  724,480 ( 0.00%)      int val = qatomic_read(&lockcnt->count);
  362,240 ( 0.00%)      bool waited = false;
        .           
        .               for (;;) {
  724,480 ( 0.00%)          if (val >= QEMU_LOCKCNT_COUNT_STEP) {
        .                       int expected = val;
        .                       val = qatomic_cmpxchg(&lockcnt->count, val,
        .                                             val + QEMU_LOCKCNT_COUNT_STEP);
        .                       if (val == expected) {
        .                           break;
        .                       }
        .                   } else {
        .                       /* The fast path is (0, unlocked)->(1, unlocked).  */
2,897,920 ( 0.00%)              if (qemu_lockcnt_cmpxchg_or_wait(lockcnt, &val, QEMU_LOCKCNT_COUNT_STEP,
9,056,000 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/lockcnt.c:qemu_lockcnt_cmpxchg_or_wait (362,240x)
        .                                                        &waited)) {
        .                           break;
        .                       }
        .                   }
        .               }
        .           
        .               /* If we were woken by another thread, we should also wake one because
        .                * we are effectively releasing the lock that was given to us.  This is
        .                * the case where qemu_lockcnt_lock would leave QEMU_LOCKCNT_STATE_WAITING
        .                * in the low bits, and qemu_lockcnt_inc_and_unlock would find it and
        .                * wake someone.
        .                */
  724,480 ( 0.00%)      if (waited) {
        .                   lockcnt_wake(lockcnt);
        .               }
2,535,680 ( 0.00%)  }
        .           
        .           void qemu_lockcnt_dec(QemuLockCnt *lockcnt)
  362,240 ( 0.00%)  {
  362,240 ( 0.00%)      qatomic_sub(&lockcnt->count, QEMU_LOCKCNT_COUNT_STEP);
  362,240 ( 0.00%)  }
        .           
        .           /* Decrement a counter, and return locked if it is decremented to zero.
        .            * If the function returns true, it is impossible for the counter to
        .            * become nonzero until the next qemu_lockcnt_unlock.
        .            */
        .           bool qemu_lockcnt_dec_and_lock(QemuLockCnt *lockcnt)
        .           {
        .               int val = qatomic_read(&lockcnt->count);
-- line 155 ----------------------------------------
-- line 229 ----------------------------------------
        .                */
        .               if (waited) {
        .                   lockcnt_wake(lockcnt);
        .               }
        .               return false;
        .           }
        .           
        .           void qemu_lockcnt_lock(QemuLockCnt *lockcnt)
       33 ( 0.00%)  {
       12 ( 0.00%)      int val = qatomic_read(&lockcnt->count);
        3 ( 0.00%)      int step = QEMU_LOCKCNT_STATE_LOCKED;
        3 ( 0.00%)      bool waited = false;
        .           
        .               /* The third argument is only used if the low bits of val are 0
        .                * (QEMU_LOCKCNT_STATE_FREE), so just blindly mix in the desired
        .                * state.
        .                */
       24 ( 0.00%)      while (!qemu_lockcnt_cmpxchg_or_wait(lockcnt, &val, val + step, &waited)) {
       75 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/lockcnt.c:qemu_lockcnt_cmpxchg_or_wait (3x)
        .                   if (waited) {
        .                       /* At this point we do not know if there are more waiters.  Assume
        .                        * there are.
        .                        */
        3 ( 0.00%)              step = QEMU_LOCKCNT_STATE_WAITING;
        .                   }
        .               }
       30 ( 0.00%)  }
        .           
        .           void qemu_lockcnt_inc_and_unlock(QemuLockCnt *lockcnt)
        .           {
        .               int expected, new, val;
        .           
        .               val = qatomic_read(&lockcnt->count);
        .               do {
        .                   expected = val;
-- line 262 ----------------------------------------
-- line 267 ----------------------------------------
        .           
        .               trace_lockcnt_unlock_success(lockcnt, val, new);
        .               if (val & QEMU_LOCKCNT_STATE_WAITING) {
        .                   lockcnt_wake(lockcnt);
        .               }
        .           }
        .           
        .           void qemu_lockcnt_unlock(QemuLockCnt *lockcnt)
        3 ( 0.00%)  {
        .               int expected, new, val;
        .           
        6 ( 0.00%)      val = qatomic_read(&lockcnt->count);
        .               do {
        .                   expected = val;
        6 ( 0.00%)          new = val & ~QEMU_LOCKCNT_STATE_MASK;
        .                   trace_lockcnt_unlock_attempt(lockcnt, val, new);
       12 ( 0.00%)          val = qatomic_cmpxchg(&lockcnt->count, val, new);
        6 ( 0.00%)      } while (val != expected);
        .           
        .               trace_lockcnt_unlock_success(lockcnt, val, new);
        9 ( 0.00%)      if (val & QEMU_LOCKCNT_STATE_WAITING) {
        .                   lockcnt_wake(lockcnt);
        .               }
        .           }
        .           
        .           unsigned qemu_lockcnt_count(QemuLockCnt *lockcnt)
        .           {
        .               return qatomic_read(&lockcnt->count) >> QEMU_LOCKCNT_COUNT_SHIFT;
        .           }
-- line 295 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c
--------------------------------------------------------------------------------
Ir                   

-- line 67 ----------------------------------------
          .           static QemuMutex qemu_global_mutex;
          .           
          .           /*
          .            * The chosen accelerator is supposed to register this.
          .            */
          .           static const AccelOpsClass *cpus_accel;
          .           
          .           bool cpu_is_stopped(CPUState *cpu)
    362,242 ( 0.00%)  {
    905,605 ( 0.00%)      return cpu->stopped || !runstate_is_running();
  1,267,847 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/runstate.c:runstate_is_running (181,121x)
    362,242 ( 0.00%)  }
          .           
          .           bool cpu_work_list_empty(CPUState *cpu)
    181,121 ( 0.00%)  {
    543,363 ( 0.00%)      return QSIMPLEQ_EMPTY_ATOMIC(&cpu->work_list);
    181,121 ( 0.00%)  }
          .           
          .           bool cpu_thread_is_idle(CPUState *cpu)
          .           {
          .               if (cpu->stop || !cpu_work_list_empty(cpu)) {
          .                   return false;
          .               }
          .               if (cpu_is_stopped(cpu)) {
          .                   return true;
-- line 90 ----------------------------------------
-- line 124 ----------------------------------------
          .                   fprintf(stderr, "CPU #%d:\n", cpu->cpu_index);
          .                   cpu_dump_state(cpu, stderr, CPU_DUMP_FPU);
          .               }
          .               va_end(ap);
          .               abort();
          .           }
          .           
          .           void cpu_synchronize_all_states(void)
          2 ( 0.00%)  {
          .               CPUState *cpu;
          .           
          8 ( 0.00%)      CPU_FOREACH(cpu) {
          2 ( 0.00%)          cpu_synchronize_state(cpu);
          6 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:cpu_synchronize_state (1x)
          .               }
          2 ( 0.00%)  }
          .           
          .           void cpu_synchronize_all_post_reset(void)
          2 ( 0.00%)  {
          .               CPUState *cpu;
          .           
          8 ( 0.00%)      CPU_FOREACH(cpu) {
          2 ( 0.00%)          cpu_synchronize_post_reset(cpu);
          6 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:cpu_synchronize_post_reset (1x)
          .               }
          2 ( 0.00%)  }
          .           
          .           void cpu_synchronize_all_post_init(void)
          2 ( 0.00%)  {
          .               CPUState *cpu;
          .           
          8 ( 0.00%)      CPU_FOREACH(cpu) {
          2 ( 0.00%)          cpu_synchronize_post_init(cpu);
          6 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:cpu_synchronize_post_init (1x)
          .               }
          2 ( 0.00%)  }
          .           
          .           void cpu_synchronize_all_pre_loadvm(void)
          .           {
          .               CPUState *cpu;
          .           
          .               CPU_FOREACH(cpu) {
          .                   cpu_synchronize_pre_loadvm(cpu);
          .               }
          .           }
          .           
          .           void cpu_synchronize_state(CPUState *cpu)
          1 ( 0.00%)  {
          4 ( 0.00%)      if (cpus_accel->synchronize_state) {
          .                   cpus_accel->synchronize_state(cpu);
          .               }
          1 ( 0.00%)  }
          .           
          .           void cpu_synchronize_post_reset(CPUState *cpu)
          1 ( 0.00%)  {
          4 ( 0.00%)      if (cpus_accel->synchronize_post_reset) {
          .                   cpus_accel->synchronize_post_reset(cpu);
          .               }
          1 ( 0.00%)  }
          .           
          .           void cpu_synchronize_post_init(CPUState *cpu)
          1 ( 0.00%)  {
          4 ( 0.00%)      if (cpus_accel->synchronize_post_init) {
          .                   cpus_accel->synchronize_post_init(cpu);
          .               }
          1 ( 0.00%)  }
          .           
          .           void cpu_synchronize_pre_loadvm(CPUState *cpu)
          .           {
          .               if (cpus_accel->synchronize_pre_loadvm) {
          .                   cpus_accel->synchronize_pre_loadvm(cpu);
          .               }
          .           }
          .           
-- line 194 ----------------------------------------
-- line 196 ----------------------------------------
          .           {
          .               if (cpus_accel->cpus_are_resettable) {
          .                   return cpus_accel->cpus_are_resettable();
          .               }
          .               return true;
          .           }
          .           
          .           int64_t cpus_get_virtual_clock(void)
    380,842 ( 0.00%)  {
          .               /*
          .                * XXX
          .                *
          .                * need to check that cpus_accel is not NULL, because qcow2 calls
          .                * qemu_get_clock_ns(CLOCK_VIRTUAL) without any accel initialized and
          .                * with ticks disabled in some io-tests:
          .                * 030 040 041 060 099 120 127 140 156 161 172 181 191 192 195 203 229 249 256 267
          .                *
          .                * is this expected?
          .                *
          .                * XXX
          .                */
  2,285,052 ( 0.00%)      if (cpus_accel && cpus_accel->get_virtual_clock) {
    380,842 ( 0.00%)          return cpus_accel->get_virtual_clock();
  1,142,526 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/xx-common-tcgloop.c:xx_icount_get (380,842x)
          .               }
          .               return cpu_get_clock();
          .           }
          .           
          .           /*
          .            * return the time elapsed in VM between vm_start and vm_stop.  Unless
          .            * icount is active, cpus_get_elapsed_ticks() uses units of the host CPU cycle
          .            * counter.
-- line 226 ----------------------------------------
-- line 238 ----------------------------------------
          .               cpu->interrupt_request |= mask;
          .           
          .               if (!qemu_cpu_is_self(cpu)) {
          .                   qemu_cpu_kick(cpu);
          .               }
          .           }
          .           
          .           void cpu_interrupt(CPUState *cpu, int mask)
    492,488 ( 0.00%)  {
  1,969,952 ( 0.00%)      if (cpus_accel->handle_interrupt) {
    492,488 ( 0.00%)          cpus_accel->handle_interrupt(cpu, mask);
  2,462,440 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/xx-common-tcgloop.c:xx_icount_handle_interrupt (492,488x)
          .               } else {
          .                   generic_handle_interrupt(cpu, mask);
          .               }
          .           }
          .           
          .           static int do_vm_stop(RunState state, bool send_stop)
          .           {
          .               int ret = 0;
-- line 256 ----------------------------------------
-- line 276 ----------------------------------------
          .            * did not expect a QMP STOP event and so we need to retain compatibility.
          .            */
          .           int vm_shutdown(void)
          .           {
          .               return do_vm_stop(RUN_STATE_SHUTDOWN, false);
          .           }
          .           
          .           bool cpu_can_run(CPUState *cpu)
    362,242 ( 0.00%)  {
    362,242 ( 0.00%)      if (cpu->stop) {
          .                   return false;
          .               }
    362,242 ( 0.00%)      if (cpu_is_stopped(cpu)) {
  2,897,936 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:cpu_is_stopped (181,121x)
          .                   return false;
          .               }
          .               return true;
    362,242 ( 0.00%)  }
          .           
          .           void cpu_handle_guest_debug(CPUState *cpu)
          .           {
          .               if (replay_running_debug()) {
          .                   if (!cpu->singlestep_enabled) {
          .                       /*
          .                        * Report about the breakpoint and
          .                        * make a single step to skip it
-- line 300 ----------------------------------------
-- line 352 ----------------------------------------
          .           {
          .               struct sigaction action;
          .           
          .               /*
          .                * ALERT: when modifying this, take care that SIGBUS forwarding in
          .                * qemu_prealloc_mem() will continue working as expected.
          .                */
          .               memset(&action, 0, sizeof(action));
          1 ( 0.00%)      action.sa_flags = SA_SIGINFO;
          2 ( 0.00%)      action.sa_sigaction = sigbus_handler;
          3 ( 0.00%)      sigaction(SIGBUS, &action, NULL);
         61 ( 0.00%)  => ???:0x0000000004e3c330 (1x)
          .           
          7 ( 0.00%)      prctl(PR_MCE_KILL, PR_MCE_KILL_SET, PR_MCE_KILL_EARLY, 0, 0);
         26 ( 0.00%)  => ???:0x0000000004e3c410 (1x)
          .           }
          .           #else /* !CONFIG_LINUX */
          .           static void qemu_init_sigbus(void)
          .           {
          .           }
          .           #endif /* !CONFIG_LINUX */
          .           
          .           static QemuThread io_thread;
          .           
          .           /* cpu creation */
          .           static QemuCond qemu_cpu_cond;
          .           /* system init */
          .           static QemuCond qemu_pause_cond;
          .           
          .           void qemu_init_cpu_loop(void)
          5 ( 0.00%)  {
          .               qemu_init_sigbus();
          2 ( 0.00%)      qemu_cond_init(&qemu_cpu_cond);
         59 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_cond_init (1x)
          2 ( 0.00%)      qemu_cond_init(&qemu_pause_cond);
         59 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_cond_init (1x)
          2 ( 0.00%)      qemu_mutex_init(&qemu_global_mutex);
         42 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_mutex_init (1x)
          .           
          5 ( 0.00%)      qemu_thread_get_self(&io_thread);
         12 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_thread_get_self (1x)
          1 ( 0.00%)  }
          .           
          .           void run_on_cpu(CPUState *cpu, run_on_cpu_func func, run_on_cpu_data data)
     79,996 ( 0.00%)  {
    159,992 ( 0.00%)      do_run_on_cpu(cpu, func, data, &qemu_global_mutex);
  3,839,808 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../cpus-common.c:do_run_on_cpu (79,996x)
          .           }
          .           
          .           static void qemu_cpu_stop(CPUState *cpu, bool exit)
          .           {
          .               g_assert(qemu_cpu_is_self(cpu));
          .               cpu->stop = false;
          .               cpu->stopped = true;
          .               if (exit) {
-- line 399 ----------------------------------------
-- line 449 ----------------------------------------
          .                   exit(1);
          .               }
          .           #else
          .               qemu_sem_post(&cpu->sem);
          .           #endif
          .           }
          .           
          .           void qemu_cpu_kick(CPUState *cpu)
          3 ( 0.00%)  {
          2 ( 0.00%)      qemu_cond_broadcast(cpu->halt_cond);
         33 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_cond_broadcast (1x)
          4 ( 0.00%)      if (cpus_accel->kick_vcpu_thread) {
          2 ( 0.00%)          cpus_accel->kick_vcpu_thread(cpu);
          2 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/xx-common-tcgloop.c:xx_kick_vcpu_thread (1x)
          .               } else { /* default */
          .                   cpus_kick_thread(cpu);
          .               }
          1 ( 0.00%)  }
          .           
          .           void qemu_cpu_kick_self(void)
          .           {
          .               assert(current_cpu);
          .               cpus_kick_thread(current_cpu);
          .           }
          .           
          .           bool qemu_cpu_is_self(CPUState *cpu)
     80,001 ( 0.00%)  {
    160,002 ( 0.00%)      return qemu_thread_is_self(cpu->thread);
  1,040,013 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_thread_is_self (80,001x)
          .           }
          .           
          .           bool qemu_in_vcpu_thread(void)
          8 ( 0.00%)  {
         20 ( 0.00%)      return current_cpu && qemu_cpu_is_self(current_cpu);
         56 ( 0.00%)  => ???:0x0000000004e3cc50 (4x)
         12 ( 0.00%)  }
          .           
185,009,776 ( 0.25%)  QEMU_DEFINE_STATIC_CO_TLS(bool, iothread_locked)
163,251,704 ( 0.22%)  => ???:0x0000000004e3cc50 (11,660,836x)
          .           
          .           bool qemu_mutex_iothread_locked(void)
 17,230,654 ( 0.02%)  {
 17,230,654 ( 0.02%)      return get_iothread_locked();
344,613,080 ( 0.47%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:get_iothread_locked (17,230,654x)
          .           }
          .           
          .           bool qemu_in_main_thread(void)
         98 ( 0.00%)  {
         98 ( 0.00%)      return qemu_mutex_iothread_locked();
      2,156 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:qemu_mutex_iothread_locked (98x)
          .           }
          .           
          .           /*
          .            * The BQL is taken from so many places that it is worth profiling the
          .            * callers directly, instead of funneling them all through a single function.
          .            */
          .           void qemu_mutex_lock_iothread_impl(const char *file, int line)
 34,982,508 ( 0.05%)  {
 11,660,836 ( 0.02%)      QemuMutexLockFunc bql_lock = qatomic_read(&qemu_bql_mutex_lock_func);
          .           
 17,491,254 ( 0.02%)      g_assert(!qemu_mutex_iothread_locked());
128,269,196 ( 0.18%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:qemu_mutex_iothread_locked (5,830,418x)
 23,321,672 ( 0.03%)      bql_lock(&qemu_global_mutex, file, line);
 11,660,836 ( 0.02%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_mutex_lock_impl (5,830,418x)
 11,660,836 ( 0.02%)      set_iothread_locked(true);
122,438,778 ( 0.17%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:set_iothread_locked (5,830,418x)
 17,491,254 ( 0.02%)  }
          .           
          .           void qemu_mutex_unlock_iothread(void)
 11,660,836 ( 0.02%)  {
 17,491,254 ( 0.02%)      g_assert(qemu_mutex_iothread_locked());
128,269,196 ( 0.18%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:qemu_mutex_iothread_locked (5,830,418x)
 11,660,836 ( 0.02%)      set_iothread_locked(false);
122,438,778 ( 0.17%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:set_iothread_locked (5,830,418x)
 23,321,672 ( 0.03%)      qemu_mutex_unlock(&qemu_global_mutex);
 11,660,836 ( 0.02%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_mutex_unlock_impl (5,830,418x)
  5,830,418 ( 0.01%)  }
          .           
          .           void qemu_cond_wait_iothread(QemuCond *cond)
          .           {
          .               qemu_cond_wait(cond, &qemu_global_mutex);
          .           }
          .           
          .           void qemu_cond_timedwait_iothread(QemuCond *cond, int ms)
          .           {
-- line 520 ----------------------------------------
-- line 576 ----------------------------------------
          .               }
          .           
          .               qemu_mutex_unlock_iothread();
          .               replay_mutex_lock();
          .               qemu_mutex_lock_iothread();
          .           }
          .           
          .           void cpu_resume(CPUState *cpu)
          1 ( 0.00%)  {
          2 ( 0.00%)      cpu->stop = false;
          .               cpu->stopped = false;
          1 ( 0.00%)      qemu_cpu_kick(cpu);
         47 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:qemu_cpu_kick (1x)
          .           }
          .           
          .           void resume_all_vcpus(void)
          2 ( 0.00%)  {
          .               CPUState *cpu;
          .           
          3 ( 0.00%)      if (!runstate_is_running()) {
          7 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/runstate.c:runstate_is_running (1x)
          .                   return;
          .               }
          .           
          3 ( 0.00%)      qemu_clock_enable(QEMU_CLOCK_VIRTUAL, true);
        105 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:qemu_clock_enable (1x)
          8 ( 0.00%)      CPU_FOREACH(cpu) {
          2 ( 0.00%)          cpu_resume(cpu);
         51 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:cpu_resume (1x)
          .               }
          2 ( 0.00%)  }
          .           
          .           void cpu_remove_sync(CPUState *cpu)
          .           {
          .               cpu->stop = true;
          .               cpu->unplug = true;
          .               qemu_cpu_kick(cpu);
          .               qemu_mutex_unlock_iothread();
          .               qemu_thread_join(cpu->thread);
          .               qemu_mutex_lock_iothread();
          .           }
          .           
          .           void cpus_register_accel(const AccelOpsClass *ops)
          2 ( 0.00%)  {
          2 ( 0.00%)      assert(ops != NULL);
          2 ( 0.00%)      assert(ops->create_vcpu_thread != NULL); /* mandatory */
          1 ( 0.00%)      cpus_accel = ops;
          2 ( 0.00%)  }
          .           
          .           const AccelOpsClass *cpus_get_accel(void)
          .           {
          .               /* broken if we call this early */
          .               assert(cpus_accel);
          .               return cpus_accel;
          .           }
          .           
          .           void qemu_init_vcpu(CPUState *cpu)
          7 ( 0.00%)  {
          2 ( 0.00%)      MachineState *ms = MACHINE(qdev_get_machine());
          5 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/qdev.c:qdev_get_machine (1x)
          .           
          2 ( 0.00%)      cpu->nr_cores = ms->smp.cores;
          2 ( 0.00%)      cpu->nr_threads =  ms->smp.threads;
          1 ( 0.00%)      cpu->stopped = true;
          2 ( 0.00%)      cpu->random_seed = qemu_guest_random_seed_thread_part1();
         12 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/guest-random.c:qemu_guest_random_seed_thread_part1 (1x)
          .           
          2 ( 0.00%)      if (!cpu->as) {
          .                   /* If the target cpu hasn't set up any address spaces itself,
          .                    * give it the default one.
          .                    */
          .                   cpu->num_ases = 1;
          .                   cpu_address_space_init(cpu, 0, "cpu-memory", cpu->memory);
          .               }
          .           
          .               /* accelerators all implement the AccelOpsClass */
          6 ( 0.00%)      g_assert(cpus_accel != NULL && cpus_accel->create_vcpu_thread != NULL);
          2 ( 0.00%)      cpus_accel->create_vcpu_thread(cpu);
        611 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/xx-common-tcgloop.c:xx_start_vcpu_thread (1x)
          .           
          2 ( 0.00%)      while (!cpu->created) {
          .                   qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);
          .               }
          6 ( 0.00%)  }
          .           
          .           void cpu_stop_current(void)
          .           {
          .               if (current_cpu) {
          .                   current_cpu->stop = true;
          .                   cpu_exit(current_cpu);
          .               }
          .           }
-- line 660 ----------------------------------------
-- line 676 ----------------------------------------
          .           }
          .           
          .           /**
          .            * Prepare for (re)starting the VM.
          .            * Returns -1 if the vCPUs are not to be restarted (e.g. if they are already
          .            * running or in case of an error condition), 0 otherwise.
          .            */
          .           int vm_prepare_start(bool step_pending)
          7 ( 0.00%)  {
          .               RunState requested;
          .           
          2 ( 0.00%)      qemu_vmstop_requested(&requested);
         30 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/runstate.c:qemu_vmstop_requested (1x)
          3 ( 0.00%)      if (runstate_is_running() && requested == RUN_STATE__MAX) {
          7 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/runstate.c:runstate_is_running (1x)
          .                   return -1;
          .               }
          .           
          .               /* Ensure that a STOP/RESUME pair of events is emitted if a
          .                * vmstop request was pending.  The BLOCK_IO_ERROR event, for
          .                * example, according to documentation is always followed by
          .                * the STOP event.
          .                */
          3 ( 0.00%)      if (runstate_is_running()) {
          7 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/runstate.c:runstate_is_running (1x)
          .                   qapi_event_send_stop();
          .                   qapi_event_send_resume();
          .                   return -1;
          .               }
          .           
          .               /*
          .                * WHPX accelerator needs to know whether we are going to step
          .                * any CPUs, before starting the first one.
          .                */
          4 ( 0.00%)      if (cpus_accel->synchronize_pre_resume) {
          .                   cpus_accel->synchronize_pre_resume(step_pending);
          .               }
          .           
          .               /* We are sending this now, but the CPUs will be resumed shortly later */
          1 ( 0.00%)      qapi_event_send_resume();
     41,139 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/qapi/qapi-events-run-state.c:qapi_event_send_resume (1x)
          .           
          1 ( 0.00%)      cpu_enable_ticks();
         53 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpu-timers.c:cpu_enable_ticks (1x)
          2 ( 0.00%)      runstate_set(RUN_STATE_RUNNING);
         46 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/runstate.c:runstate_set (1x)
          3 ( 0.00%)      vm_state_notify(1, RUN_STATE_RUNNING);
         55 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/runstate.c:vm_state_notify (1x)
          1 ( 0.00%)      return 0;
          6 ( 0.00%)  }
          .           
          .           void vm_start(void)
          2 ( 0.00%)  {
          4 ( 0.00%)      if (!vm_prepare_start(false)) {
     41,370 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:vm_prepare_start (1x)
          1 ( 0.00%)          resume_all_vcpus();
        183 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:resume_all_vcpus (1x)
          .               }
          1 ( 0.00%)  }
          .           
          .           /* does a state transition even if the VM is already stopped,
          .              current state is forgotten forever */
          .           int vm_stop_force_state(RunState state)
          .           {
          .               if (runstate_is_running()) {
          .                   return vm_stop(state);
          .               } else {
-- line 733 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/cpu-qom.h
--------------------------------------------------------------------------------
Ir                  

-- line 22 ----------------------------------------
         .           
         .           #include "hw/core/cpu.h"
         .           #include "qom/object.h"
         .           
         .           struct arm_boot_info;
         .           
         .           #define TYPE_ARM_CPU "arm-cpu"
         .           
20,665,807 ( 0.03%)  OBJECT_DECLARE_CPU_TYPE(ARMCPU, ARMCPUClass, ARM_CPU)
 5,433,630 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_dynamic_cast_assert (1,811,210x)
         .           
         .           #define TYPE_ARM_MAX_CPU "max-" TYPE_ARM_CPU
         .           
         .           typedef struct ARMCPUInfo {
         .               const char *name;
         .               void (*initfn)(Object *obj);
         .               void (*class_init)(ObjectClass *oc, void *data);
         .           } ARMCPUInfo;
-- line 38 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c
--------------------------------------------------------------------------------
Ir                  

-- line 55 ----------------------------------------
         .               ts->tv_sec += ms / 1000;
         .               if (ts->tv_nsec >= 1000000000) {
         .                   ts->tv_sec++;
         .                   ts->tv_nsec -= 1000000000;
         .               }
         .           }
         .           
         .           void qemu_mutex_init(QemuMutex *mutex)
       165 ( 0.00%)  {
         .               int err;
         .           
       110 ( 0.00%)      err = pthread_mutex_init(&mutex->lock, NULL);
     1,760 ( 0.00%)  => ???:0x0000000004e3c7e0 (55x)
       110 ( 0.00%)      if (err)
         .                   error_exit(err, __func__);
         .               qemu_mutex_post_init(mutex);
       110 ( 0.00%)  }
         .           
         .           void qemu_mutex_destroy(QemuMutex *mutex)
         .           {
         .               int err;
         .           
         .               assert(mutex->initialized);
         .               mutex->initialized = false;
         .               err = pthread_mutex_destroy(&mutex->lock);
         .               if (err)
         .                   error_exit(err, __func__);
         .           }
         .           
         .           void qemu_mutex_lock_impl(QemuMutex *mutex, const char *file, const int line)
 6,411,746 ( 0.01%)  {
         .               /*
         .               int err;
         .           
         .               assert(mutex->initialized);
         .               qemu_mutex_pre_lock(mutex, file, line);
         .               err = pthread_mutex_lock(&mutex->lock);
         .               if (err)
         .                   error_exit(err, __func__);
         .               qemu_mutex_post_lock(mutex, file, line);
         .               */
 6,411,746 ( 0.01%)  }
         .           
         .           int qemu_mutex_trylock_impl(QemuMutex *mutex, const char *file, const int line)
         .           {
         .               /*
         .               int err;
         .           
         .               assert(mutex->initialized);
         .               err = pthread_mutex_trylock(&mutex->lock);
-- line 103 ----------------------------------------
-- line 105 ----------------------------------------
         .                   qemu_mutex_post_lock(mutex, file, line);
         .                   return 0;
         .               }
         .               if (err != EBUSY) {
         .                   error_exit(err, __func__);
         .               }
         .               return -EBUSY;
         .               */
12,823,492 ( 0.02%)  }
         .           
         .           void qemu_mutex_unlock_impl(QemuMutex *mutex, const char *file, const int line)
         .           {
         .               /*
         .               int err;
         .           
         .               assert(mutex->initialized);
         .               qemu_mutex_pre_unlock(mutex, file, line);
         .               err = pthread_mutex_unlock(&mutex->lock);
         .               if (err)
         .                   error_exit(err, __func__);
         .               */
         .           }
         .           
         .           void qemu_rec_mutex_init(QemuRecMutex *mutex)
        27 ( 0.00%)  {
         .               int err;
         .               pthread_mutexattr_t attr;
         .           
         9 ( 0.00%)      pthread_mutexattr_init(&attr);
        18 ( 0.00%)  => ???:0x0000000004e3aa50 (3x)
         9 ( 0.00%)      pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
        45 ( 0.00%)  => ???:0x0000000004e3c7a0 (3x)
        12 ( 0.00%)      err = pthread_mutex_init(&mutex->m.lock, &attr);
       150 ( 0.00%)  => ???:0x0000000004e3c7e0 (3x)
         6 ( 0.00%)      pthread_mutexattr_destroy(&attr);
        15 ( 0.00%)  => ???:0x0000000004e3c7b0 (3x)
         6 ( 0.00%)      if (err) {
         .                   error_exit(err, __func__);
         .               }
         3 ( 0.00%)      mutex->m.initialized = true;
        24 ( 0.00%)  }
         .           
         .           void qemu_rec_mutex_destroy(QemuRecMutex *mutex)
         .           {
         .               qemu_mutex_destroy(&mutex->m);
         .           }
         .           
         .           void qemu_rec_mutex_lock_impl(QemuRecMutex *mutex, const char *file, int line)
         2 ( 0.00%)  {
         2 ( 0.00%)      qemu_mutex_lock_impl(&mutex->m, file, line);
         4 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_mutex_lock_impl (2x)
         .           }
         .           
         .           int qemu_rec_mutex_trylock_impl(QemuRecMutex *mutex, const char *file, int line)
         .           {
         .               return qemu_mutex_trylock_impl(&mutex->m, file, line);
         .           }
         .           
         .           void qemu_rec_mutex_unlock_impl(QemuRecMutex *mutex, const char *file, int line)
         2 ( 0.00%)  {
         2 ( 0.00%)      qemu_mutex_unlock_impl(&mutex->m, file, line);
         4 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_mutex_unlock_impl (2x)
         .           }
         .           
         .           void qemu_cond_init(QemuCond *cond)
       128 ( 0.00%)  {
         .               pthread_condattr_t attr;
         .               int err;
         .           
        48 ( 0.00%)      err = pthread_condattr_init(&attr);
        96 ( 0.00%)  => ???:0x0000000004e3ab70 (16x)
        32 ( 0.00%)      if (err) {
         .                   error_exit(err, __func__);
         .               }
         .           #ifdef CONFIG_PTHREAD_CONDATTR_SETCLOCK
         .               err = pthread_condattr_setclock(&attr, qemu_timedwait_clockid());
         .               if (err) {
         .                   error_exit(err, __func__);
         .               }
         .           #endif
        48 ( 0.00%)      err = pthread_cond_init(&cond->cond, &attr);
       288 ( 0.00%)  => ???:0x0000000004e3c240 (16x)
        32 ( 0.00%)      if (err) {
         .                   error_exit(err, __func__);
         .               }
        32 ( 0.00%)      err = pthread_condattr_destroy(&attr);
        80 ( 0.00%)  => ???:0x0000000004e3b350 (16x)
        32 ( 0.00%)      if (err) {
         .                   error_exit(err, __func__);
         .               }
        16 ( 0.00%)      cond->initialized = true;
       112 ( 0.00%)  }
         .           
         .           void qemu_cond_destroy(QemuCond *cond)
         .           {
         .               int err;
         .           
         .               assert(cond->initialized);
         .               cond->initialized = false;
         .               err = pthread_cond_destroy(&cond->cond);
-- line 195 ----------------------------------------
-- line 203 ----------------------------------------
         .           
         .               assert(cond->initialized);
         .               err = pthread_cond_signal(&cond->cond);
         .               if (err)
         .                   error_exit(err, __func__);
         .           }
         .           
         .           void qemu_cond_broadcast(QemuCond *cond)
         2 ( 0.00%)  {
         .               int err;
         .           
         2 ( 0.00%)      assert(cond->initialized);
         1 ( 0.00%)      err = pthread_cond_broadcast(&cond->cond);
        24 ( 0.00%)  => ???:0x0000000004e3af40 (1x)
         2 ( 0.00%)      if (err)
         .                   error_exit(err, __func__);
         2 ( 0.00%)  }
         .           
         .           void qemu_cond_wait_impl(QemuCond *cond, QemuMutex *mutex, const char *file, const int line)
         .           {
         .               int err;
         .           
         .               assert(cond->initialized);
         .               qemu_mutex_pre_unlock(mutex, file, line);
         .               err = pthread_cond_wait(&cond->cond, &mutex->lock);
-- line 226 ----------------------------------------
-- line 250 ----------------------------------------
         .           {
         .               struct timespec ts;
         .           
         .               compute_abs_deadline(&ts, ms);
         .               return qemu_cond_timedwait_ts(cond, mutex, &ts, file, line);
         .           }
         .           
         .           void qemu_sem_init(QemuSemaphore *sem, int init)
        60 ( 0.00%)  {
        10 ( 0.00%)      qemu_mutex_init(&sem->mutex);
       420 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_mutex_init (10x)
        20 ( 0.00%)      qemu_cond_init(&sem->cond);
       590 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_cond_init (10x)
         .           
        20 ( 0.00%)      if (init < 0) {
         .                   error_exit(EINVAL, __func__);
         .               }
        10 ( 0.00%)      sem->count = init;
        40 ( 0.00%)  }
         .           
         .           void qemu_sem_destroy(QemuSemaphore *sem)
         .           {
         .               qemu_cond_destroy(&sem->cond);
         .               qemu_mutex_destroy(&sem->mutex);
         .           }
         .           
         .           void qemu_sem_post(QemuSemaphore *sem)
-- line 274 ----------------------------------------
-- line 358 ----------------------------------------
         .            * transitioned to free or busy.
         .            */
         .           
         .           #define EV_SET         0
         .           #define EV_FREE        1
         .           #define EV_BUSY       -1
         .           
         .           void qemu_event_init(QemuEvent *ev, bool init)
        15 ( 0.00%)  {
         .           #ifndef __linux__
         .               pthread_mutex_init(&ev->lock, NULL);
         .               pthread_cond_init(&ev->cond, NULL);
         .           #endif
         .           
        45 ( 0.00%)      ev->value = (init ? EV_SET : EV_FREE);
        15 ( 0.00%)      ev->initialized = true;
        15 ( 0.00%)  }
         .           
         .           void qemu_event_destroy(QemuEvent *ev)
         .           {
         .               assert(ev->initialized);
         .               ev->initialized = false;
         .           #ifndef __linux__
         .               pthread_mutex_destroy(&ev->lock);
         .               pthread_cond_destroy(&ev->cond);
         .           #endif
         .           }
         .           
         .           void qemu_event_set(QemuEvent *ev)
   362,310 ( 0.00%)  {
         .               /* qemu_event_set has release semantics, but because it *loads*
         .                * ev->value we need a full memory barrier here.
         .                */
   362,310 ( 0.00%)      assert(ev->initialized);
   181,155 ( 0.00%)      smp_mb();
   543,465 ( 0.00%)      if (qatomic_read(&ev->value) != EV_SET) {
   724,484 ( 0.00%)          if (qatomic_xchg(&ev->value, EV_SET) == EV_BUSY) {
         .                       /* There were waiters, wake them up.  */
         .                       qemu_futex_wake(ev, INT_MAX);
         .                   }
         .               }
   362,310 ( 0.00%)  }
         .           
         .           void qemu_event_reset(QemuEvent *ev)
   181,122 ( 0.00%)  {
         .               unsigned value;
         .           
   362,244 ( 0.00%)      assert(ev->initialized);
   181,122 ( 0.00%)      value = qatomic_read(&ev->value);
         .               smp_mb_acquire();
   362,244 ( 0.00%)      if (value == EV_SET) {
         .                   /*
         .                    * If there was a concurrent reset (or even reset+wait),
         .                    * do nothing.  Otherwise change EV_SET->EV_FREE.
         .                    */
   362,244 ( 0.00%)          qatomic_or(&ev->value, EV_FREE);
         .               }
         .           }
         .           
         .           void qemu_event_wait(QemuEvent *ev)
         2 ( 0.00%)  {
         .               unsigned value;
         .           
         2 ( 0.00%)      assert(ev->initialized);
         2 ( 0.00%)      value = qatomic_read(&ev->value);
         .               smp_mb_acquire();
         2 ( 0.00%)      if (value != EV_SET) {
         2 ( 0.00%)          if (value == EV_FREE) {
         .                       /*
         .                        * Leave the event reset and tell qemu_event_set that there
         .                        * are waiters.  No need to retry, because there cannot be
         .                        * a concurrent busy->free transition.  After the CAS, the
         .                        * event will be either set or busy.
         .                        */
         5 ( 0.00%)              if (qatomic_cmpxchg(&ev->value, EV_FREE, EV_BUSY) == EV_SET) {
         .                           return;
         .                       }
         .                   }
         .                   qemu_futex_wait(ev, EV_BUSY);
         .               }
         .           }
         .           
         .           static __thread NotifierList thread_exit;
-- line 440 ----------------------------------------
-- line 467 ----------------------------------------
         .           
         .           typedef struct {
         .               void *(*start_routine)(void *);
         .               void *arg;
         .               char *name;
         .           } QemuThreadArgs;
         .           
         .           static void *qemu_thread_start(void *args)
         5 ( 0.00%)  {
         .               QemuThreadArgs *qemu_thread_args = args;
         4 ( 0.00%)      void *(*start_routine)(void *) = qemu_thread_args->start_routine;
         2 ( 0.00%)      void *arg = qemu_thread_args->arg;
         .               void *r;
         .           
         .               /* Attempt to set the threads name; note that this is for debug, so
         .                * we're not going to fail if we can't set it.
         .                */
         3 ( 0.00%)      if (name_threads && qemu_thread_args->name) {
         .           # if defined(CONFIG_PTHREAD_SETNAME_NP_W_TID)
         .                   pthread_setname_np(pthread_self(), qemu_thread_args->name);
         .           # elif defined(CONFIG_PTHREAD_SETNAME_NP_WO_TID)
         .                   pthread_setname_np(qemu_thread_args->name);
         .           # endif
         .               }
         .               QEMU_TSAN_ANNOTATE_THREAD_NAME(qemu_thread_args->name);
         2 ( 0.00%)      g_free(qemu_thread_args->name);
     1,348 ( 0.00%)  => ???:0x0000000004e3a950 (1x)
         2 ( 0.00%)      g_free(qemu_thread_args);
        95 ( 0.00%)  => ???:0x0000000004e3a950 (1x)
         .           
         .               /*
         .                * GCC 11 with glibc 2.17 on PowerPC reports
         .                *
         .                * qemu-thread-posix.c:540:5: error: __sigsetjmp accessing 656 bytes
         .                *   in a region of size 528 [-Werror=stringop-overflow=]
         .                * 540 |     pthread_cleanup_push(qemu_thread_atexit_notify, NULL);
         .                *     |     ^~~~~~~~~~~~~~~~~~~~
-- line 501 ----------------------------------------
-- line 502 ----------------------------------------
         .                *
         .                * which is clearly nonsense.
         .                */
         .           #pragma GCC diagnostic push
         .           #ifndef __clang__
         .           #pragma GCC diagnostic ignored "-Wstringop-overflow"
         .           #endif
         .           
         9 ( 0.00%)      pthread_cleanup_push(qemu_thread_atexit_notify, NULL);
        33 ( 0.00%)  => ???:0x0000000004e3c6f0 (1x)
         9 ( 0.00%)  => ???:0x0000000004e3c8a0 (1x)
         3 ( 0.00%)      r = start_routine(arg);
    38,700 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/rcu.c:call_rcu_thread (1x)
         .               pthread_cleanup_pop(1);
         .           
         .           #pragma GCC diagnostic pop
         .           
         .               return r;
         .           }
         .           
         .           void qemu_thread_create(QemuThread *thread, const char *name,
         .                                  void *(*start_routine)(void*),
         .                                  void *arg, int mode)
        16 ( 0.00%)  {
         .               sigset_t set, oldset;
         .               int err;
         .               pthread_attr_t attr;
         .               QemuThreadArgs *qemu_thread_args;
         .           
         3 ( 0.00%)      err = pthread_attr_init(&attr);
        22 ( 0.00%)  => ???:0x0000000004e3c260 (1x)
         2 ( 0.00%)      if (err) {
         .                   error_exit(err, __func__);
         .               }
         .           
         2 ( 0.00%)      if (mode == QEMU_THREAD_DETACHED) {
         4 ( 0.00%)          pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
         8 ( 0.00%)  => ???:0x0000000004e3c440 (1x)
         .               }
         .           
         .               /* Leave signal handling to the iothread.  */
         3 ( 0.00%)      sigfillset(&set);
         9 ( 0.00%)  => ???:0x0000000004e3ae90 (1x)
         .               /* Blocking the signals can result in undefined behaviour. */
         3 ( 0.00%)      sigdelset(&set, SIGSEGV);
        16 ( 0.00%)  => ???:0x0000000004e3c390 (1x)
         3 ( 0.00%)      sigdelset(&set, SIGFPE);
        16 ( 0.00%)  => ???:0x0000000004e3c390 (1x)
         3 ( 0.00%)      sigdelset(&set, SIGILL);
        16 ( 0.00%)  => ???:0x0000000004e3c390 (1x)
         .               /* TODO avoid SIGBUS loss on macOS */
         6 ( 0.00%)      pthread_sigmask(SIG_SETMASK, &set, &oldset);
        29 ( 0.00%)  => ???:0x0000000004e3ada0 (1x)
         .           
         3 ( 0.00%)      qemu_thread_args = g_new0(QemuThreadArgs, 1);
       167 ( 0.00%)  => ???:0x0000000004e3cc20 (1x)
         3 ( 0.00%)      qemu_thread_args->name = g_strdup(name);
       251 ( 0.00%)  => ???:0x0000000004e3b620 (1x)
         1 ( 0.00%)      qemu_thread_args->start_routine = start_routine;
         1 ( 0.00%)      qemu_thread_args->arg = arg;
         .           
         5 ( 0.00%)      err = pthread_create(&thread->thread, &attr,
     1,969 ( 0.00%)  => ???:0x0000000004e3cf10 (1x)
         .                                    qemu_thread_start, qemu_thread_args);
         .           
         3 ( 0.00%)      if (err)
         .                   error_exit(err, __func__);
         .           
         4 ( 0.00%)      pthread_sigmask(SIG_SETMASK, &oldset, NULL);
        29 ( 0.00%)  => ???:0x0000000004e3ada0 (1x)
         .           
         2 ( 0.00%)      pthread_attr_destroy(&attr);
         8 ( 0.00%)  => ???:0x0000000004e3cba0 (1x)
        11 ( 0.00%)  }
         .           
         .           int qemu_thread_set_affinity(QemuThread *thread, unsigned long *host_cpus,
         .                                        unsigned long nbits)
         .           {
         .           #if defined(CONFIG_PTHREAD_AFFINITY_NP)
         .               const size_t setsize = CPU_ALLOC_SIZE(nbits);
         .               unsigned long value;
         .               cpu_set_t *cpuset;
-- line 568 ----------------------------------------
-- line 624 ----------------------------------------
         .               CPU_FREE(cpuset);
         .               return 0;
         .           #else
         .               return -ENOSYS;
         .           #endif
         .           }
         .           
         .           void qemu_thread_get_self(QemuThread *thread)
         6 ( 0.00%)  {
         4 ( 0.00%)      thread->thread = pthread_self();
        10 ( 0.00%)  => ???:0x0000000004e3bb80 (2x)
         4 ( 0.00%)  }
         .           
         .           bool qemu_thread_is_self(QemuThread *thread)
   240,003 ( 0.00%)  {
    80,001 ( 0.00%)     return pthread_equal(pthread_self(), thread->thread);
   400,005 ( 0.00%)  => ???:0x0000000004e3bb80 (80,001x)
   160,002 ( 0.00%)  }
         .           
         .           void qemu_thread_exit(void *retval)
         .           {
         .               pthread_exit(retval);
         .           }
         .           
         .           void *qemu_thread_join(QemuThread *thread)
         .           {
-- line 647 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/include/hw/core/cpu.h
--------------------------------------------------------------------------------
Ir                  

-- line 54 ----------------------------------------
         .           /*
         .            * The class checkers bring in CPU_GET_CLASS() which is potentially
         .            * expensive given the eventual call to
         .            * object_class_dynamic_cast_assert(). Because of this the CPUState
         .            * has a cached value for the class in cs->cc which is set up in
         .            * cpu_exec_realizefn() for use in hot code paths.
         .            */
         .           typedef struct CPUClass CPUClass;
42,553,377 ( 0.06%)  DECLARE_CLASS_CHECKERS(CPUClass, CPU,
       260 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_class_dynamic_cast_assert (1x)
         3 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_get_class (1x)
         .                                  TYPE_CPU)
         .           
         .           /**
         .            * OBJECT_DECLARE_CPU_TYPE:
         .            * @CpuInstanceType: instance struct name
         .            * @CpuClassType: class struct name
         .            * @CPU_MODULE_OBJ_NAME: the CPU name in uppercase with underscore separators
         .            *
-- line 70 ----------------------------------------
-- line 662 ----------------------------------------
         .            * Checks whether the CPU has work to do.
         .            *
         .            * Returns: %true if the CPU has work, %false otherwise.
         .            */
         .           static inline bool cpu_has_work(CPUState *cpu)
         .           {
         .               CPUClass *cc = CPU_GET_CLASS(cpu);
         .           
 1,086,720 ( 0.00%)      g_assert(cc->has_work);
   724,480 ( 0.00%)      return cc->has_work(cpu);
 3,441,280 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/cpu.c:arm_cpu_has_work (181,120x)
         .           }
         .           
         .           /**
         .            * qemu_cpu_is_self:
         .            * @cpu: The vCPU to check against.
         .            *
         .            * Checks whether the caller is executing on the vCPU thread.
         .            *
-- line 679 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/include/exec/memopidx.h
--------------------------------------------------------------------------------
Ir                  

-- line 22 ----------------------------------------
         .            *
         .            * Encode these values into a single parameter.
         .            */
         .           static inline MemOpIdx make_memop_idx(MemOp op, unsigned idx)
         .           {
         .           #ifdef CONFIG_DEBUG_TCG
         .               assert(idx <= 15);
         .           #endif
     4,737 ( 0.00%)      return (op << 4) | idx;
         .           }
         .           
         .           /**
         .            * get_memop
         .            * @oi: combined op/idx parameter
         .            *
         .            * Extract the memory operation from the combined value.
         .            */
         .           static inline MemOp get_memop(MemOpIdx oi)
         .           {
18,765,174 ( 0.03%)      return oi >> 4;
         .           }
         .           
         .           /**
         .            * get_mmuidx
         .            * @oi: combined op/idx parameter
         .            *
         .            * Extract the mmu index from the combined value.
         .            */
         .           static inline unsigned get_mmuidx(MemOpIdx oi)
         .           {
24,015,326 ( 0.03%)      return oi & 15;
         .           }
         .           
         .           #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/cpu.h
--------------------------------------------------------------------------------
Ir                   

-- line 765 ----------------------------------------
          .           #ifdef TARGET_TAGGED_ADDRESSES
          .               /* Linux syscall tagged address support */
          .               bool tagged_addr_enable;
          .           #endif
          .           } CPUARMState;
          .           
          .           static inline void set_feature(CPUARMState *env, int feature)
          .           {
         18 ( 0.00%)      env->features |= 1ULL << feature;
          .           }
          .           
          .           static inline void unset_feature(CPUARMState *env, int feature)
          .           {
          6 ( 0.00%)      env->features &= ~(1ULL << feature);
          .           }
          .           
          .           /**
          .            * ARMELChangeHookFn:
          .            * type of a function which can be registered via arm_register_el_change_hook()
          .            * to get callbacks when the CPU changes its exception level or mode.
          .            */
          .           typedef void ARMELChangeHookFn(ARMCPU *cpu, void *opaque);
-- line 786 ----------------------------------------
-- line 1545 ----------------------------------------
          .            */
          .           void cpsr_write(CPUARMState *env, uint32_t val, uint32_t mask,
          .                           CPSRWriteType write_type);
          .           
          .           /* Return the current xPSR value.  */
          .           static inline uint32_t xpsr_read(CPUARMState *env)
          .           {
          .               int ZF;
  3,289,832 ( 0.00%)      ZF = (env->ZF == 0);
  2,467,374 ( 0.00%)      return (env->NF & 0x80000000) | (ZF << 30)
  5,757,206 ( 0.01%)          | (env->CF << 29) | ((env->VF & 0x80000000) >> 3) | (env->QF << 27)
  4,934,748 ( 0.01%)          | (env->thumb << 24) | ((env->condexec_bits & 3) << 25)
  1,644,916 ( 0.00%)          | ((env->condexec_bits & 0xfc) << 8)
  1,644,916 ( 0.00%)          | (env->GE << 16)
  7,402,122 ( 0.01%)          | env->v7m.exception;
          .           }
          .           
          .           /* Set the xPSR.  Note that some bits of mask must be all-set or all-clear.  */
          .           static inline void xpsr_write(CPUARMState *env, uint32_t val, uint32_t mask)
          .           {
          .               if (mask & XPSR_NZCV) {
  1,969,952 ( 0.00%)          env->ZF = (~val) & XPSR_Z;
    492,488 ( 0.00%)          env->NF = val;
  1,969,952 ( 0.00%)          env->CF = (val >> 29) & 1;
  1,477,464 ( 0.00%)          env->VF = (val << 3) & 0x80000000;
          .               }
          .               if (mask & XPSR_Q) {
  1,969,952 ( 0.00%)          env->QF = ((val & XPSR_Q) != 0);
          .               }
          .               if (mask & XPSR_GE) {
  2,462,440 ( 0.00%)          env->GE = (val & XPSR_GE) >> 16;
          .               }
          .           #ifndef CONFIG_USER_ONLY
          .               if (mask & XPSR_T) {
  1,969,952 ( 0.00%)          env->thumb = ((val & XPSR_T) != 0);
          .               }
          .               if (mask & XPSR_IT_0_1) {
          .                   env->condexec_bits &= ~3;
    984,976 ( 0.00%)          env->condexec_bits |= (val >> 25) & 3;
          .               }
          .               if (mask & XPSR_IT_2_7) {
    492,488 ( 0.00%)          env->condexec_bits &= 3;
  2,462,440 ( 0.00%)          env->condexec_bits |= (val >> 8) & 0xfc;
          .               }
          .               if (mask & XPSR_EXCP) {
          .                   /* Note that this only happens on exception exit */
  1,969,952 ( 0.00%)          write_v7m_exception(env, val & XPSR_EXCP);
  7,164,096 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/m_helper.c:write_v7m_exception (492,488x)
          .               }
          .           #endif
          .           }
          .           
          .           #define HCR_VM        (1ULL << 0)
          .           #define HCR_SWIO      (1ULL << 1)
          .           #define HCR_PTW       (1ULL << 2)
          .           #define HCR_FMO       (1ULL << 3)
-- line 1599 ----------------------------------------
-- line 2359 ----------------------------------------
          .               ARM_FEATURE_VBAR, /* has cp15 VBAR */
          .               ARM_FEATURE_M_SECURITY, /* M profile Security Extension */
          .               ARM_FEATURE_M_MAIN, /* M profile Main Extension */
          .               ARM_FEATURE_V8_1M, /* M profile extras only in v8.1M and later */
          .           };
          .           
          .           static inline int arm_feature(CPUARMState *env, int feature)
          .           {
242,848,943 ( 0.33%)      return (env->features & (1ULL << feature)) != 0;
          .           }
          .           
          .           void arm_cpu_finalize_features(ARMCPU *cpu, Error **errp);
          .           
          .           #if !defined(CONFIG_USER_ONLY)
          .           /* Return true if exception levels below EL3 are in secure state,
          .            * or would be following an exception return to that level.
          .            * Unlike arm_is_secure() (which is always a question about the
          .            * _current_ state of the CPU) this doesn't care about the current
          .            * EL or mode.
          .            */
          .           static inline bool arm_is_secure_below_el3(CPUARMState *env)
          .           {
    622,736 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_EL3)) {
          .                   return !(env->cp15.scr_el3 & SCR_NS);
          .               } else {
          .                   /* If EL3 is not supported then the secure state is implementation
          .                    * defined, in which case QEMU defaults to non-secure.
          .                    */
          .                   return false;
          .               }
          .           }
          .           
          .           /* Return true if the CPU is AArch64 EL3 or AArch32 Mon */
          .           static inline bool arm_is_el3_or_mon(CPUARMState *env)
          .           {
    622,740 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_EL3)) {
          .                   if (is_a64(env) && extract32(env->pstate, 2, 2) == 3) {
          .                       /* CPU currently in AArch64 state and EL3 */
          .                       return true;
          .                   } else if (!is_a64(env) &&
          .                           (env->uncached_cpsr & CPSR_M) == ARM_CPU_MODE_MON) {
          .                       /* CPU currently in AArch32 state and monitor mode */
          .                       return true;
          .                   }
-- line 2402 ----------------------------------------
-- line 2415 ----------------------------------------
          .           
          .           /*
          .            * Return true if the current security state has AArch64 EL2 or AArch32 Hyp.
          .            * This corresponds to the pseudocode EL2Enabled()
          .            */
          .           static inline bool arm_is_el2_enabled_secstate(CPUARMState *env, bool secure)
          .           {
          .               return arm_feature(env, ARM_FEATURE_EL2)
    622,736 ( 0.00%)             && (!secure || (env->cp15.scr_el3 & SCR_EEL2));
          .           }
          .           
          .           static inline bool arm_is_el2_enabled(CPUARMState *env)
          .           {
          .               return arm_is_el2_enabled_secstate(env, arm_is_secure_below_el3(env));
          .           }
          .           
          .           #else
-- line 2431 ----------------------------------------
-- line 2498 ----------------------------------------
          .            * operating in AArch32 state, the NS-bit determines whether the secure
          .            * instance of a cp register should be used. When EL3 is AArch64 (or if
          .            * it doesn't exist at all) then there is no register banking, and all
          .            * accesses are to the non-secure version.
          .            */
          .           static inline bool access_secure_reg(CPUARMState *env)
          .           {
          .               bool ret = (arm_feature(env, ARM_FEATURE_EL3) &&
  3,783,330 ( 0.01%)                  !arm_el_is_aa64(env, 3) &&
          .                           !(env->cp15.scr_el3 & SCR_NS));
          .           
          .               return ret;
          .           }
          .           
          .           /* Macros for accessing a specified CP register bank */
          .           #define A32_BANKED_REG_GET(_env, _regname, _secure)    \
          .               ((_secure) ? (_env)->cp15._regname##_s : (_env)->cp15._regname##_ns)
-- line 2514 ----------------------------------------
-- line 2764 ----------------------------------------
          .                   return 2;
          .               }
          .               return 1;
          .           }
          .           
          .           /* Return true if a v7M CPU is in Handler mode */
          .           static inline bool arm_v7m_is_handler_mode(CPUARMState *env)
          .           {
  5,747,752 ( 0.01%)      return env->v7m.exception != 0;
          .           }
          .           
          .           /* Return the current Exception Level (as per ARMv8; note that this differs
          .            * from the ARMv7 Privilege Level).
          .            */
          .           static inline int arm_current_el(CPUARMState *env)
          .           {
 10,779,350 ( 0.01%)      if (arm_feature(env, ARM_FEATURE_M)) {
 23,905,604 ( 0.03%)          return arm_v7m_is_handler_mode(env) ||
  7,574,809 ( 0.01%)              !(env->v7m.control[env->v7m.secure] & 1);
          .               }
          .           
          .               if (is_a64(env)) {
          .                   return extract32(env->pstate, 2, 2);
          .               }
          .           
          .               switch (env->uncached_cpsr & 0x1f) {
          .               case ARM_CPU_MODE_USR:
-- line 2790 ----------------------------------------
-- line 2796 ----------------------------------------
          .               default:
          .                   if (arm_is_secure(env) && !arm_el_is_aa64(env, 3)) {
          .                       /* If EL3 is 32-bit then all secure privileged modes run in
          .                        * EL3
          .                        */
          .                       return 3;
          .                   }
          .           
  1,587,352 ( 0.00%)          return 1;
          .               }
          .           }
          .           
          .           /**
          .            * write_list_to_cpustate
          .            * @cpu: ARMCPU
          .            *
          .            * For each register listed in the ARMCPU cpreg_indexes list, write
-- line 2812 ----------------------------------------
-- line 3064 ----------------------------------------
          .           static inline bool arm_sctlr_b(CPUARMState *env)
          .           {
          .               return
          .                   /* We need not implement SCTLR.ITD in user-mode emulation, so
          .                    * let linux-user ignore the fact that it conflicts with SCTLR_B.
          .                    * This lets people run BE32 binaries with "-cpu any".
          .                    */
          .           #ifndef CONFIG_USER_ONLY
  3,783,330 ( 0.01%)          !arm_feature(env, ARM_FEATURE_V7) &&
          .           #endif
          .                   (env->cp15.sctlr_el[1] & SCTLR_B) != 0;
          .           }
          .           
          .           uint64_t arm_sctlr(CPUARMState *env, int el);
          .           
          .           static inline bool arm_cpu_data_is_big_endian_a32(CPUARMState *env,
          .                                                             bool sctlr_b)
-- line 3080 ----------------------------------------
-- line 3321 ----------------------------------------
          .               QEMU_PSCI_CONDUIT_DISABLED = 0,
          .               QEMU_PSCI_CONDUIT_SMC = 1,
          .               QEMU_PSCI_CONDUIT_HVC = 2,
          .           };
          .           
          .           #ifndef CONFIG_USER_ONLY
          .           /* Return the address space index to use for a memory access */
          .           static inline int arm_asidx_from_attrs(CPUState *cs, MemTxAttrs attrs)
  3,330,841 ( 0.00%)  {
 33,776,277 ( 0.05%)      return attrs.secure ? ARMASIdx_S : ARMASIdx_NS;
  3,330,841 ( 0.00%)  }
          .           
          .           /* Return the AddressSpace to use for a memory access
          .            * (which depends on whether the access is S or NS, and whether
          .            * the board gave us a separate AddressSpace for S accesses).
          .            */
          .           static inline AddressSpace *arm_addressspace(CPUState *cs, MemTxAttrs attrs)
          .           {
 30,234,208 ( 0.04%)      return cpu_get_address_space(cs, arm_asidx_from_attrs(cs, attrs));
  3,939,904 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:cpu_get_address_space (492,488x)
          .           }
          .           #endif
          .           
          .           /**
          .            * arm_register_pre_el_change_hook:
          .            * Register a hook function which will be called immediately before this
          .            * CPU changes exception level or mode. The hook function will be
          .            * passed a pointer to the ARMCPU and the opaque data pointer passed
-- line 3347 ----------------------------------------
-- line 3460 ----------------------------------------
          .            * and the _aa32_ function.
          .            */
          .           
          .           /*
          .            * 32-bit feature tests via id registers.
          .            */
          .           static inline bool isar_feature_aa32_thumb_div(const ARMISARegisters *id)
          .           {
          3 ( 0.00%)      return FIELD_EX32(id->id_isar0, ID_ISAR0, DIVIDE) != 0;
          .           }
          .           
          .           static inline bool isar_feature_aa32_arm_div(const ARMISARegisters *id)
          .           {
          .               return FIELD_EX32(id->id_isar0, ID_ISAR0, DIVIDE) > 1;
          .           }
          .           
          .           static inline bool isar_feature_aa32_lob(const ARMISARegisters *id)
-- line 3476 ----------------------------------------
-- line 3571 ----------------------------------------
          .                * (VSCCLRM, CLRM, FPCTX access insns) are implemented
          .                */
          .               return FIELD_EX32(id->id_pfr1, ID_PFR1, SECURITY) >= 3;
          .           }
          .           
          .           static inline bool isar_feature_aa32_fp16_arith(const ARMISARegisters *id)
          .           {
          .               /* Sadly this is encoded differently for A-profile and M-profile */
     80,068 ( 0.00%)      if (isar_feature_aa32_mprofile(id)) {
    120,102 ( 0.00%)          return FIELD_EX32(id->mvfr1, MVFR1, FP16) > 0;
          .               } else {
          .                   return FIELD_EX32(id->mvfr1, MVFR1, FPHP) >= 3;
          .               }
          .           }
          .           
          .           static inline bool isar_feature_aa32_mve(const ARMISARegisters *id)
          .           {
          .               /*
          .                * Return true if MVE is supported (either integer or floating point).
          .                * We must check for M-profile as the MVFR1 field means something
          .                * else for A-profile.
          .                */
894,472,878 ( 1.23%)      return isar_feature_aa32_mprofile(id) &&
          .                   FIELD_EX32(id->mvfr1, MVFR1, MVE) > 0;
          .           }
          .           
          .           static inline bool isar_feature_aa32_mve_fp(const ARMISARegisters *id)
          .           {
          .               /*
          .                * Return true if MVE is supported (either integer or floating point).
          .                * We must check for M-profile as the MVFR1 field means something
-- line 3601 ----------------------------------------
-- line 3612 ----------------------------------------
          .                * In this case, a minimum of VFP w/ D0-D15.
          .                */
          .               return FIELD_EX32(id->mvfr0, MVFR0, SIMDREG) > 0;
          .           }
          .           
          .           static inline bool isar_feature_aa32_simd_r32(const ARMISARegisters *id)
          .           {
          .               /* Return true if D16-D31 are implemented */
          1 ( 0.00%)      return FIELD_EX32(id->mvfr0, MVFR0, SIMDREG) >= 2;
          .           }
          .           
          .           static inline bool isar_feature_aa32_fpshvec(const ARMISARegisters *id)
          .           {
          .               return FIELD_EX32(id->mvfr0, MVFR0, FPSHVEC) > 0;
          .           }
          .           
          .           static inline bool isar_feature_aa32_fpsp_v2(const ARMISARegisters *id)
          .           {
          .               /* Return true if CPU supports single precision floating point, VFPv2 */
          1 ( 0.00%)      return FIELD_EX32(id->mvfr0, MVFR0, FPSP) > 0;
          .           }
          .           
          .           static inline bool isar_feature_aa32_fpsp_v3(const ARMISARegisters *id)
          .           {
          .               /* Return true if CPU supports single precision floating point, VFPv3 */
          .               return FIELD_EX32(id->mvfr0, MVFR0, FPSP) >= 2;
          .           }
          .           
-- line 3639 ----------------------------------------
-- line 4036 ----------------------------------------
          .           
          .           static inline bool isar_feature_aa64_mte_insn_reg(const ARMISARegisters *id)
          .           {
          .               return FIELD_EX64(id->id_aa64pfr1, ID_AA64PFR1, MTE) != 0;
          .           }
          .           
          .           static inline bool isar_feature_aa64_mte(const ARMISARegisters *id)
          .           {
          1 ( 0.00%)      return FIELD_EX64(id->id_aa64pfr1, ID_AA64PFR1, MTE) >= 2;
          .           }
          .           
          .           static inline bool isar_feature_aa64_sme(const ARMISARegisters *id)
          .           {
          .               return FIELD_EX64(id->id_aa64pfr1, ID_AA64PFR1, SME) != 0;
          .           }
          .           
          .           static inline bool isar_feature_aa64_pmuv3p1(const ARMISARegisters *id)
-- line 4052 ----------------------------------------
-- line 4265 ----------------------------------------
          .               return FIELD_SEX64(id->id_aa64dfr0, ID_AA64DFR0, DOUBLELOCK) >= 0;
          .           }
          .           
          .           /*
          .            * Feature tests for "does this exist in either 32-bit or 64-bit?"
          .            */
          .           static inline bool isar_feature_any_fp16(const ARMISARegisters *id)
          .           {
    120,102 ( 0.00%)      return isar_feature_aa64_fp16(id) || isar_feature_aa32_fp16_arith(id);
          .           }
          .           
          .           static inline bool isar_feature_any_predinv(const ARMISARegisters *id)
          .           {
          .               return isar_feature_aa64_predinv(id) || isar_feature_aa32_predinv(id);
          .           }
          .           
          .           static inline bool isar_feature_any_pmuv3p1(const ARMISARegisters *id)
-- line 4281 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/include/qemu/bitops.h
--------------------------------------------------------------------------------
Ir                     

-- line 30 ----------------------------------------
            .           
            .           /**
            .            * set_bit - Set a bit in memory
            .            * @nr: the bit to set
            .            * @addr: the address to start counting from
            .            */
            .           static inline void set_bit(long nr, unsigned long *addr)
            .           {
       18,258 ( 0.00%)      unsigned long mask = BIT_MASK(nr);
       45,641 ( 0.00%)      unsigned long *p = addr + BIT_WORD(nr);
            .           
       46,224 ( 0.00%)      *p  |= mask;
            .           }
            .           
            .           /**
            .            * set_bit_atomic - Set a bit in memory atomically
            .            * @nr: the bit to set
            .            * @addr: the address to start counting from
            .            */
            .           static inline void set_bit_atomic(long nr, unsigned long *addr)
-- line 49 ----------------------------------------
-- line 56 ----------------------------------------
            .           
            .           /**
            .            * clear_bit - Clears a bit in memory
            .            * @nr: Bit to clear
            .            * @addr: Address to start counting from
            .            */
            .           static inline void clear_bit(long nr, unsigned long *addr)
            .           {
       14,126 ( 0.00%)      unsigned long mask = BIT_MASK(nr);
       14,126 ( 0.00%)      unsigned long *p = addr + BIT_WORD(nr);
            .           
       14,126 ( 0.00%)      *p &= ~mask;
            .           }
            .           
            .           /**
            .            * change_bit - Toggle a bit in memory
            .            * @nr: Bit to change
            .            * @addr: Address to start counting from
            .            */
            .           static inline void change_bit(long nr, unsigned long *addr)
-- line 75 ----------------------------------------
-- line 127 ----------------------------------------
            .           
            .           /**
            .            * test_bit - Determine whether a bit is set
            .            * @nr: bit number to test
            .            * @addr: Address to start counting from
            .            */
            .           static inline int test_bit(long nr, const unsigned long *addr)
            .           {
      351,084 ( 0.00%)      return 1UL & (addr[BIT_WORD(nr)] >> (nr & (BITS_PER_LONG-1)));
            .           }
            .           
            .           /**
            .            * find_last_bit - find the last set bit in a memory region
            .            * @addr: The address to start the search at
            .            * @size: The maximum size to search
            .            *
            .            * Returns the bit number of the last set bit,
-- line 143 ----------------------------------------
-- line 181 ----------------------------------------
            .            * Returns the bit number of the first set bit,
            .            * or @size if there is no set bit in the bitmap.
            .            */
            .           static inline unsigned long find_first_bit(const unsigned long *addr,
            .                                                      unsigned long size)
            .           {
            .               unsigned long result, tmp;
            .           
      171,759 ( 0.00%)      for (result = 0; result < size; result += BITS_PER_LONG) {
       41,479 ( 0.00%)          tmp = *addr++;
       82,958 ( 0.00%)          if (tmp) {
       14,126 ( 0.00%)              result += ctzl(tmp);
            .                       return result < size ? result : size;
            .                   }
            .               }
            .               /* Not found */
            .               return size;
            .           }
            .           
            .           /**
-- line 200 ----------------------------------------
-- line 253 ----------------------------------------
            .           
            .           /**
            .            * rol32 - rotate a 32-bit value left
            .            * @word: value to rotate
            .            * @shift: bits to roll
            .            */
            .           static inline uint32_t rol32(uint32_t word, unsigned int shift)
            .           {
   36,866,536 ( 0.05%)      return (word << shift) | (word >> ((32 - shift) & 31));
            .           }
            .           
            .           /**
            .            * ror32 - rotate a 32-bit value right
            .            * @word: value to rotate
            .            * @shift: bits to roll
            .            */
            .           static inline uint32_t ror32(uint32_t word, unsigned int shift)
            .           {
        1,742 ( 0.00%)      return (word >> shift) | (word << ((32 - shift) & 31));
            .           }
            .           
            .           /**
            .            * rol64 - rotate a 64-bit value left
            .            * @word: value to rotate
            .            * @shift: bits to roll
            .            */
            .           static inline uint64_t rol64(uint64_t word, unsigned int shift)
-- line 279 ----------------------------------------
-- line 330 ----------------------------------------
            .            * @start and @length parameters, and return it. The bit field must
            .            * lie entirely within the 32 bit word. It is valid to request that
            .            * all 32 bits are returned (ie @length 32 and @start 0).
            .            *
            .            * Returns: the value of the bit field extracted from the input value.
            .            */
            .           static inline uint32_t extract32(uint32_t value, int start, int length)
            .           {
        4,944 ( 0.00%)      assert(start >= 0 && length > 0 && length <= 32 - start);
   19,734,523 ( 0.03%)      return (value >> start) & (~0U >> (32 - length));
            .           }
            .           
            .           /**
            .            * extract8:
            .            * @value: the value to extract the bit field from
            .            * @start: the lowest bit in the bit field (numbered from 0)
            .            * @length: the length of the bit field
            .            *
-- line 347 ----------------------------------------
-- line 388 ----------------------------------------
            .            * lie entirely within the 64 bit word. It is valid to request that
            .            * all 64 bits are returned (ie @length 64 and @start 0).
            .            *
            .            * Returns: the value of the bit field extracted from the input value.
            .            */
            .           static inline uint64_t extract64(uint64_t value, int start, int length)
            .           {
            .               assert(start >= 0 && length > 0 && length <= 64 - start);
      120,114 ( 0.00%)      return (value >> start) & (~0ULL >> (64 - length));
            .           }
            .           
            .           /**
            .            * sextract32:
            .            * @value: the value to extract the bit field from
            .            * @start: the lowest bit in the bit field (numbered from 0)
            .            * @length: the length of the bit field
            .            *
-- line 404 ----------------------------------------
-- line 413 ----------------------------------------
            .            * input value.
            .            */
            .           static inline int32_t sextract32(uint32_t value, int start, int length)
            .           {
            .               assert(start >= 0 && length > 0 && length <= 32 - start);
            .               /* Note that this implementation relies on right shift of signed
            .                * integers being an arithmetic shift.
            .                */
          618 ( 0.00%)      return ((int32_t)(value << (32 - length - start))) >> (32 - length);
            .           }
            .           
            .           /**
            .            * sextract64:
            .            * @value: the value to extract the bit field from
            .            * @start: the lowest bit in the bit field (numbered from 0)
            .            * @length: the length of the bit field
            .            *
-- line 429 ----------------------------------------
-- line 438 ----------------------------------------
            .            * input value.
            .            */
            .           static inline int64_t sextract64(uint64_t value, int start, int length)
            .           {
            .               assert(start >= 0 && length > 0 && length <= 64 - start);
            .               /* Note that this implementation relies on right shift of signed
            .                * integers being an arithmetic shift.
            .                */
            8 ( 0.00%)      return ((int64_t)(value << (64 - length - start))) >> (64 - length);
            .           }
            .           
            .           /**
            .            * deposit32:
            .            * @value: initial value to insert bit field into
            .            * @start: the lowest bit in the bit field (numbered from 0)
            .            * @length: the length of the bit field
            .            * @fieldval: the value to insert into the bit field
-- line 454 ----------------------------------------
-- line 462 ----------------------------------------
            .            * 32 and @start 0).
            .            *
            .            * Returns: the modified @value.
            .            */
            .           static inline uint32_t deposit32(uint32_t value, int start, int length,
            .                                            uint32_t fieldval)
            .           {
            .               uint32_t mask;
      111,612 ( 0.00%)      assert(start >= 0 && length > 0 && length <= 32 - start);
       37,204 ( 0.00%)      mask = (~0U >> (32 - length)) << start;
2,228,528,710 ( 3.06%)      return (value & ~mask) | ((fieldval << start) & mask);
            .           }
            .           
            .           /**
            .            * deposit64:
            .            * @value: initial value to insert bit field into
            .            * @start: the lowest bit in the bit field (numbered from 0)
            .            * @length: the length of the bit field
            .            * @fieldval: the value to insert into the bit field
-- line 480 ----------------------------------------
-- line 490 ----------------------------------------
            .            * Returns: the modified @value.
            .            */
            .           static inline uint64_t deposit64(uint64_t value, int start, int length,
            .                                            uint64_t fieldval)
            .           {
            .               uint64_t mask;
            .               assert(start >= 0 && length > 0 && length <= 64 - start);
            .               mask = (~0ULL >> (64 - length)) << start;
           55 ( 0.00%)      return (value & ~mask) | ((fieldval << start) & mask);
            .           }
            .           
            .           /**
            .            * half_shuffle32:
            .            * @x: 32-bit value (of which only the bottom 16 bits are of interest)
            .            *
            .            * Given an input value::
            .            *
-- line 506 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/debug_helper.c
--------------------------------------------------------------------------------
Ir                 

-- line 152 ----------------------------------------
        .               }
        .           }
        .           
        .           /*
        .            * Is single-stepping active? (Note that the "is EL_D AArch64?" check
        .            * implicitly means this always returns false in pre-v8 CPUs.)
        .            */
        .           bool arm_singlestep_active(CPUARMState *env)
1,891,665 ( 0.00%)  {
        .               return extract32(env->cp15.mdscr_el1, 0, 1)
        .                   && arm_el_is_aa64(env, arm_debug_target_el(env))
3,783,330 ( 0.01%)          && arm_generate_debug_exceptions(env);
3,783,330 ( 0.01%)  }
        .           
        .           /* Return true if the linked breakpoint entry lbn passes its checks */
        .           static bool linked_bp_matches(ARMCPU *cpu, int lbn)
        .           {
        .               CPUARMState *env = &cpu->env;
        .               uint64_t bcr = env->cp15.dbgbcr[lbn];
        .               int brps = arm_num_brps(cpu);
        .               int ctx_cmps = arm_num_ctx_cmps(cpu);
-- line 172 ----------------------------------------
-- line 718 ----------------------------------------
        .               /* 64 bit access versions of the (dummy) debug registers */
        .               { .name = "DBGDRAR", .cp = 14, .crm = 1, .opc1 = 0,
        .                 .access = PL0_R, .type = ARM_CP_CONST | ARM_CP_64BIT, .resetvalue = 0 },
        .               { .name = "DBGDSAR", .cp = 14, .crm = 2, .opc1 = 0,
        .                 .access = PL0_R, .type = ARM_CP_CONST | ARM_CP_64BIT, .resetvalue = 0 },
        .           };
        .           
        .           void hw_watchpoint_update(ARMCPU *cpu, int n)
      288 ( 0.00%)  {
        .               CPUARMState *env = &cpu->env;
        .               vaddr len = 0;
       32 ( 0.00%)      vaddr wvr = env->cp15.dbgwvr[n];
       32 ( 0.00%)      uint64_t wcr = env->cp15.dbgwcr[n];
        .               int mask;
        .               int flags = BP_CPU | BP_STOP_BEFORE_ACCESS;
        .           
       96 ( 0.00%)      if (env->cpu_watchpoint[n]) {
        .                   cpu_watchpoint_remove_by_ref(CPU(cpu), env->cpu_watchpoint[n]);
        .                   env->cpu_watchpoint[n] = NULL;
        .               }
        .           
       64 ( 0.00%)      if (!FIELD_EX64(wcr, DBGWCR, E)) {
        .                   /* E bit clear : watchpoint disabled */
        .                   return;
        .               }
        .           
        .               switch (FIELD_EX64(wcr, DBGWCR, LSC)) {
        .               case 0:
        .                   /* LSC 00 is reserved and must behave as if the wp is disabled */
        .                   return;
-- line 747 ----------------------------------------
-- line 804 ----------------------------------------
        .                    */
        .                   basstart = ctz32(bas);
        .                   len = cto32(bas >> basstart);
        .                   wvr += basstart;
        .               }
        .           
        .               cpu_watchpoint_insert(CPU(cpu), wvr, len, flags,
        .                                     &env->cpu_watchpoint[n]);
      192 ( 0.00%)  }
        .           
        .           void hw_watchpoint_update_all(ARMCPU *cpu)
       10 ( 0.00%)  {
        .               int i;
        .               CPUARMState *env = &cpu->env;
        .           
        .               /*
        .                * Completely clear out existing QEMU watchpoints and our array, to
        .                * avoid possible stale entries following migration load.
        .                */
        4 ( 0.00%)      cpu_watchpoint_remove_all(CPU(cpu), BP_CPU);
       28 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:cpu_watchpoint_remove_all (2x)
        .               memset(env->cpu_watchpoint, 0, sizeof(env->cpu_watchpoint));
        .           
      100 ( 0.00%)      for (i = 0; i < ARRAY_SIZE(cpu->env.cpu_watchpoint); i++) {
       96 ( 0.00%)          hw_watchpoint_update(cpu, i);
      704 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/debug_helper.c:hw_watchpoint_update (32x)
        .               }
        8 ( 0.00%)  }
        .           
        .           static void dbgwvr_write(CPUARMState *env, const ARMCPRegInfo *ri,
        .                                    uint64_t value)
        .           {
        .               ARMCPU *cpu = env_archcpu(env);
        .               int i = ri->crm;
        .           
        .               /*
-- line 837 ----------------------------------------
-- line 857 ----------------------------------------
        .               ARMCPU *cpu = env_archcpu(env);
        .               int i = ri->crm;
        .           
        .               raw_write(env, ri, value);
        .               hw_watchpoint_update(cpu, i);
        .           }
        .           
        .           void hw_breakpoint_update(ARMCPU *cpu, int n)
      288 ( 0.00%)  {
        .               CPUARMState *env = &cpu->env;
       32 ( 0.00%)      uint64_t bvr = env->cp15.dbgbvr[n];
       32 ( 0.00%)      uint64_t bcr = env->cp15.dbgbcr[n];
        .               vaddr addr;
        .               int bt;
        .               int flags = BP_CPU;
        .           
       96 ( 0.00%)      if (env->cpu_breakpoint[n]) {
        .                   cpu_breakpoint_remove_by_ref(CPU(cpu), env->cpu_breakpoint[n]);
        .                   env->cpu_breakpoint[n] = NULL;
        .               }
        .           
       64 ( 0.00%)      if (!extract64(bcr, 0, 1)) {
        .                   /* E bit clear : watchpoint disabled */
        .                   return;
        .               }
        .           
        .               bt = extract64(bcr, 20, 4);
        .           
        .               switch (bt) {
        .               case 4: /* unlinked address mismatch (reserved if AArch64) */
-- line 886 ----------------------------------------
-- line 940 ----------------------------------------
        .                    * they are linked to by some other bp/wp, which is handled in
        .                    * updates for the linking bp/wp). We choose to also generate no events
        .                    * for reserved values.
        .                    */
        .                   return;
        .               }
        .           
        .               cpu_breakpoint_insert(CPU(cpu), addr, flags, &env->cpu_breakpoint[n]);
      192 ( 0.00%)  }
        .           
        .           void hw_breakpoint_update_all(ARMCPU *cpu)
       10 ( 0.00%)  {
        .               int i;
        .               CPUARMState *env = &cpu->env;
        .           
        .               /*
        .                * Completely clear out existing QEMU breakpoints and our array, to
        .                * avoid possible stale entries following migration load.
        .                */
        4 ( 0.00%)      cpu_breakpoint_remove_all(CPU(cpu), BP_CPU);
       28 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../cpu.c:cpu_breakpoint_remove_all (2x)
        .               memset(env->cpu_breakpoint, 0, sizeof(env->cpu_breakpoint));
        .           
      100 ( 0.00%)      for (i = 0; i < ARRAY_SIZE(cpu->env.cpu_breakpoint); i++) {
       96 ( 0.00%)          hw_breakpoint_update(cpu, i);
      704 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/debug_helper.c:hw_breakpoint_update (32x)
        .               }
        8 ( 0.00%)  }
        .           
        .           static void dbgbvr_write(CPUARMState *env, const ARMCPRegInfo *ri,
        .                                    uint64_t value)
        .           {
        .               ARMCPU *cpu = env_archcpu(env);
        .               int i = ri->crm;
        .           
        .               raw_write(env, ri, value);
-- line 973 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/main-loop.c
--------------------------------------------------------------------------------
Ir                 

-- line 92 ----------------------------------------
        .               int sigfd;
        .               sigset_t set;
        .           
        .               /*
        .                * SIG_IPI must be blocked in the main thread and must not be caught
        .                * by sigwait() in the signal thread. Otherwise, the cpu thread will
        .                * not catch it reliably.
        .                */
        3 ( 0.00%)      sigemptyset(&set);
        8 ( 0.00%)  => ???:0x0000000004e3c320 (1x)
        3 ( 0.00%)      sigaddset(&set, SIG_IPI);
       16 ( 0.00%)  => ???:0x0000000004e3c890 (1x)
        3 ( 0.00%)      sigaddset(&set, SIGIO);
       16 ( 0.00%)  => ???:0x0000000004e3c890 (1x)
        3 ( 0.00%)      sigaddset(&set, SIGALRM);
       16 ( 0.00%)  => ???:0x0000000004e3c890 (1x)
        3 ( 0.00%)      sigaddset(&set, SIGBUS);
       16 ( 0.00%)  => ???:0x0000000004e3c890 (1x)
        .               /* SIGINT cannot be handled via signalfd, so that ^C can be used
        .                * to interrupt QEMU when it is being run under gdb.  SIGHUP and
        .                * SIGTERM are also handled asynchronously, even though it is not
        .                * strictly necessary, because they use the same handler as SIGINT.
        .                */
        4 ( 0.00%)      pthread_sigmask(SIG_BLOCK, &set, NULL);
       29 ( 0.00%)  => ???:0x0000000004e3ada0 (1x)
        .           
        3 ( 0.00%)      sigdelset(&set, SIG_IPI);
       16 ( 0.00%)  => ???:0x0000000004e3c390 (1x)
        2 ( 0.00%)      sigfd = qemu_signalfd(&set);
       35 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/compatfd.c:qemu_signalfd (1x)
        3 ( 0.00%)      if (sigfd == -1) {
        .                   error_setg_errno(errp, errno, "failed to create signalfd");
        .                   return -errno;
        .               }
        .           
        4 ( 0.00%)      g_unix_set_fd_nonblocking(sigfd, true, NULL);
      113 ( 0.00%)  => ???:0x0000000004e3bae0 (1x)
        .           
        5 ( 0.00%)      qemu_set_fd_handler(sigfd, sigfd_handler, NULL, (void *)(intptr_t)sigfd);
      645 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/main-loop.c:qemu_set_fd_handler (1x)
        .           
        .               return 0;
        .           }
        .           
        .           #else /* _WIN32 */
        .           
        .           static int qemu_signal_init(Error **errp)
        .           {
-- line 129 ----------------------------------------
-- line 130 ----------------------------------------
        .               return 0;
        .           }
        .           #endif
        .           
        .           static AioContext *qemu_aio_context;
        .           static QEMUBH *qemu_notify_bh;
        .           
        .           static void notify_event_cb(void *opaque)
    2,830 ( 0.00%)  {
        .               /* No need to do anything; this bottom half is only used to
        .                * kick the kernel out of ppoll/poll/WaitForMultipleObjects.
        .                */
    2,830 ( 0.00%)  }
        .           
        .           AioContext *qemu_get_aio_context(void)
        3 ( 0.00%)  {
        .               return qemu_aio_context;
        6 ( 0.00%)  }
        .           
        .           void qemu_notify_event(void)
   18,603 ( 0.00%)  {
   37,206 ( 0.00%)      if (!qemu_aio_context) {
        .                   return;
        .               }
   37,206 ( 0.00%)      qemu_bh_schedule(qemu_notify_bh);
  540,701 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/async.c:qemu_bh_schedule (18,603x)
        .           }
        .           
        .           static GArray *gpollfds;
        .           
        .           int qemu_init_main_loop(Error **errp)
        8 ( 0.00%)  {
        .               int ret;
        .               GSource *src;
        .           
        2 ( 0.00%)      init_clocks(qemu_timer_notify_cb);
    1,536 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:init_clocks (1x)
        .           
        .               ret = qemu_signal_init(errp);
        .               if (ret) {
        .                   return ret;
        .               }
        .           
        4 ( 0.00%)      qemu_aio_context = aio_context_new(errp);
    3,236 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/async.c:aio_context_new (1x)
        2 ( 0.00%)      if (!qemu_aio_context) {
        .                   return -EMFILE;
        .               }
        1 ( 0.00%)      qemu_set_current_aio_context(qemu_aio_context);
       50 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/async.c:qemu_set_current_aio_context (1x)
        5 ( 0.00%)      qemu_notify_bh = qemu_bh_new(notify_event_cb, NULL);
      247 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/main-loop.c:qemu_bh_new_full (1x)
        5 ( 0.00%)      gpollfds = g_array_new(FALSE, FALSE, sizeof(GPollFD));
      340 ( 0.00%)  => ???:0x0000000004e3bd60 (1x)
        3 ( 0.00%)      src = aio_get_g_source(qemu_aio_context);
       28 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/async.c:aio_get_g_source (1x)
        3 ( 0.00%)      g_source_set_name(src, "aio-context");
      318 ( 0.00%)  => ???:0x0000000004e3c340 (1x)
        3 ( 0.00%)      g_source_attach(src, NULL);
    4,510 ( 0.00%)  => ???:0x0000000004e3bd20 (1x)
        2 ( 0.00%)      g_source_unref(src);
       53 ( 0.00%)  => ???:0x0000000004e3b470 (1x)
        2 ( 0.00%)      src = iohandler_get_g_source();
       33 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/main-loop.c:iohandler_get_g_source (1x)
        3 ( 0.00%)      g_source_set_name(src, "io-handler");
      318 ( 0.00%)  => ???:0x0000000004e3c340 (1x)
        3 ( 0.00%)      g_source_attach(src, NULL);
    1,172 ( 0.00%)  => ???:0x0000000004e3bd20 (1x)
        2 ( 0.00%)      g_source_unref(src);
       53 ( 0.00%)  => ???:0x0000000004e3b470 (1x)
        1 ( 0.00%)      return 0;
        7 ( 0.00%)  }
        .           
        .           static void main_loop_update_params(EventLoopBase *base, Error **errp)
        .           {
        .               ERRP_GUARD();
        .           
        .               if (!qemu_aio_context) {
        .                   error_setg(errp, "qemu aio context not ready");
        .                   return;
-- line 195 ----------------------------------------
-- line 222 ----------------------------------------
        .           }
        .           
        .           static bool main_loop_can_be_deleted(EventLoopBase *base)
        .           {
        .               return false;
        .           }
        .           
        .           static void main_loop_class_init(ObjectClass *oc, void *class_data)
        2 ( 0.00%)  {
        .               EventLoopBaseClass *bc = EVENT_LOOP_BASE_CLASS(oc);
        .           
        2 ( 0.00%)      bc->init = main_loop_init;
        2 ( 0.00%)      bc->update_params = main_loop_update_params;
        2 ( 0.00%)      bc->can_be_deleted = main_loop_can_be_deleted;
        2 ( 0.00%)  }
        .           
        .           static const TypeInfo main_loop_info = {
        .               .name = TYPE_MAIN_LOOP,
        .               .parent = TYPE_EVENT_LOOP_BASE,
        .               .class_init = main_loop_class_init,
        .               .instance_size = sizeof(MainLoop),
        .           };
        .           
        .           static void main_loop_register_types(void)
        1 ( 0.00%)  {
        2 ( 0.00%)      type_register_static(&main_loop_info);
    1,229 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_register_static (1x)
        .           }
        .           
        4 ( 0.00%)  type_init(main_loop_register_types)
      278 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/module.c:register_module_init (1x)
        .           
        .           static int max_priority;
        .           
        .           #ifndef _WIN32
        .           static int glib_pollfds_idx;
        .           static int glib_n_poll_fds;
        .           
        .           void qemu_fd_register(int fd)
        .           {
        .           }
        .           
        .           static void glib_pollfds_fill(int64_t *cur_timeout)
        .           {
  362,240 ( 0.00%)      GMainContext *context = g_main_context_default();
1,448,960 ( 0.00%)  => ???:0x0000000004e3ad90 (181,120x)
  181,120 ( 0.00%)      int timeout = 0;
        .               int64_t timeout_ns;
        .               int n;
        .           
  543,360 ( 0.00%)      g_main_context_prepare(context, &max_priority);
217,498,967 ( 0.30%)  => ???:0x0000000004e3d040 (181,120x)
        .           
  543,360 ( 0.00%)      glib_pollfds_idx = gpollfds->len;
  362,240 ( 0.00%)      n = glib_n_poll_fds;
        .               do {
        .                   GPollFD *pfds;
  181,121 ( 0.00%)          glib_n_poll_fds = n;
  362,244 ( 0.00%)          g_array_set_size(gpollfds, glib_pollfds_idx + glib_n_poll_fds);
9,961,746 ( 0.01%)  => ???:0x0000000004e3ca50 (181,121x)
  724,484 ( 0.00%)          pfds = &g_array_index(gpollfds, GPollFD, glib_pollfds_idx);
  905,605 ( 0.00%)          n = g_main_context_query(context, max_priority, &timeout, pfds,
31,512,188 ( 0.04%)  => ???:0x0000000004e3ba80 (181,121x)
        .                                            glib_n_poll_fds);
  362,242 ( 0.00%)      } while (n != glib_n_poll_fds);
        .           
  543,360 ( 0.00%)      if (timeout < 0) {
        .                   timeout_ns = -1;
        .               } else {
    2,830 ( 0.00%)          timeout_ns = (int64_t)timeout * (int64_t)SCALE_MS;
        .               }
        .           
        .               *cur_timeout = qemu_soonest_timeout(timeout_ns, *cur_timeout);
        .           }
        .           
        .           static void glib_pollfds_poll(void)
        .           {
  362,240 ( 0.00%)      GMainContext *context = g_main_context_default();
1,448,960 ( 0.00%)  => ???:0x0000000004e3ad90 (181,120x)
  724,480 ( 0.00%)      GPollFD *pfds = &g_array_index(gpollfds, GPollFD, glib_pollfds_idx);
        .           
1,086,720 ( 0.00%)      if (g_main_context_check(context, max_priority, pfds, glib_n_poll_fds)) {
234,938,026 ( 0.32%)  => ???:0x0000000004e3c9d0 (181,120x)
    8,490 ( 0.00%)          g_main_context_dispatch(context);
1,524,109 ( 0.00%)  => ???:0x0000000004e3bf50 (2,830x)
        .               }
        .           }
        .           
        .           #define MAX_MAIN_LOOP_SPIN (1000)
        .           
        .           static int os_host_main_loop_wait(int64_t timeout)
        .           {
  362,240 ( 0.00%)      GMainContext *context = g_main_context_default();
1,448,960 ( 0.00%)  => ???:0x0000000004e3ad90 (181,120x)
        .               int ret;
        .           
  362,240 ( 0.00%)      g_main_context_acquire(context);
15,395,480 ( 0.02%)  => ???:0x0000000004e3c960 (181,120x)
        .           
        .               glib_pollfds_fill(&timeout);
        .           
        .               //qemu_mutex_unlock_iothread();
  181,120 ( 0.00%)      replay_mutex_unlock();
1,086,720 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../replay/replay-internal.c:replay_mutex_unlock (181,120x)
        .           
1,086,720 ( 0.00%)      ret = qemu_poll_ns((GPollFD *)gpollfds->data, gpollfds->len, timeout);
18,474,240 ( 0.03%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:qemu_poll_ns (181,120x)
        .           
  181,120 ( 0.00%)      replay_mutex_lock();
1,086,720 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../replay/replay-internal.c:replay_mutex_lock (181,120x)
        .               //qemu_mutex_lock_iothread();
        .           
        .               glib_pollfds_poll();
        .           
  362,240 ( 0.00%)      g_main_context_release(context);
6,158,080 ( 0.01%)  => ???:0x0000000004e3ac40 (181,120x)
        .           
        .               return ret;
        .           }
        .           #else
        .           /***********************************************************/
        .           /* Polling handling */
        .           
        .           typedef struct PollingEntry {
-- line 330 ----------------------------------------
-- line 570 ----------------------------------------
        .           }
        .           
        .           void main_loop_poll_remove_notifier(Notifier *notify)
        .           {
        .               notifier_remove(notify);
        .           }
        .           
        .           void main_loop_wait(int nonblocking)
2,354,560 ( 0.00%)  {
  543,360 ( 0.00%)      MainLoopPoll mlpoll = {
        .                   .state = MAIN_LOOP_POLL_FILL,
        .                   .timeout = UINT32_MAX,
        .                   .pollfds = gpollfds,
        .               };
        .               int ret;
        .               int64_t timeout_ns;
        .           
  543,360 ( 0.00%)      if (nonblocking) {
        .                   mlpoll.timeout = 0;
        .               }
        .           
        .               /* poll any events */
  362,240 ( 0.00%)      g_array_set_size(gpollfds, 0); /* reset for new iteration */
11,953,877 ( 0.02%)  => ???:0x0000000004e3ca50 (181,120x)
        .               /* XXX: separate device handlers from system ones */
  905,600 ( 0.00%)      notifier_list_notify(&main_loop_poll_notifiers, &mlpoll);
1,992,320 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/notify.c:notifier_list_notify (181,120x)
        .           
  543,360 ( 0.00%)      if (mlpoll.timeout == UINT32_MAX) {
        .                   timeout_ns = -1;
        .               } else {
        .                   timeout_ns = (uint64_t)mlpoll.timeout * (int64_t)(SCALE_MS);
        .               }
        .           
  543,360 ( 0.00%)      timeout_ns = qemu_soonest_timeout(timeout_ns,
38,035,200 ( 0.05%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:timerlistgroup_deadline_ns (181,120x)
        .                                                 timerlistgroup_deadline_ns(
        .                                                     &main_loop_tlg));
        .           
        .               ret = os_host_main_loop_wait(timeout_ns);
  905,600 ( 0.00%)      mlpoll.state = ret < 0 ? MAIN_LOOP_POLL_ERR : MAIN_LOOP_POLL_OK;
  543,360 ( 0.00%)      notifier_list_notify(&main_loop_poll_notifiers, &mlpoll);
1,992,320 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/notify.c:notifier_list_notify (181,120x)
        .           
  724,480 ( 0.00%)      if (icount_enabled()) {
        .                   /*
        .                    * CPU thread can infinitely wait for event after
        .                    * missing the warp
        .                    */
        .                   icount_start_warp_timer();
        .               }
  181,120 ( 0.00%)      qemu_clock_run_all_timers();
44,374,400 ( 0.06%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:qemu_clock_run_all_timers (181,120x)
1,992,320 ( 0.00%)  }
        .           
        .           /* Functions to operate on the main QEMU AioContext.  */
        .           
        .           QEMUBH *qemu_bh_new_full(QEMUBHFunc *cb, void *opaque, const char *name)
        2 ( 0.00%)  {
        4 ( 0.00%)      return aio_bh_new_full(qemu_aio_context, cb, opaque, name);
      241 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/async.c:aio_bh_new_full (1x)
        .           }
        .           
        .           /*
        .            * Functions to operate on the I/O handler AioContext.
        .            * This context runs on top of main loop. We can't reuse qemu_aio_context
        .            * because iohandlers mustn't be polled by aio_poll(qemu_aio_context).
        .            */
        .           static AioContext *iohandler_ctx;
        .           
        .           static void iohandler_init(void)
        .           {
        9 ( 0.00%)      if (!iohandler_ctx) {
        3 ( 0.00%)          iohandler_ctx = aio_context_new(&error_abort);
    3,395 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/async.c:aio_context_new (1x)
        .               }
        .           }
        .           
        .           AioContext *iohandler_get_aio_context(void)
        2 ( 0.00%)  {
        .               iohandler_init();
        .               return iohandler_ctx;
        2 ( 0.00%)  }
        .           
        .           GSource *iohandler_get_g_source(void)
        1 ( 0.00%)  {
        .               iohandler_init();
        1 ( 0.00%)      return aio_get_g_source(iohandler_ctx);
       28 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/async.c:aio_get_g_source (1x)
        .           }
        .           
        .           void qemu_set_fd_handler(int fd,
        .                                    IOHandler *fd_read,
        .                                    IOHandler *fd_write,
        .                                    void *opaque)
        9 ( 0.00%)  {
        .               iohandler_init();
        7 ( 0.00%)      aio_set_fd_handler(iohandler_ctx, fd, false,
      621 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/aio-posix.c:aio_set_fd_handler (1x)
        .                                  fd_read, fd_write, NULL, NULL, opaque);
        5 ( 0.00%)  }
        .           
        .           void event_notifier_set_handler(EventNotifier *e,
        .                                           EventNotifierHandler *handler)
        .           {
        .               iohandler_init();
        .               aio_set_event_notifier(iohandler_ctx, e, false,
        .                                      handler, NULL, NULL);
        .           }
-- line 669 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/include/exec/exec-all.h
--------------------------------------------------------------------------------
Ir                   

-- line 609 ----------------------------------------
          .           #else
          .               return tb->pc;
          .           #endif
          .           }
          .           
          .           /* Hide the qatomic_read to make code a little easier on the eyes */
          .           static inline uint32_t tb_cflags(const TranslationBlock *tb)
          .           {
178,866,099 ( 0.25%)      return qatomic_read(&tb->cflags);
          .           }
          .           
          .           static inline tb_page_addr_t tb_page_addr0(const TranslationBlock *tb)
          .           {
        746 ( 0.00%)      return tb->page_addr[0];
          .           }
          .           
          .           static inline tb_page_addr_t tb_page_addr1(const TranslationBlock *tb)
          .           {
  5,264,849 ( 0.01%)      return tb->page_addr[1];
          .           }
          .           
          .           static inline void tb_set_page_addr0(TranslationBlock *tb,
          .                                                tb_page_addr_t addr)
          .           {
      1,492 ( 0.00%)      tb->page_addr[0] = addr;
          .           }
          .           
          .           static inline void tb_set_page_addr1(TranslationBlock *tb,
          .                                                tb_page_addr_t addr)
          .           {
        750 ( 0.00%)      tb->page_addr[1] = addr;
          .           }
          .           
          .           /* current cflags for hashing/comparison */
          .           uint32_t curr_cflags(CPUState *cpu);
          .           
          .           /* TranslationBlock invalidate API */
          .           #if defined(CONFIG_USER_ONLY)
          .           void tb_invalidate_phys_addr(target_ulong addr);
-- line 647 ----------------------------------------
-- line 712 ----------------------------------------
          .            * the region is not backed by RAM, returns -1. Otherwise, returns the
          .            * ram_addr_t corresponding to the guest code at @addr.
          .            *
          .            * Note: this function can trigger an exception.
          .            */
          .           static inline tb_page_addr_t get_page_addr_code(CPUArchState *env,
          .                                                           target_ulong addr)
          .           {
 10,533,360 ( 0.01%)      return get_page_addr_code_hostp(env, addr, NULL);
     60,295 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:get_page_addr_code_hostp (389x)
          .           }
          .           
          .           #if defined(CONFIG_USER_ONLY)
          .           void mmap_lock(void);
          .           void mmap_unlock(void);
          .           bool have_mmap_lock(void);
          .           
          .           /**
-- line 728 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/irq.c
--------------------------------------------------------------------------------
Ir                 

-- line 21 ----------------------------------------
        .            * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
        .            * THE SOFTWARE.
        .            */
        .           #include "qemu/osdep.h"
        .           #include "qemu/main-loop.h"
        .           #include "hw/irq.h"
        .           #include "qom/object.h"
        .           
      355 ( 0.00%)  DECLARE_INSTANCE_CHECKER(struct IRQState, IRQ,
      213 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_dynamic_cast_assert (71x)
        .                                    TYPE_IRQ)
        .           
        .           struct IRQState {
        .               Object parent_obj;
        .           
        .               qemu_irq_handler handler;
        .               void *opaque;
        .               int n;
        .           };
        .           
        .           void qemu_set_irq(qemu_irq irq, int level)
3,066,540 ( 0.00%)  {
3,066,540 ( 0.00%)      if (!irq)
        .                   return;
        .           
7,666,350 ( 0.01%)      irq->handler(irq->opaque, irq->n, level);
78,206,536 ( 0.11%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/cpu.c:arm_cpu_set_irq (1,533,270x)
        .           }
        .           
        .           qemu_irq *qemu_extend_irqs(qemu_irq *old, int n_old, qemu_irq_handler handler,
        .                                      void *opaque, int n)
       44 ( 0.00%)  {
        .               qemu_irq *s;
        .               int i;
        .           
        8 ( 0.00%)      if (!old) {
        4 ( 0.00%)          n_old = 0;
        .               }
       20 ( 0.00%)      s = old ? g_renew(qemu_irq, old, n + n_old) : g_new(qemu_irq, n);
      256 ( 0.00%)  => ???:0x0000000004e3aa60 (4x)
      304 ( 0.00%)      for (i = n_old; i < n + n_old; i++) {
      355 ( 0.00%)          s[i] = qemu_allocate_irq(handler, opaque, i);
  126,438 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/irq.c:qemu_allocate_irq (71x)
        .               }
        .               return s;
       36 ( 0.00%)  }
        .           
        .           qemu_irq *qemu_allocate_irqs(qemu_irq_handler handler, void *opaque, int n)
        .           {
        .               return qemu_extend_irqs(NULL, 0, handler, opaque, n);
        .           }
        .           
        .           qemu_irq qemu_allocate_irq(qemu_irq_handler handler, void *opaque, int n)
      639 ( 0.00%)  {
        .               struct IRQState *irq;
        .           
      284 ( 0.00%)      irq = IRQ(object_new(TYPE_IRQ));
  124,308 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_new (71x)
       71 ( 0.00%)      irq->handler = handler;
       71 ( 0.00%)      irq->opaque = opaque;
       71 ( 0.00%)      irq->n = n;
        .           
        .               return irq;
      426 ( 0.00%)  }
        .           
        .           void qemu_free_irqs(qemu_irq *s, int n)
        .           {
        .               int i;
        .               for (i = 0; i < n; i++) {
        .                   qemu_free_irq(s[i]);
        .               }
        .               g_free(s);
-- line 87 ----------------------------------------
-- line 119 ----------------------------------------
        .           
        .           static const TypeInfo irq_type_info = {
        .              .name = TYPE_IRQ,
        .              .parent = TYPE_OBJECT,
        .              .instance_size = sizeof(struct IRQState),
        .           };
        .           
        .           static void irq_register_types(void)
        1 ( 0.00%)  {
        2 ( 0.00%)      type_register_static(&irq_type_info);
    1,127 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_register_static (1x)
        .           }
        .           
        4 ( 0.00%)  type_init(irq_register_types)
      261 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/module.c:register_module_init (1x)

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/tb-jmp-cache.h
--------------------------------------------------------------------------------
Ir                   

-- line 26 ----------------------------------------
          .               } array[TB_JMP_CACHE_SIZE];
          .           };
          .           
          .           static inline TranslationBlock *
          .           tb_jmp_cache_get_tb(CPUJumpCache *jc, uint32_t hash)
          .           {
          .           #if TARGET_TB_PCREL
          .               /* Use acquire to ensure current load of pc from jc. */
879,609,764 ( 1.21%)      return qatomic_load_acquire(&jc->array[hash].tb);
          .           #else
          .               /* Use rcu_read to ensure current load of pc from *tb. */
          .               return qatomic_rcu_read(&jc->array[hash].tb);
          .           #endif
          .           }
          .           
          .           static inline target_ulong
          .           tb_jmp_cache_get_pc(CPUJumpCache *jc, uint32_t hash, TranslationBlock *tb)
-- line 42 ----------------------------------------
-- line 48 ----------------------------------------
          .           #endif
          .           }
          .           
          .           static inline void
          .           tb_jmp_cache_set(CPUJumpCache *jc, uint32_t hash,
          .                            TranslationBlock *tb, target_ulong pc)
          .           {
          .           #if TARGET_TB_PCREL
 10,531,936 ( 0.01%)      jc->array[hash].pc = pc;
          .               /* Use store_release on tb to ensure pc is written first. */
  5,265,595 ( 0.01%)      qatomic_store_release(&jc->array[hash].tb, tb);
          .           #else
          .               /* Use the pc value already stored in tb->pc. */
          .               qatomic_set(&jc->array[hash].tb, tb);
          .           #endif
        746 ( 0.00%)  }
          .           
          .           #endif /* ACCEL_TCG_TB_JMP_CACHE_H */

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/cpu.c
--------------------------------------------------------------------------------
Ir                 

-- line 113 ----------------------------------------
        .                   }
        .                   env->condexec_bits = data[1];
        .                   env->exception.syndrome = data[2] << ARM_INSN_START_WORD2_SHIFT;
        .               }
        .           }
        .           #endif /* CONFIG_TCG */
        .           
        .           static bool arm_cpu_has_work(CPUState *cs)
1,086,720 ( 0.00%)  {
        .               ARMCPU *cpu = ARM_CPU(cs);
        .           
  362,240 ( 0.00%)      return (cpu->power_state != PSCI_OFF)
1,448,960 ( 0.00%)          && cs->interrupt_request &
        .                   (CPU_INTERRUPT_FIQ | CPU_INTERRUPT_HARD
        .                    | CPU_INTERRUPT_VFIQ | CPU_INTERRUPT_VIRQ | CPU_INTERRUPT_VSERR
        .                    | CPU_INTERRUPT_EXITTB);
  724,480 ( 0.00%)  }
        .           
        .           void arm_register_pre_el_change_hook(ARMCPU *cpu, ARMELChangeHookFn *hook,
        .                                            void *opaque)
        .           {
        .               ARMELChangeHook *entry = g_new0(ARMELChangeHook, 1);
        .           
        .               entry->hook = hook;
        .               entry->opaque = opaque;
-- line 137 ----------------------------------------
-- line 198 ----------------------------------------
        .           
        .               oldvalue = read_raw_cp_reg(&cpu->env, ri);
        .               cp_reg_reset(key, value, opaque);
        .               newvalue = read_raw_cp_reg(&cpu->env, ri);
        .               assert(oldvalue == newvalue);
        .           }
        .           
        .           static void arm_cpu_reset(DeviceState *dev)
       14 ( 0.00%)  {
        .               CPUState *s = CPU(dev);
        .               ARMCPU *cpu = ARM_CPU(s);
        .               ARMCPUClass *acc = ARM_CPU_GET_CLASS(cpu);
        2 ( 0.00%)      CPUARMState *env = &cpu->env;
        .           
        4 ( 0.00%)      acc->parent_reset(dev);
   66,460 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/cpu-common.c:cpu_common_reset (2x)
        .           
        .               memset(env, 0, offsetof(CPUARMState, end_reset_fields));
        .           
        8 ( 0.00%)      g_hash_table_foreach(cpu->cp_regs, cp_reg_reset, cpu);
      356 ( 0.00%)  => ???:0x0000000004e3ceb0 (2x)
        8 ( 0.00%)      g_hash_table_foreach(cpu->cp_regs, cp_reg_check_reset, cpu);
      356 ( 0.00%)  => ???:0x0000000004e3ceb0 (2x)
        .           
        4 ( 0.00%)      env->vfp.xregs[ARM_VFP_FPSID] = cpu->reset_fpsid;
        4 ( 0.00%)      env->vfp.xregs[ARM_VFP_MVFR0] = cpu->isar.mvfr0;
        4 ( 0.00%)      env->vfp.xregs[ARM_VFP_MVFR1] = cpu->isar.mvfr1;
        4 ( 0.00%)      env->vfp.xregs[ARM_VFP_MVFR2] = cpu->isar.mvfr2;
        .           
        4 ( 0.00%)      cpu->power_state = s->start_powered_off ? PSCI_OFF : PSCI_ON;
        .           
        4 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_IWMMXT)) {
        .                   env->iwmmxt.cregs[ARM_IWMMXT_wCID] = 0x69051000 | 'Q';
        .               }
        .           
        4 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_AARCH64)) {
        .                   /* 64 bit CPUs always start in 64 bit mode */
        .                   env->aarch64 = true;
        .           #if defined(CONFIG_USER_ONLY)
        .                   env->pstate = PSTATE_MODE_EL0t;
        .                   /* Userspace expects access to DC ZVA, CTL_EL0 and the cache ops */
        .                   env->cp15.sctlr_el[1] |= SCTLR_UCT | SCTLR_UCI | SCTLR_DZE;
        .                   /* Enable all PAC keys.  */
        .                   env->cp15.sctlr_el[1] |= (SCTLR_EnIA | SCTLR_EnIB |
-- line 238 ----------------------------------------
-- line 320 ----------------------------------------
        .               }
        .           #else
        .           
        .               /*
        .                * If the highest available EL is EL2, AArch32 will start in Hyp
        .                * mode; otherwise it starts in SVC. Note that if we start in
        .                * AArch64 then these values in the uncached_cpsr will be ignored.
        .                */
        4 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_EL2) &&
        .                   !arm_feature(env, ARM_FEATURE_EL3)) {
        .                   env->uncached_cpsr = ARM_CPU_MODE_HYP;
        .               } else {
        2 ( 0.00%)          env->uncached_cpsr = ARM_CPU_MODE_SVC;
        .               }
        2 ( 0.00%)      env->daif = PSTATE_D | PSTATE_A | PSTATE_I | PSTATE_F;
        .           
        .               /* AArch32 has a hard highvec setting of 0xFFFF0000.  If we are currently
        .                * executing as AArch32 then check if highvecs are enabled and
        .                * adjust the PC accordingly.
        .                */
        4 ( 0.00%)      if (A32_BANKED_CURRENT_REG_GET(env, sctlr) & SCTLR_V) {
        .                   env->regs[15] = 0xFFFF0000;
        .               }
        .           
        2 ( 0.00%)      env->vfp.xregs[ARM_VFP_FPEXC] = 0;
        .           #endif
        .           
        4 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_M)) {
        .           #ifndef CONFIG_USER_ONLY
        .                   uint32_t initial_msp; /* Loaded from 0x0 */
        .                   uint32_t initial_pc; /* Loaded from 0x4 */
        .                   uint8_t *rom;
        .                   uint32_t vecbase;
        .           #endif
        .           
        4 ( 0.00%)          if (cpu_isar_feature(aa32_lob, cpu)) {
        .                       /*
        .                        * LTPSIZE is constant 4 if MVE not implemented, and resets
        .                        * to an UNKNOWN value if MVE is implemented. We choose to
        .                        * always reset to 4.
        .                        */
        .                       env->v7m.ltpsize = 4;
        .                       /* The LTPSIZE field in FPDSCR is constant and reads as 4. */
        .                       env->v7m.fpdscr[M_REG_NS] = 4 << FPCR_LTPSIZE_SHIFT;
        .                       env->v7m.fpdscr[M_REG_S] = 4 << FPCR_LTPSIZE_SHIFT;
        .                   }
        .           
        4 ( 0.00%)          if (arm_feature(env, ARM_FEATURE_M_SECURITY)) {
        .                       env->v7m.secure = true;
        .                   } else {
        .                       /* This bit resets to 0 if security is supported, but 1 if
        .                        * it is not. The bit is not present in v7M, but we set it
        .                        * here so we can avoid having to make checks on it conditional
        .                        * on ARM_FEATURE_V8 (we don't let the guest see the bit).
        .                        */
        2 ( 0.00%)              env->v7m.aircr = R_V7M_AIRCR_BFHFNMINS_MASK;
        .                       /*
        .                        * Set NSACR to indicate "NS access permitted to everything";
        .                        * this avoids having to have all the tests of it being
        .                        * conditional on ARM_FEATURE_M_SECURITY. Note also that from
        .                        * v8.1M the guest-visible value of NSACR in a CPU without the
        .                        * Security Extension is 0xcff.
        .                        */
        4 ( 0.00%)              env->v7m.nsacr = 0xcff;
        .                   }
        .           
        .                   /* In v7M the reset value of this bit is IMPDEF, but ARM recommends
        .                    * that it resets to 1, so QEMU always does that rather than making
        .                    * it dependent on CPU model. In v8M it is RES1.
        .                    */
        .                   env->v7m.ccr[M_REG_NS] = R_V7M_CCR_STKALIGN_MASK;
        .                   env->v7m.ccr[M_REG_S] = R_V7M_CCR_STKALIGN_MASK;
        .                   if (arm_feature(env, ARM_FEATURE_V8)) {
        .                       /* in v8M the NONBASETHRDENA bit [0] is RES1 */
       10 ( 0.00%)              env->v7m.ccr[M_REG_NS] |= R_V7M_CCR_NONBASETHRDENA_MASK;
        .                       env->v7m.ccr[M_REG_S] |= R_V7M_CCR_NONBASETHRDENA_MASK;
        .                   }
        4 ( 0.00%)          if (!arm_feature(env, ARM_FEATURE_M_MAIN)) {
        .                       env->v7m.ccr[M_REG_NS] |= R_V7M_CCR_UNALIGN_TRP_MASK;
        .                       env->v7m.ccr[M_REG_S] |= R_V7M_CCR_UNALIGN_TRP_MASK;
        .                   }
        .           
        4 ( 0.00%)          if (cpu_isar_feature(aa32_vfp_simd, cpu)) {
        4 ( 0.00%)              env->v7m.fpccr[M_REG_NS] = R_V7M_FPCCR_ASPEN_MASK;
        .                       env->v7m.fpccr[M_REG_S] = R_V7M_FPCCR_ASPEN_MASK |
        .                           R_V7M_FPCCR_LSPEN_MASK | R_V7M_FPCCR_S_MASK;
        .                   }
        .           
        .           #ifndef CONFIG_USER_ONLY
        .                   /* Unlike A/R profile, M profile defines the reset LR value */
        2 ( 0.00%)          env->regs[14] = 0xffffffff;
        .           
        6 ( 0.00%)          env->v7m.vecbase[M_REG_S] = cpu->init_svtor & 0xffffff80;
        6 ( 0.00%)          env->v7m.vecbase[M_REG_NS] = cpu->init_nsvtor & 0xffffff80;
        .           
        .                   /* Load the initial SP and PC from offset 0 and 4 in the vector table */
        8 ( 0.00%)          vecbase = env->v7m.vecbase[env->v7m.secure];
        8 ( 0.00%)          rom = rom_ptr_for_as(s->as, vecbase, 8);
    1,191 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/loader.c:rom_ptr_for_as (2x)
        4 ( 0.00%)          if (rom) {
        .                       /* Address zero is covered by ROM which hasn't yet been
        .                        * copied into physical memory.
        .                        */
        .                       initial_msp = ldl_p(rom);
        .                       initial_pc = ldl_p(rom + 4);
        .                   } else {
        .                       /* Address zero not covered by a ROM blob, or the ROM blob
        .                        * is in non-modifiable memory and this is a second reset after
        .                        * it got copied into memory. In the latter case, rom_ptr
        .                        * will return a NULL pointer and we should use ldl_phys instead.
        .                        */
        2 ( 0.00%)              initial_msp = ldl_phys(s->as, vecbase);
        4 ( 0.00%)              initial_pc = ldl_phys(s->as, vecbase + 4);
        .                   }
        .           
        .                   qemu_log_mask(CPU_LOG_INT,
        .                                 "Loaded reset SP 0x%x PC 0x%x from vector table\n",
        .                                 initial_msp, initial_pc);
        .           
        6 ( 0.00%)          env->regs[13] = initial_msp & 0xFFFFFFFC;
        6 ( 0.00%)          env->regs[15] = initial_pc & ~1;
        6 ( 0.00%)          env->thumb = initial_pc & 1;
        .           #else
        .                   /*
        .                    * For user mode we run non-secure and with access to the FPU.
        .                    * The FPU context is active (ie does not need further setup)
        .                    * and is owned by non-secure.
        .                    */
        .                   env->v7m.secure = false;
        .                   env->v7m.nsacr = 0xcff;
-- line 448 ----------------------------------------
-- line 454 ----------------------------------------
        .               }
        .           
        .               /* M profile requires that reset clears the exclusive monitor;
        .                * A profile does not, but clearing it makes more sense than having it
        .                * set with an exclusive access on address zero.
        .                */
        .               arm_clear_exclusive(env);
        .           
        4 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_PMSA)) {
        6 ( 0.00%)          if (cpu->pmsav7_dregion > 0) {
        4 ( 0.00%)              if (arm_feature(env, ARM_FEATURE_V8)) {
        .                           memset(env->pmsav8.rbar[M_REG_NS], 0,
        .                                  sizeof(*env->pmsav8.rbar[M_REG_NS])
        .                                  * cpu->pmsav7_dregion);
        .                           memset(env->pmsav8.rlar[M_REG_NS], 0,
        .                                  sizeof(*env->pmsav8.rlar[M_REG_NS])
        .                                  * cpu->pmsav7_dregion);
        .                           if (arm_feature(env, ARM_FEATURE_M_SECURITY)) {
        .                               memset(env->pmsav8.rbar[M_REG_S], 0,
        .                                      sizeof(*env->pmsav8.rbar[M_REG_S])
        .                                      * cpu->pmsav7_dregion);
        .                               memset(env->pmsav8.rlar[M_REG_S], 0,
        .                                      sizeof(*env->pmsav8.rlar[M_REG_S])
        .                                      * cpu->pmsav7_dregion);
        .                           }
        4 ( 0.00%)              } else if (arm_feature(env, ARM_FEATURE_V7)) {
        2 ( 0.00%)                  memset(env->pmsav7.drbar, 0,
        .                                  sizeof(*env->pmsav7.drbar) * cpu->pmsav7_dregion);
        2 ( 0.00%)                  memset(env->pmsav7.drsr, 0,
        2 ( 0.00%)                         sizeof(*env->pmsav7.drsr) * cpu->pmsav7_dregion);
        2 ( 0.00%)                  memset(env->pmsav7.dracr, 0,
        2 ( 0.00%)                         sizeof(*env->pmsav7.dracr) * cpu->pmsav7_dregion);
        .                       }
        .                   }
        2 ( 0.00%)          env->pmsav7.rnr[M_REG_NS] = 0;
        .                   env->pmsav7.rnr[M_REG_S] = 0;
        2 ( 0.00%)          env->pmsav8.mair0[M_REG_NS] = 0;
        .                   env->pmsav8.mair0[M_REG_S] = 0;
        4 ( 0.00%)          env->pmsav8.mair1[M_REG_NS] = 0;
        .                   env->pmsav8.mair1[M_REG_S] = 0;
        .               }
        .           
        4 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_M_SECURITY)) {
        .                   if (cpu->sau_sregion > 0) {
        .                       memset(env->sau.rbar, 0, sizeof(*env->sau.rbar) * cpu->sau_sregion);
        .                       memset(env->sau.rlar, 0, sizeof(*env->sau.rlar) * cpu->sau_sregion);
        .                   }
        .                   env->sau.rnr = 0;
        .                   /* SAU_CTRL reset value is IMPDEF; we choose 0, which is what
        .                    * the Cortex-M33 does.
        .                    */
-- line 504 ----------------------------------------
-- line 518 ----------------------------------------
        .               set_float_detect_tininess(float_tininess_before_rounding,
        .                                         &env->vfp.standard_fp_status_f16);
        .           #ifndef CONFIG_USER_ONLY
        .               if (kvm_enabled()) {
        .                   kvm_arm_reset_vcpu(cpu);
        .               }
        .           #endif
        .           
        4 ( 0.00%)      hw_breakpoint_update_all(cpu);
    1,000 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/debug_helper.c:hw_breakpoint_update_all (2x)
        4 ( 0.00%)      hw_watchpoint_update_all(cpu);
    1,000 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/debug_helper.c:hw_watchpoint_update_all (2x)
        4 ( 0.00%)      arm_rebuild_hflags(env);
      386 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:arm_rebuild_hflags (2x)
       10 ( 0.00%)  }
        .           
        .           #ifndef CONFIG_USER_ONLY
        .           
        .           static inline bool arm_excp_unmasked(CPUState *cs, unsigned int excp_idx,
        .                                                unsigned int target_el,
        .                                                unsigned int cur_el, bool secure,
        .                                                uint64_t hcr_el2)
        .           {
-- line 537 ----------------------------------------
-- line 785 ----------------------------------------
        .                   } else {
        .                       cpu_reset_interrupt(cs, CPU_INTERRUPT_VSERR);
        .                   }
        .               }
        .           }
        .           
        .           #ifndef CONFIG_USER_ONLY
        .           static void arm_cpu_set_irq(void *opaque, int irq, int level)
1,533,270 ( 0.00%)  {
        .               ARMCPU *cpu = opaque;
        .               CPUARMState *env = &cpu->env;
        .               CPUState *cs = CPU(cpu);
        .               static const int mask[] = {
        .                   [ARM_CPU_IRQ] = CPU_INTERRUPT_HARD,
        .                   [ARM_CPU_FIQ] = CPU_INTERRUPT_FIQ,
        .                   [ARM_CPU_VIRQ] = CPU_INTERRUPT_VIRQ,
        .                   [ARM_CPU_VFIQ] = CPU_INTERRUPT_VFIQ
        .               };
        .           
6,133,080 ( 0.01%)      if (!arm_feature(env, ARM_FEATURE_EL2) &&
1,533,270 ( 0.00%)          (irq == ARM_CPU_VIRQ || irq == ARM_CPU_VFIQ)) {
        .                   /*
        .                    * The GIC might tell us about VIRQ and VFIQ state, but if we don't
        .                    * have EL2 support we don't care. (Unless the guest is doing something
        .                    * silly this will only be calls saying "level is still 0".)
        .                    */
        .                   return;
        .               }
        .           
3,066,540 ( 0.00%)      if (level) {
7,118,056 ( 0.01%)          env->irq_line_state |= mask[irq];
        .               } else {
4,163,128 ( 0.01%)          env->irq_line_state &= ~mask[irq];
        .               }
        .           
7,666,350 ( 0.01%)      switch (irq) {
        .               case ARM_CPU_VIRQ:
        .                   arm_cpu_update_virq(cpu);
        .                   break;
        .               case ARM_CPU_VFIQ:
        .                   arm_cpu_update_vfiq(cpu);
        .                   break;
        .               case ARM_CPU_IRQ:
        .               case ARM_CPU_FIQ:
        .                   if (level) {
  984,976 ( 0.00%)              cpu_interrupt(cs, mask[irq]);
5,417,368 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:cpu_interrupt (492,488x)
        .                   } else {
2,081,564 ( 0.00%)              cpu_reset_interrupt(cs, mask[irq]);
38,508,934 ( 0.05%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/cpu-common.c:cpu_reset_interrupt (1,040,782x)
        .                   }
        .                   break;
        .               default:
        .                   g_assert_not_reached();
        .               }
        .           }
        .           
        .           static void arm_cpu_kvm_set_irq(void *opaque, int irq, int level)
-- line 840 ----------------------------------------
-- line 1164 ----------------------------------------
        .                   qemu_fprintf(f, "FPSCR: %08x\n", vfp_get_fpscr(env));
        .                   if (cpu_isar_feature(aa32_mve, cpu)) {
        .                       qemu_fprintf(f, "VPR: %08x\n", env->v7m.vpr);
        .                   }
        .               }
        .           }
        .           
        .           uint64_t arm_cpu_mp_affinity(int idx, uint8_t clustersz)
        1 ( 0.00%)  {
        4 ( 0.00%)      uint32_t Aff1 = idx / clustersz;
        .               uint32_t Aff0 = idx % clustersz;
        2 ( 0.00%)      return (Aff1 << ARM_AFF1_SHIFT) | Aff0;
        1 ( 0.00%)  }
        .           
        .           static void arm_cpu_initfn(Object *obj)
        4 ( 0.00%)  {
        .               ARMCPU *cpu = ARM_CPU(obj);
        .           
        .               cpu_set_cpustate_pointers(cpu);
        6 ( 0.00%)      cpu->cp_regs = g_hash_table_new_full(g_direct_hash, g_direct_equal,
      712 ( 0.00%)  => ???:0x0000000004e3b5d0 (1x)
        .                                                    NULL, g_free);
        .           
        1 ( 0.00%)      QLIST_INIT(&cpu->pre_el_change_hooks);
        1 ( 0.00%)      QLIST_INIT(&cpu->el_change_hooks);
        .           
        .           #ifdef CONFIG_USER_ONLY
        .           # ifdef TARGET_AARCH64
        .               /*
        .                * The linux kernel defaults to 512-bit for SVE, and 256-bit for SME.
        .                * These values were chosen to fit within the default signal frame.
        .                * See documentation for /proc/sys/abi/{sve,sme}_default_vector_length,
        .                * and our corresponding cpu property.
-- line 1195 ----------------------------------------
-- line 1200 ----------------------------------------
        .           #else
        .               /* Our inbound IRQ and FIQ lines */
        .               if (kvm_enabled()) {
        .                   /* VIRQ and VFIQ are unused with KVM but we add them to maintain
        .                    * the same interface as non-KVM CPUs.
        .                    */
        .                   qdev_init_gpio_in(DEVICE(cpu), arm_cpu_kvm_set_irq, 4);
        .               } else {
        3 ( 0.00%)          qdev_init_gpio_in(DEVICE(cpu), arm_cpu_set_irq, 4);
   28,216 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/gpio.c:qdev_init_gpio_in (1x)
        .               }
        .           
        3 ( 0.00%)      qdev_init_gpio_out(DEVICE(cpu), cpu->gt_timer_outputs,
   28,813 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/gpio.c:qdev_init_gpio_out (1x)
        .                                  ARRAY_SIZE(cpu->gt_timer_outputs));
        .           
        4 ( 0.00%)      qdev_init_gpio_out_named(DEVICE(cpu), &cpu->gicv3_maintenance_interrupt,
    6,093 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/gpio.c:qdev_init_gpio_out_named (1x)
        .                                        "gicv3-maintenance-interrupt", 1);
        4 ( 0.00%)      qdev_init_gpio_out_named(DEVICE(cpu), &cpu->pmu_interrupt,
    6,010 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/gpio.c:qdev_init_gpio_out_named (1x)
        .                                        "pmu-interrupt", 1);
        .           #endif
        .           
        .               /* DTB consumers generally don't in fact care what the 'compatible'
        .                * string is, so always provide some string and trust that a hypothetical
        .                * picky DTB consumer will also provide a helpful error message.
        .                */
        2 ( 0.00%)      cpu->dtb_compatible = "qemu,unknown";
        .               cpu->psci_version = QEMU_PSCI_VERSION_0_1; /* By default assume PSCI v0.1 */
        1 ( 0.00%)      cpu->kvm_target = QEMU_KVM_ARM_TARGET_NONE;
        .           
        1 ( 0.00%)      if (tcg_enabled() || hvf_enabled()) {
        .                   /* TCG and HVF implement PSCI 1.1 */
        5 ( 0.00%)          cpu->psci_version = QEMU_PSCI_VERSION_1_1;
        .               }
        4 ( 0.00%)  }
        .           
        .           static Property arm_cpu_gt_cntfrq_property =
        .                       DEFINE_PROP_UINT64("cntfrq", ARMCPU, gt_cntfrq_hz,
        .                                          NANOSECONDS_PER_SECOND / GTIMER_SCALE);
        .           
        .           static Property arm_cpu_reset_cbar_property =
        .                       DEFINE_PROP_UINT64("reset-cbar", ARMCPU, reset_cbar, 0);
        .           
-- line 1240 ----------------------------------------
-- line 1317 ----------------------------------------
        .                * Finally, CNTFRQ is effectively capped at 1GHz to ensure our scale factor
        .                * cannot become zero.
        .                */
        .               return NANOSECONDS_PER_SECOND > cpu->gt_cntfrq_hz ?
        .                 NANOSECONDS_PER_SECOND / cpu->gt_cntfrq_hz : 1;
        .           }
        .           
        .           void arm_cpu_post_init(Object *obj)
        7 ( 0.00%)  {
        .               ARMCPU *cpu = ARM_CPU(obj);
        .           
        .               /* M profile implies PMSA. We have to do this here rather than
        .                * in realize with the other feature-implication checks because
        .                * we look at the PMSA bit to see if we should add some properties.
        .                */
        2 ( 0.00%)      if (arm_feature(&cpu->env, ARM_FEATURE_M)) {
        .                   set_feature(&cpu->env, ARM_FEATURE_PMSA);
        .               }
        .           
        4 ( 0.00%)      if (arm_feature(&cpu->env, ARM_FEATURE_CBAR) ||
        .                   arm_feature(&cpu->env, ARM_FEATURE_CBAR_RO)) {
        .                   qdev_property_add_static(DEVICE(obj), &arm_cpu_reset_cbar_property);
        .               }
        .           
        2 ( 0.00%)      if (!arm_feature(&cpu->env, ARM_FEATURE_M)) {
        .                   qdev_property_add_static(DEVICE(obj), &arm_cpu_reset_hivecs_property);
        .               }
        .           
        2 ( 0.00%)      if (arm_feature(&cpu->env, ARM_FEATURE_AARCH64)) {
        .                   object_property_add_uint64_ptr(obj, "rvbar",
        .                                                  &cpu->rvbar_prop,
        .                                                  OBJ_PROP_FLAG_READWRITE);
        .               }
        .           
        .           #ifndef CONFIG_USER_ONLY
        2 ( 0.00%)      if (arm_feature(&cpu->env, ARM_FEATURE_EL3)) {
        .                   /* Add the has_el3 state CPU property only if EL3 is allowed.  This will
        .                    * prevent "has_el3" from existing on CPUs which cannot support EL3.
        .                    */
        .                   qdev_property_add_static(DEVICE(obj), &arm_cpu_has_el3_property);
        .           
        .                   object_property_add_link(obj, "secure-memory",
        .                                            TYPE_MEMORY_REGION,
        .                                            (Object **)&cpu->secure_memory,
        .                                            qdev_prop_allow_set_link_before_realize,
        .                                            OBJ_PROP_LINK_STRONG);
        .               }
        .           
        2 ( 0.00%)      if (arm_feature(&cpu->env, ARM_FEATURE_EL2)) {
        .                   qdev_property_add_static(DEVICE(obj), &arm_cpu_has_el2_property);
        .               }
        .           #endif
        .           
        2 ( 0.00%)      if (arm_feature(&cpu->env, ARM_FEATURE_PMU)) {
        .                   cpu->has_pmu = true;
        .                   object_property_add_bool(obj, "pmu", arm_get_pmu, arm_set_pmu);
        .               }
        .           
        .               /*
        .                * Allow user to turn off VFP and Neon support, but only for TCG --
        .                * KVM does not currently allow us to lie to the guest about its
        .                * ID/feature registers, so the guest always sees what the host has.
        .                */
        5 ( 0.00%)      if (arm_feature(&cpu->env, ARM_FEATURE_AARCH64)
        .                   ? cpu_isar_feature(aa64_fp_simd, cpu)
        .                   : cpu_isar_feature(aa32_vfp, cpu)) {
        1 ( 0.00%)          cpu->has_vfp = true;
        .                   if (!kvm_enabled()) {
        2 ( 0.00%)              qdev_property_add_static(DEVICE(obj), &arm_cpu_has_vfp_property);
    3,211 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/qdev-properties.c:qdev_property_add_static (1x)
        .                   }
        .               }
        .           
        2 ( 0.00%)      if (arm_feature(&cpu->env, ARM_FEATURE_NEON)) {
        .                   cpu->has_neon = true;
        .                   if (!kvm_enabled()) {
        .                       qdev_property_add_static(DEVICE(obj), &arm_cpu_has_neon_property);
        .                   }
        .               }
        .           
        4 ( 0.00%)      if (arm_feature(&cpu->env, ARM_FEATURE_M) &&
        .                   arm_feature(&cpu->env, ARM_FEATURE_THUMB_DSP)) {
        2 ( 0.00%)          qdev_property_add_static(DEVICE(obj), &arm_cpu_has_dsp_property);
    3,416 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/qdev-properties.c:qdev_property_add_static (1x)
        .               }
        .           
        2 ( 0.00%)      if (arm_feature(&cpu->env, ARM_FEATURE_PMSA)) {
        2 ( 0.00%)          qdev_property_add_static(DEVICE(obj), &arm_cpu_has_mpu_property);
    3,885 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/qdev-properties.c:qdev_property_add_static (1x)
        2 ( 0.00%)          if (arm_feature(&cpu->env, ARM_FEATURE_V7)) {
        2 ( 0.00%)              qdev_property_add_static(DEVICE(obj),
    3,716 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/qdev-properties.c:qdev_property_add_static (1x)
        .                                                &arm_cpu_pmsav7_dregion_property);
        .                   }
        .               }
        .           
        2 ( 0.00%)      if (arm_feature(&cpu->env, ARM_FEATURE_M_SECURITY)) {
        .                   object_property_add_link(obj, "idau", TYPE_IDAU_INTERFACE, &cpu->idau,
        .                                            qdev_prop_allow_set_link_before_realize,
        .                                            OBJ_PROP_LINK_STRONG);
        .                   /*
        .                    * M profile: initial value of the Secure VTOR. We can't just use
        .                    * a simple DEFINE_PROP_UINT32 for this because we want to permit
        .                    * the property to be set after realize.
        .                    */
        .                   object_property_add_uint32_ptr(obj, "init-svtor",
        .                                                  &cpu->init_svtor,
        .                                                  OBJ_PROP_FLAG_READWRITE);
        .               }
        2 ( 0.00%)      if (arm_feature(&cpu->env, ARM_FEATURE_M)) {
        .                   /*
        .                    * Initial value of the NS VTOR (for cores without the Security
        .                    * extension, this is the only VTOR)
        .                    */
        5 ( 0.00%)          object_property_add_uint32_ptr(obj, "init-nsvtor",
    5,059 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_add_uint32_ptr (1x)
        1 ( 0.00%)                                         &cpu->init_nsvtor,
        .                                                  OBJ_PROP_FLAG_READWRITE);
        .               }
        .           
        .               /* Not DEFINE_PROP_UINT32: we want this to be settable after realize */
        4 ( 0.00%)      object_property_add_uint32_ptr(obj, "psci-conduit",
    2,181 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_add_uint32_ptr (1x)
        1 ( 0.00%)                                     &cpu->psci_conduit,
        .                                              OBJ_PROP_FLAG_READWRITE);
        .           
        2 ( 0.00%)      qdev_property_add_static(DEVICE(obj), &arm_cpu_cfgend_property);
    3,683 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/qdev-properties.c:qdev_property_add_static (1x)
        .           
        2 ( 0.00%)      if (arm_feature(&cpu->env, ARM_FEATURE_GENERIC_TIMER)) {
        .                   qdev_property_add_static(DEVICE(cpu), &arm_cpu_gt_cntfrq_property);
        .               }
        .           
        .               if (kvm_enabled()) {
        .                   kvm_arm_add_vcpu_properties(obj);
        .               }
        .           
        .           #ifndef CONFIG_USER_ONLY
        2 ( 0.00%)      if (arm_feature(&cpu->env, ARM_FEATURE_AARCH64) &&
        .                   cpu_isar_feature(aa64_mte, cpu)) {
        .                   object_property_add_link(obj, "tag-memory",
        .                                            TYPE_MEMORY_REGION,
        .                                            (Object **)&cpu->tag_memory,
        .                                            qdev_prop_allow_set_link_before_realize,
        .                                            OBJ_PROP_LINK_STRONG);
        .           
        .                   if (arm_feature(&cpu->env, ARM_FEATURE_EL3)) {
-- line 1456 ----------------------------------------
-- line 1457 ----------------------------------------
        .                       object_property_add_link(obj, "secure-tag-memory",
        .                                                TYPE_MEMORY_REGION,
        .                                                (Object **)&cpu->secure_tag_memory,
        .                                                qdev_prop_allow_set_link_before_realize,
        .                                                OBJ_PROP_LINK_STRONG);
        .                   }
        .               }
        .           #endif
        6 ( 0.00%)  }
        .           
        .           static void arm_cpu_finalizefn(Object *obj)
        .           {
        .               ARMCPU *cpu = ARM_CPU(obj);
        .               ARMELChangeHook *hook, *next;
        .           
        .               g_hash_table_destroy(cpu->cp_regs);
        .           
-- line 1473 ----------------------------------------
-- line 1482 ----------------------------------------
        .           #ifndef CONFIG_USER_ONLY
        .               if (cpu->pmu_timer) {
        .                   timer_free(cpu->pmu_timer);
        .               }
        .           #endif
        .           }
        .           
        .           void arm_cpu_finalize_features(ARMCPU *cpu, Error **errp)
        1 ( 0.00%)  {
        .               Error *local_err = NULL;
        .           
        .           #ifdef TARGET_AARCH64
        .               if (arm_feature(&cpu->env, ARM_FEATURE_AARCH64)) {
        .                   arm_cpu_sve_finalize(cpu, &local_err);
        .                   if (local_err != NULL) {
        .                       error_propagate(errp, local_err);
        .                       return;
-- line 1498 ----------------------------------------
-- line 1520 ----------------------------------------
        .           
        .               if (kvm_enabled()) {
        .                   kvm_arm_steal_time_finalize(cpu, &local_err);
        .                   if (local_err != NULL) {
        .                       error_propagate(errp, local_err);
        .                       return;
        .                   }
        .               }
        1 ( 0.00%)  }
        .           
        .           static void arm_cpu_realizefn(DeviceState *dev, Error **errp)
       13 ( 0.00%)  {
        .               CPUState *cs = CPU(dev);
        .               ARMCPU *cpu = ARM_CPU(dev);
        .               ARMCPUClass *acc = ARM_CPU_GET_CLASS(dev);
        .               CPUARMState *env = &cpu->env;
        .               int pagebits;
        1 ( 0.00%)      Error *local_err = NULL;
        .               bool no_aa32 = false;
        .           
        .               /* If we needed to query the host kernel for the CPU features
        .                * then it's possible that might have failed in the initfn, but
        .                * this is the first point where we can report it.
        .                */
        2 ( 0.00%)      if (cpu->host_cpu_probe_failed) {
        .                   if (!kvm_enabled() && !hvf_enabled()) {
        .                       error_setg(errp, "The 'host' CPU type can only be used with KVM or HVF");
        .                   } else {
        .                       error_setg(errp, "Failed to retrieve host CPU features");
        .                   }
        .                   return;
        .               }
        .           
        .           #ifndef CONFIG_USER_ONLY
        .               /* The NVIC and M-profile CPU are two halves of a single piece of
        .                * hardware; trying to use one without the other is a command line
        .                * error and will result in segfaults if not caught here.
        .                */
        2 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_M)) {
        3 ( 0.00%)          if (!env->nvic) {
        .                       error_setg(errp, "This board cannot be used with Cortex-M CPUs");
        .                       return;
        .                   }
        .               } else {
        .                   if (env->nvic) {
        .                       error_setg(errp, "This board can only be used with Cortex-M CPUs");
        .                       return;
        .                   }
        .               }
        .           
        3 ( 0.00%)      if (!tcg_enabled() && !qtest_enabled()) {
        .                   /*
        .                    * We assume that no accelerator except TCG (and the "not really an
        .                    * accelerator" qtest) can handle these features, because Arm hardware
        .                    * virtualization can't virtualize them.
        .                    *
        .                    * Catch all the cases which might cause us to create more than one
        .                    * address space for the CPU (otherwise we will assert() later in
        .                    * cpu_address_space_init()).
-- line 1578 ----------------------------------------
-- line 1595 ----------------------------------------
        .                                  current_accel_name());
        .                       return;
        .                   }
        .               }
        .           
        .               {
        .                   uint64_t scale;
        .           
        2 ( 0.00%)          if (arm_feature(env, ARM_FEATURE_GENERIC_TIMER)) {
        .                       if (!cpu->gt_cntfrq_hz) {
        .                           error_setg(errp, "Invalid CNTFRQ: %"PRId64"Hz",
        .                                      cpu->gt_cntfrq_hz);
        .                           return;
        .                       }
        .                       scale = gt_cntfrq_period_ns(cpu);
        .                   } else {
        .                       scale = GTIMER_SCALE;
        .                   }
        .           
        1 ( 0.00%)          cpu->gt_timer[GTIMER_PHYS] = timer_new(QEMU_CLOCK_VIRTUAL, scale,
        .                                                          arm_gt_ptimer_cb, cpu);
        1 ( 0.00%)          cpu->gt_timer[GTIMER_VIRT] = timer_new(QEMU_CLOCK_VIRTUAL, scale,
        .                                                          arm_gt_vtimer_cb, cpu);
        1 ( 0.00%)          cpu->gt_timer[GTIMER_HYP] = timer_new(QEMU_CLOCK_VIRTUAL, scale,
        .                                                         arm_gt_htimer_cb, cpu);
        1 ( 0.00%)          cpu->gt_timer[GTIMER_SEC] = timer_new(QEMU_CLOCK_VIRTUAL, scale,
        .                                                         arm_gt_stimer_cb, cpu);
        1 ( 0.00%)          cpu->gt_timer[GTIMER_HYPVIRT] = timer_new(QEMU_CLOCK_VIRTUAL, scale,
        .                                                             arm_gt_hvtimer_cb, cpu);
        .               }
        .           #endif
        .           
        4 ( 0.00%)      cpu_exec_realizefn(cs, &local_err);
  191,228 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../cpu.c:cpu_exec_realizefn (1x)
        4 ( 0.00%)      if (local_err != NULL) {
        .                   error_propagate(errp, local_err);
        .                   return;
        .               }
        .           
        3 ( 0.00%)      arm_cpu_finalize_features(cpu, &local_err);
        2 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/cpu.c:arm_cpu_finalize_features (1x)
        3 ( 0.00%)      if (local_err != NULL) {
        .                   error_propagate(errp, local_err);
        .                   return;
        .               }
        .           
        2 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_AARCH64) &&
        2 ( 0.00%)          cpu->has_vfp != cpu->has_neon) {
        .                   /*
        .                    * This is an architectural requirement for AArch64; AArch32 is
        .                    * more flexible and permits VFP-no-Neon and Neon-no-VFP.
        .                    */
        .                   error_setg(errp,
        .                              "AArch64 CPUs must have both VFP and Neon or neither");
        .                   return;
        .               }
        .           
        2 ( 0.00%)      if (!cpu->has_vfp) {
        .                   uint64_t t;
        .                   uint32_t u;
        .           
        .                   t = cpu->isar.id_aa64isar1;
        .                   t = FIELD_DP64(t, ID_AA64ISAR1, JSCVT, 0);
        .                   cpu->isar.id_aa64isar1 = t;
        .           
        .                   t = cpu->isar.id_aa64pfr0;
-- line 1658 ----------------------------------------
-- line 1676 ----------------------------------------
        .                   }
        .                   cpu->isar.mvfr0 = u;
        .           
        .                   u = cpu->isar.mvfr1;
        .                   u = FIELD_DP32(u, MVFR1, FPFTZ, 0);
        .                   u = FIELD_DP32(u, MVFR1, FPDNAN, 0);
        .                   u = FIELD_DP32(u, MVFR1, FPHP, 0);
        .                   if (arm_feature(env, ARM_FEATURE_M)) {
        2 ( 0.00%)              u = FIELD_DP32(u, MVFR1, FP16, 0);
        .                   }
        .                   cpu->isar.mvfr1 = u;
        .           
        .                   u = cpu->isar.mvfr2;
        .                   u = FIELD_DP32(u, MVFR2, FPMISC, 0);
        .                   cpu->isar.mvfr2 = u;
        .               }
        .           
        2 ( 0.00%)      if (!cpu->has_neon) {
        .                   uint64_t t;
        .                   uint32_t u;
        .           
        .                   unset_feature(env, ARM_FEATURE_NEON);
        .           
        1 ( 0.00%)          t = cpu->isar.id_aa64isar0;
        .                   t = FIELD_DP64(t, ID_AA64ISAR0, AES, 0);
        .                   t = FIELD_DP64(t, ID_AA64ISAR0, SHA1, 0);
        .                   t = FIELD_DP64(t, ID_AA64ISAR0, SHA2, 0);
        .                   t = FIELD_DP64(t, ID_AA64ISAR0, SHA3, 0);
        .                   t = FIELD_DP64(t, ID_AA64ISAR0, SM3, 0);
        .                   t = FIELD_DP64(t, ID_AA64ISAR0, SM4, 0);
        .                   t = FIELD_DP64(t, ID_AA64ISAR0, DP, 0);
        .                   cpu->isar.id_aa64isar0 = t;
        .           
        1 ( 0.00%)          t = cpu->isar.id_aa64isar1;
        .                   t = FIELD_DP64(t, ID_AA64ISAR1, FCMA, 0);
        .                   t = FIELD_DP64(t, ID_AA64ISAR1, BF16, 0);
        .                   t = FIELD_DP64(t, ID_AA64ISAR1, I8MM, 0);
        .                   cpu->isar.id_aa64isar1 = t;
        .           
        .                   t = cpu->isar.id_aa64pfr0;
        .                   t = FIELD_DP64(t, ID_AA64PFR0, ADVSIMD, 0xf);
        .                   cpu->isar.id_aa64pfr0 = t;
-- line 1717 ----------------------------------------
-- line 1726 ----------------------------------------
        .           
        .                   u = cpu->isar.id_isar6;
        .                   u = FIELD_DP32(u, ID_ISAR6, DP, 0);
        .                   u = FIELD_DP32(u, ID_ISAR6, FHM, 0);
        .                   u = FIELD_DP32(u, ID_ISAR6, BF16, 0);
        .                   u = FIELD_DP32(u, ID_ISAR6, I8MM, 0);
        .                   cpu->isar.id_isar6 = u;
        .           
        2 ( 0.00%)          if (!arm_feature(env, ARM_FEATURE_M)) {
        .                       u = cpu->isar.mvfr1;
        .                       u = FIELD_DP32(u, MVFR1, SIMDLS, 0);
        .                       u = FIELD_DP32(u, MVFR1, SIMDINT, 0);
        .                       u = FIELD_DP32(u, MVFR1, SIMDSP, 0);
        .                       u = FIELD_DP32(u, MVFR1, SIMDHP, 0);
        .                       cpu->isar.mvfr1 = u;
        .           
        .                       u = cpu->isar.mvfr2;
        .                       u = FIELD_DP32(u, MVFR2, SIMDMISC, 0);
        .                       cpu->isar.mvfr2 = u;
        .                   }
        .               }
        .           
        2 ( 0.00%)      if (!cpu->has_neon && !cpu->has_vfp) {
        .                   uint64_t t;
        .                   uint32_t u;
        .           
        .                   t = cpu->isar.id_aa64isar0;
        .                   t = FIELD_DP64(t, ID_AA64ISAR0, FHM, 0);
        .                   cpu->isar.id_aa64isar0 = t;
        .           
        .                   t = cpu->isar.id_aa64isar1;
-- line 1756 ----------------------------------------
-- line 1762 ----------------------------------------
        .                   cpu->isar.mvfr0 = u;
        .           
        .                   /* Despite the name, this field covers both VFP and Neon */
        .                   u = cpu->isar.mvfr1;
        .                   u = FIELD_DP32(u, MVFR1, SIMDFMAC, 0);
        .                   cpu->isar.mvfr1 = u;
        .               }
        .           
        2 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_M) && !cpu->has_dsp) {
        .                   uint32_t u;
        .           
        .                   unset_feature(env, ARM_FEATURE_THUMB_DSP);
        .           
        .                   u = cpu->isar.id_isar1;
        .                   u = FIELD_DP32(u, ID_ISAR1, EXTEND, 1);
        .                   cpu->isar.id_isar1 = u;
        .           
-- line 1778 ----------------------------------------
-- line 1783 ----------------------------------------
        .           
        .                   u = cpu->isar.id_isar3;
        .                   u = FIELD_DP32(u, ID_ISAR3, SIMD, 1);
        .                   u = FIELD_DP32(u, ID_ISAR3, SATURATE, 0);
        .                   cpu->isar.id_isar3 = u;
        .               }
        .           
        .               /* Some features automatically imply others: */
        3 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_V8)) {
        .                   if (arm_feature(env, ARM_FEATURE_M)) {
        .                       set_feature(env, ARM_FEATURE_V7);
        .                   } else {
        .                       set_feature(env, ARM_FEATURE_V7VE);
        .                   }
        .               }
        .           
        .               /*
        .                * There exist AArch64 cpus without AArch32 support.  When KVM
        .                * queries ID_ISAR0_EL1 on such a host, the value is UNKNOWN.
        .                * Similarly, we cannot check ID_AA64PFR0 without AArch64 support.
        .                * As a general principle, we also do not make ID register
        .                * consistency checks anywhere unless using TCG, because only
        .                * for TCG would a consistency-check failure be a QEMU bug.
        .                */
        2 ( 0.00%)      if (arm_feature(&cpu->env, ARM_FEATURE_AARCH64)) {
        .                   no_aa32 = !cpu_isar_feature(aa64_aa32, cpu);
        .               }
        .           
        2 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_V7VE)) {
        .                   /* v7 Virtualization Extensions. In real hardware this implies
        .                    * EL2 and also the presence of the Security Extensions.
        .                    * For QEMU, for backwards-compatibility we implement some
        .                    * CPUs or CPU configs which have no actual EL2 or EL3 but do
        .                    * include the various other features that V7VE implies.
        .                    * Presence of EL2 itself is ARM_FEATURE_EL2, and of the
        .                    * Security Extensions is ARM_FEATURE_EL3.
        .                    */
        .                   assert(!tcg_enabled() || no_aa32 ||
        .                          cpu_isar_feature(aa32_arm_div, cpu));
        .                   set_feature(env, ARM_FEATURE_LPAE);
        .                   set_feature(env, ARM_FEATURE_V7);
        .               }
        2 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_V7)) {
        .                   set_feature(env, ARM_FEATURE_VAPA);
        .                   set_feature(env, ARM_FEATURE_THUMB2);
        .                   set_feature(env, ARM_FEATURE_MPIDR);
        .                   if (!arm_feature(env, ARM_FEATURE_M)) {
        .                       set_feature(env, ARM_FEATURE_V6K);
        .                   } else {
        .                       set_feature(env, ARM_FEATURE_V6);
        .                   }
        .           
        .                   /* Always define VBAR for V7 CPUs even if it doesn't exist in
        .                    * non-EL3 configs. This is needed by some legacy boards.
        .                    */
        .                   set_feature(env, ARM_FEATURE_VBAR);
        .               }
        2 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_V6K)) {
        .                   set_feature(env, ARM_FEATURE_V6);
        .                   set_feature(env, ARM_FEATURE_MVFR);
        .               }
        2 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_V6)) {
        .                   set_feature(env, ARM_FEATURE_V5);
        2 ( 0.00%)          if (!arm_feature(env, ARM_FEATURE_M)) {
        .                       assert(!tcg_enabled() || no_aa32 ||
        .                              cpu_isar_feature(aa32_jazelle, cpu));
        .                       set_feature(env, ARM_FEATURE_AUXCR);
        .                   }
        .               }
        2 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_V5)) {
        .                   set_feature(env, ARM_FEATURE_V4T);
        .               }
        2 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_LPAE)) {
        .                   set_feature(env, ARM_FEATURE_V7MP);
        .               }
        2 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_CBAR_RO)) {
        .                   set_feature(env, ARM_FEATURE_CBAR);
        .               }
        4 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_THUMB2) &&
        .                   !arm_feature(env, ARM_FEATURE_M)) {
        .                   set_feature(env, ARM_FEATURE_THUMB_DSP);
        .               }
        .           
        .               /*
        .                * We rely on no XScale CPU having VFP so we can use the same bits in the
        .                * TB flags field for VECSTRIDE and XSCALE_CPAR.
        .                */
        6 ( 0.00%)      assert(arm_feature(&cpu->env, ARM_FEATURE_AARCH64) ||
        .                      !cpu_isar_feature(aa32_vfp_simd, cpu) ||
        .                      !arm_feature(env, ARM_FEATURE_XSCALE));
        .           
        4 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_V7) &&
        .                   !arm_feature(env, ARM_FEATURE_M) &&
        .                   !arm_feature(env, ARM_FEATURE_PMSA)) {
        .                   /* v7VMSA drops support for the old ARMv5 tiny pages, so we
        .                    * can use 4K pages.
        .                    */
        .                   pagebits = 12;
        .               } else {
        .                   /* For CPUs which might have tiny 1K pages, or which have an
        .                    * MPU and might have small region sizes, stick with 1K pages.
        .                    */
        1 ( 0.00%)          pagebits = 10;
        .               }
        3 ( 0.00%)      if (!set_preferred_target_page_bits(pagebits)) {
       15 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../page-vary.c:set_preferred_target_page_bits (1x)
        .                   /* This can only ever happen for hotplugging a CPU, or if
        .                    * the board code incorrectly creates a CPU which it has
        .                    * promised via minimum_page_size that it will not.
        .                    */
        .                   error_setg(errp, "This CPU requires a smaller page size than the "
        .                              "system is using");
        .                   return;
        .               }
        .           
        .               /* This cpu-id-to-MPIDR affinity is used only for TCG; KVM will override it.
        .                * We don't support setting cluster ID ([16..23]) (known as Aff2
        .                * in later ARM ARM versions), or any of the higher affinity level fields,
        .                * so these bits always RAZ.
        .                */
        3 ( 0.00%)      if (cpu->mp_affinity == ARM64_AFFINITY_INVALID) {
        5 ( 0.00%)          cpu->mp_affinity = arm_cpu_mp_affinity(cs->cpu_index,
        8 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/cpu.c:arm_cpu_mp_affinity (1x)
        .                                                          ARM_DEFAULT_CPUS_PER_CLUSTER);
        .               }
        .           
        2 ( 0.00%)      if (cpu->reset_hivecs) {
        .                       cpu->reset_sctlr |= (1 << 13);
        .               }
        .           
        2 ( 0.00%)      if (cpu->cfgend) {
        .                   if (arm_feature(&cpu->env, ARM_FEATURE_V7)) {
        .                       cpu->reset_sctlr |= SCTLR_EE;
        .                   } else {
        .                       cpu->reset_sctlr |= SCTLR_B;
        .                   }
        .               }
        .           
        2 ( 0.00%)      if (!arm_feature(env, ARM_FEATURE_M) && !cpu->has_el3) {
        .                   /* If the has_el3 CPU property is disabled then we need to disable the
        .                    * feature.
        .                    */
        .                   unset_feature(env, ARM_FEATURE_EL3);
        .           
        .                   /*
        .                    * Disable the security extension feature bits in the processor
        .                    * feature registers as well.
        .                    */
        .                   cpu->isar.id_pfr1 = FIELD_DP32(cpu->isar.id_pfr1, ID_PFR1, SECURITY, 0);
        .                   cpu->isar.id_dfr0 = FIELD_DP32(cpu->isar.id_dfr0, ID_DFR0, COPSDBG, 0);
        .                   cpu->isar.id_aa64pfr0 = FIELD_DP64(cpu->isar.id_aa64pfr0,
        .                                                      ID_AA64PFR0, EL3, 0);
        .               }
        .           
        2 ( 0.00%)      if (!cpu->has_el2) {
        .                   unset_feature(env, ARM_FEATURE_EL2);
        .               }
        .           
        2 ( 0.00%)      if (!cpu->has_pmu) {
        .                   unset_feature(env, ARM_FEATURE_PMU);
        .               }
        2 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_PMU)) {
        .                   pmu_init(cpu);
        .           
        .                   if (!kvm_enabled()) {
        .                       arm_register_pre_el_change_hook(cpu, &pmu_pre_el_change, 0);
        .                       arm_register_el_change_hook(cpu, &pmu_post_el_change, 0);
        .                   }
        .           
        .           #ifndef CONFIG_USER_ONLY
        .                   cpu->pmu_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, arm_pmu_timer_cb,
        .                           cpu);
        .           #endif
        .               } else {
        .                   cpu->isar.id_aa64dfr0 =
        .                       FIELD_DP64(cpu->isar.id_aa64dfr0, ID_AA64DFR0, PMUVER, 0);
        .                   cpu->isar.id_dfr0 = FIELD_DP32(cpu->isar.id_dfr0, ID_DFR0, PERFMON, 0);
        1 ( 0.00%)          cpu->pmceid0 = 0;
        1 ( 0.00%)          cpu->pmceid1 = 0;
        .               }
        .           
        2 ( 0.00%)      if (!arm_feature(env, ARM_FEATURE_EL2)) {
        .                   /*
        .                    * Disable the hypervisor feature bits in the processor feature
        .                    * registers if we don't have EL2.
        .                    */
        .                   cpu->isar.id_aa64pfr0 = FIELD_DP64(cpu->isar.id_aa64pfr0,
        .                                                      ID_AA64PFR0, EL2, 0);
        .                   cpu->isar.id_pfr1 = FIELD_DP32(cpu->isar.id_pfr1,
        .                                                  ID_PFR1, VIRTUALIZATION, 0);
        .               }
        .           
        .           #ifndef CONFIG_USER_ONLY
        4 ( 0.00%)      if (cpu->tag_memory == NULL && cpu_isar_feature(aa64_mte, cpu)) {
        .                   /*
        .                    * Disable the MTE feature bits if we do not have tag-memory
        .                    * provided by the machine.
        .                    */
        .                   cpu->isar.id_aa64pfr1 =
        .                       FIELD_DP64(cpu->isar.id_aa64pfr1, ID_AA64PFR1, MTE, 0);
        .               }
        .           #endif
        .           
        3 ( 0.00%)      if (tcg_enabled()) {
        .                   /*
        .                    * Don't report the Statistical Profiling Extension in the ID
        .                    * registers, because TCG doesn't implement it yet (not even a
        .                    * minimal stub version) and guests will fall over when they
        .                    * try to access the non-existent system registers for it.
        .                    */
        .                   cpu->isar.id_aa64dfr0 =
        .                       FIELD_DP64(cpu->isar.id_aa64dfr0, ID_AA64DFR0, PMSVER, 0);
        .               }
        .           
        .               /* MPU can be configured out of a PMSA CPU either by setting has-mpu
        .                * to false or by setting pmsav7-dregion to 0.
        .                */
        2 ( 0.00%)      if (!cpu->has_mpu) {
        .                   cpu->pmsav7_dregion = 0;
        .               }
        3 ( 0.00%)      if (cpu->pmsav7_dregion == 0) {
        .                   cpu->has_mpu = false;
        .               }
        .           
        4 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_PMSA) &&
        .                   arm_feature(env, ARM_FEATURE_V7)) {
        .                   uint32_t nr = cpu->pmsav7_dregion;
        .           
        2 ( 0.00%)          if (nr > 0xff) {
        .                       error_setg(errp, "PMSAv7 MPU #regions invalid %" PRIu32, nr);
        .                       return;
        .                   }
        .           
        .                   if (nr) {
        2 ( 0.00%)              if (arm_feature(env, ARM_FEATURE_V8)) {
        .                           /* PMSAv8 */
        1 ( 0.00%)                  env->pmsav8.rbar[M_REG_NS] = g_new0(uint32_t, nr);
        .                           env->pmsav8.rlar[M_REG_NS] = g_new0(uint32_t, nr);
        .                           if (arm_feature(env, ARM_FEATURE_M_SECURITY)) {
        .                               env->pmsav8.rbar[M_REG_S] = g_new0(uint32_t, nr);
        .                               env->pmsav8.rlar[M_REG_S] = g_new0(uint32_t, nr);
        .                           }
        .                       } else {
        4 ( 0.00%)                  env->pmsav7.drbar = g_new0(uint32_t, nr);
      260 ( 0.00%)  => ???:0x0000000004e3ca40 (1x)
        4 ( 0.00%)                  env->pmsav7.drsr = g_new0(uint32_t, nr);
      260 ( 0.00%)  => ???:0x0000000004e3ca40 (1x)
        4 ( 0.00%)                  env->pmsav7.dracr = g_new0(uint32_t, nr);
      260 ( 0.00%)  => ???:0x0000000004e3ca40 (1x)
        .                       }
        .                   }
        .               }
        .           
        2 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_M_SECURITY)) {
        .                   uint32_t nr = cpu->sau_sregion;
        .           
        .                   if (nr > 0xff) {
        .                       error_setg(errp, "v8M SAU #regions invalid %" PRIu32, nr);
        .                       return;
        .                   }
        .           
        .                   if (nr) {
        .                       env->sau.rbar = g_new0(uint32_t, nr);
        .                       env->sau.rlar = g_new0(uint32_t, nr);
        .                   }
        .               }
        .           
        2 ( 0.00%)      if (arm_feature(env, ARM_FEATURE_EL3)) {
        .                   set_feature(env, ARM_FEATURE_VBAR);
        .               }
        .           
        2 ( 0.00%)      register_cp_regs_for_features(cpu);
       26 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:register_cp_regs_for_features (1x)
        2 ( 0.00%)      arm_cpu_register_gdb_regs_for_features(cpu);
    4,599 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/gdbstub.c:arm_cpu_register_gdb_regs_for_features (1x)
        .           
        2 ( 0.00%)      init_cpreg_list(cpu);
      258 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/helper.c:init_cpreg_list (1x)
        .           
        .           #ifndef CONFIG_USER_ONLY
        2 ( 0.00%)      MachineState *ms = MACHINE(qdev_get_machine());
        5 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/qdev.c:qdev_get_machine (1x)
        1 ( 0.00%)      unsigned int smp_cpus = ms->smp.cpus;
        4 ( 0.00%)      bool has_secure = cpu->has_el3 || arm_feature(env, ARM_FEATURE_M_SECURITY);
        .           
        .               /*
        .                * We must set cs->num_ases to the final value before
        .                * the first call to cpu_address_space_init.
        .                */
        2 ( 0.00%)      if (cpu->tag_memory != NULL) {
        1 ( 0.00%)          cs->num_ases = 3 + has_secure;
        .               } else {
        1 ( 0.00%)          cs->num_ases = 1 + has_secure;
        .               }
        .           
        2 ( 0.00%)      if (has_secure) {
        .                   if (!cpu->secure_memory) {
        .                       cpu->secure_memory = cs->memory;
        .                   }
        .                   cpu_address_space_init(cs, ARMASIdx_S, "cpu-secure-memory",
        .                                          cpu->secure_memory);
        .               }
        .           
        3 ( 0.00%)      if (cpu->tag_memory != NULL) {
        .                   cpu_address_space_init(cs, ARMASIdx_TagNS, "cpu-tag-memory",
        .                                          cpu->tag_memory);
        .                   if (has_secure) {
        .                       cpu_address_space_init(cs, ARMASIdx_TagS, "cpu-tag-memory",
        .                                              cpu->secure_tag_memory);
        .                   }
        .               }
        .           
        5 ( 0.00%)      cpu_address_space_init(cs, ARMASIdx_NS, "cpu-memory", cs->memory);
   19,518 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:cpu_address_space_init (1x)
        .           
        .               /* No core_count specified, default to smp_cpus. */
        2 ( 0.00%)      if (cpu->core_count == -1) {
        1 ( 0.00%)          cpu->core_count = smp_cpus;
        .               }
        .           #endif
        .           
        3 ( 0.00%)      if (tcg_enabled()) {
        3 ( 0.00%)          int dcz_blocklen = 4 << cpu->dcz_blocksize;
        .           
        .                   /*
        .                    * We only support DCZ blocklen that fits on one page.
        .                    *
        .                    * Architectually this is always true.  However TARGET_PAGE_SIZE
        .                    * is variable and, for compatibility with -machine virt-2.7,
        .                    * is only 1KiB, as an artifact of legacy ARMv5 subpage support.
        .                    * But even then, while the largest architectural DCZ blocklen
        .                    * is 2KiB, no cpu actually uses such a large blocklen.
        .                    */
        5 ( 0.00%)          assert(dcz_blocklen <= TARGET_PAGE_SIZE);
        .           
        .                   /*
        .                    * We only support DCZ blocksize >= 2*TAG_GRANULE, which is to say
        .                    * both nibbles of each byte storing tag data may be written at once.
        .                    * Since TAG_GRANULE is 16, this means that blocklen must be >= 32.
        .                    */
        .                   if (cpu_isar_feature(aa64_mte, cpu)) {
        2 ( 0.00%)              assert(dcz_blocklen >= 2 * TAG_GRANULE);
        .                   }
        .               }
        .           
        2 ( 0.00%)      qemu_init_vcpu(cs);
      670 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:qemu_init_vcpu (1x)
        2 ( 0.00%)      cpu_reset(cs);
   38,910 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/cpu-common.c:cpu_reset (1x)
        .           
        6 ( 0.00%)      acc->parent_realize(dev, errp);
   65,876 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/cpu-common.c:cpu_common_realizefn (1x)
       11 ( 0.00%)  }
        .           
        .           static ObjectClass *arm_cpu_class_by_name(const char *cpu_model)
        .           {
        .               ObjectClass *oc;
        .               char *typename;
        .               char **cpuname;
        .               const char *cpunamestr;
        .           
-- line 2130 ----------------------------------------
-- line 2201 ----------------------------------------
        .               .adjust_watchpoint_address = arm_adjust_watchpoint_address,
        .               .debug_check_watchpoint = arm_debug_check_watchpoint,
        .               .debug_check_breakpoint = arm_debug_check_breakpoint,
        .           #endif /* !CONFIG_USER_ONLY */
        .           };
        .           #endif /* CONFIG_TCG */
        .           
        .           static void arm_cpu_class_init(ObjectClass *oc, void *data)
        5 ( 0.00%)  {
        .               ARMCPUClass *acc = ARM_CPU_CLASS(oc);
        .               CPUClass *cc = CPU_CLASS(acc);
        .               DeviceClass *dc = DEVICE_CLASS(oc);
        .           
        4 ( 0.00%)      device_class_set_parent_realize(dc, arm_cpu_realizefn,
        5 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/qdev.c:device_class_set_parent_realize (1x)
        .                                               &acc->parent_realize);
        .           
        3 ( 0.00%)      device_class_set_props(dc, arm_cpu_properties);
    8,907 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/qdev-properties.c:device_class_set_props (1x)
        4 ( 0.00%)      device_class_set_parent_reset(dc, arm_cpu_reset, &acc->parent_reset);
        5 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/qdev.c:device_class_set_parent_reset (1x)
        .           
        2 ( 0.00%)      cc->class_by_name = arm_cpu_class_by_name;
        2 ( 0.00%)      cc->has_work = arm_cpu_has_work;
        2 ( 0.00%)      cc->dump_state = arm_cpu_dump_state;
        2 ( 0.00%)      cc->set_pc = arm_cpu_set_pc;
        2 ( 0.00%)      cc->get_pc = arm_cpu_get_pc;
        2 ( 0.00%)      cc->gdb_read_register = arm_cpu_gdb_read_register;
        2 ( 0.00%)      cc->gdb_write_register = arm_cpu_gdb_write_register;
        .           #ifndef CONFIG_USER_ONLY
        2 ( 0.00%)      cc->sysemu_ops = &arm_sysemu_ops;
        .           #endif
        1 ( 0.00%)      cc->gdb_num_core_regs = 26;
        2 ( 0.00%)      cc->gdb_core_xml_file = "arm-core.xml";
        2 ( 0.00%)      cc->gdb_arch_name = arm_gdb_arch_name;
        2 ( 0.00%)      cc->gdb_get_dynamic_xml = arm_gdb_get_dynamic_xml;
        1 ( 0.00%)      cc->gdb_stop_before_watchpoint = true;
        2 ( 0.00%)      cc->disas_set_info = arm_disas_set_info;
        .           
        .           #ifdef CONFIG_TCG
        2 ( 0.00%)      cc->tcg_ops = &arm_tcg_ops;
        .           #endif /* CONFIG_TCG */
        4 ( 0.00%)  }
        .           
        .           static void arm_cpu_instance_init(Object *obj)
        3 ( 0.00%)  {
        .               ARMCPUClass *acc = ARM_CPU_GET_CLASS(obj);
        .           
        3 ( 0.00%)      acc->info->initfn(obj);
       33 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/cpu_tcg.c:cortex_m7_initfn (1x)
        2 ( 0.00%)      arm_cpu_post_init(obj);
   25,300 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/cpu.c:arm_cpu_post_init (1x)
        1 ( 0.00%)  }
        .           
        .           static void cpu_register_class_init(ObjectClass *oc, void *data)
       87 ( 0.00%)  {
        .               ARMCPUClass *acc = ARM_CPU_CLASS(oc);
        .           
       29 ( 0.00%)      acc->info = data;
       58 ( 0.00%)  }
        .           
        .           void arm_cpu_register(const ARMCPUInfo *info)
      245 ( 0.00%)  {
      910 ( 0.00%)      TypeInfo type_info = {
        .                   .parent = TYPE_ARM_CPU,
        .                   .instance_size = sizeof(ARMCPU),
        .                   .instance_align = __alignof__(ARMCPU),
        .                   .instance_init = arm_cpu_instance_init,
        .                   .class_size = sizeof(ARMCPUClass),
      140 ( 0.00%)          .class_init = info->class_init ?: cpu_register_class_init,
        .                   .class_data = (void *)info,
        .               };
        .           
      175 ( 0.00%)      type_info.name = g_strdup_printf("%s-" TYPE_ARM_CPU, info->name);
   32,368 ( 0.00%)  => ???:0x0000000004e3b7e0 (35x)
       70 ( 0.00%)      type_register(&type_info);
  140,611 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_register (35x)
       70 ( 0.00%)      g_free((void *)type_info.name);
    3,325 ( 0.00%)  => ???:0x0000000004e3a950 (35x)
      210 ( 0.00%)  }
        .           
        .           static const TypeInfo arm_cpu_type_info = {
        .               .name = TYPE_ARM_CPU,
        .               .parent = TYPE_CPU,
        .               .instance_size = sizeof(ARMCPU),
        .               .instance_align = __alignof__(ARMCPU),
        .               .instance_init = arm_cpu_initfn,
        .               .instance_finalize = arm_cpu_finalizefn,
        .               .abstract = true,
        .               .class_size = sizeof(ARMCPUClass),
        .               .class_init = arm_cpu_class_init,
        .           };
        .           
        .           static void arm_cpu_register_types(void)
        1 ( 0.00%)  {
        2 ( 0.00%)      type_register_static(&arm_cpu_type_info);
    1,751 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_register_static (1x)
        .           }
        .           
        4 ( 0.00%)  type_init(arm_cpu_register_types)
      261 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/module.c:register_module_init (1x)

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/include/qemu/seqlock.h
--------------------------------------------------------------------------------
Ir                  

-- line 21 ----------------------------------------
         .           typedef struct QemuSeqLock QemuSeqLock;
         .           
         .           struct QemuSeqLock {
         .               unsigned sequence;
         .           };
         .           
         .           static inline void seqlock_init(QemuSeqLock *sl)
         .           {
         2 ( 0.00%)      sl->sequence = 0;
         .           }
         .           
         .           /* Lock out other writers and update the count.  */
         .           static inline void seqlock_write_begin(QemuSeqLock *sl)
         .           {
     2,242 ( 0.00%)      qatomic_set(&sl->sequence, sl->sequence + 1);
         .           
         .               /* Write sequence before updating other fields.  */
         .               smp_wmb();
         .           }
         .           
         .           static inline void seqlock_write_end(QemuSeqLock *sl)
         .           {
         .               /* Write other fields before finalizing sequence.  */
         .               smp_wmb();
         .           
     2,241 ( 0.00%)      qatomic_set(&sl->sequence, sl->sequence + 1);
         .           }
         .           
         .           /* Lock out other writers and update the count.  */
         .           static inline void seqlock_write_lock_impl(QemuSeqLock *sl, QemuLockable *lock)
         .           {
         .               qemu_lockable_lock(lock);
         .               seqlock_write_begin(sl);
         .           }
-- line 54 ----------------------------------------
-- line 63 ----------------------------------------
         .           }
         .           #define seqlock_write_unlock(sl, lock) \
         .               seqlock_write_unlock_impl(sl, QEMU_MAKE_LOCKABLE(lock))
         .           
         .           
         .           static inline unsigned seqlock_read_begin(const QemuSeqLock *sl)
         .           {
         .               /* Always fail if a write is in progress.  */
 5,265,902 ( 0.01%)      unsigned ret = qatomic_read(&sl->sequence);
         .           
         .               /* Read sequence before reading other fields.  */
         .               smp_rmb();
10,531,804 ( 0.01%)      return ret & ~1;
         .           }
         .           
         .           static inline int seqlock_read_retry(const QemuSeqLock *sl, unsigned start)
         .           {
         .               /* Read other fields before reading final sequence.  */
         .               smp_rmb();
 5,265,902 ( 0.01%)      return unlikely(qatomic_read(&sl->sequence) != start);
         .           }
         .           
         .           #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/include/qemu/int128.h
--------------------------------------------------------------------------------
Ir                  

-- line 3 ----------------------------------------
         .           
         .           #include "qemu/bswap.h"
         .           
         .           #ifdef CONFIG_INT128
         .           typedef __int128_t Int128;
         .           
         .           static inline Int128 int128_make64(uint64_t a)
         .           {
40,776,264 ( 0.06%)      return a;
         .           }
         .           
         .           static inline Int128 int128_makes64(int64_t a)
         .           {
         .               return a;
         .           }
         .           
         .           static inline Int128 int128_make128(uint64_t lo, uint64_t hi)
         .           {
         .               return (__uint128_t)hi << 64 | lo;
         .           }
         .           
         .           static inline uint64_t int128_get64(Int128 a)
         .           {
       244 ( 0.00%)      uint64_t r = a;
17,370,424 ( 0.02%)      assert(r == a);
         .               return r;
         .           }
         .           
         .           static inline uint64_t int128_getlo(Int128 a)
         .           {
         .               return a;
         .           }
         .           
-- line 35 ----------------------------------------
-- line 60 ----------------------------------------
         .           
         .           static inline Int128 int128_not(Int128 a)
         .           {
         .               return ~a;
         .           }
         .           
         .           static inline Int128 int128_and(Int128 a, Int128 b)
         .           {
       854 ( 0.00%)      return a & b;
         .           }
         .           
         .           static inline Int128 int128_or(Int128 a, Int128 b)
         .           {
         .               return a | b;
         .           }
         .           
         .           static inline Int128 int128_xor(Int128 a, Int128 b)
         .           {
         .               return a ^ b;
         .           }
         .           
         .           static inline Int128 int128_rshift(Int128 a, int n)
         .           {
     1,098 ( 0.00%)      return a >> n;
         .           }
         .           
         .           static inline Int128 int128_urshift(Int128 a, int n)
         .           {
         .               return (__uint128_t)a >> n;
         .           }
         .           
         .           static inline Int128 int128_lshift(Int128 a, int n)
         .           {
         .               return a << n;
         .           }
         .           
         .           static inline Int128 int128_add(Int128 a, Int128 b)
         .           {
     2,466 ( 0.00%)      return a + b;
         .           }
         .           
         .           static inline Int128 int128_neg(Int128 a)
         .           {
       366 ( 0.00%)      return -a;
         .           }
         .           
         .           static inline Int128 int128_sub(Int128 a, Int128 b)
         .           {
34,740,048 ( 0.05%)      return a - b;
         .           }
         .           
         .           static inline bool int128_nonneg(Int128 a)
         .           {
         .               return a >= 0;
         .           }
         .           
         .           static inline bool int128_eq(Int128 a, Int128 b)
-- line 116 ----------------------------------------
-- line 155 ----------------------------------------
         .           
         .           static inline bool int128_nz(Int128 a)
         .           {
         .               return a != 0;
         .           }
         .           
         .           static inline Int128 int128_min(Int128 a, Int128 b)
         .           {
34,741,398 ( 0.05%)      return a < b ? a : b;
         .           }
         .           
         .           static inline Int128 int128_max(Int128 a, Int128 b)
         .           {
     1,260 ( 0.00%)      return a > b ? a : b;
         .           }
         .           
         .           static inline void int128_addto(Int128 *a, Int128 b)
         .           {
       624 ( 0.00%)      *a += b;
         .           }
         .           
         .           static inline void int128_subfrom(Int128 *a, Int128 b)
         .           {
       348 ( 0.00%)      *a -= b;
        86 ( 0.00%)  }
         .           
         .           static inline Int128 bswap128(Int128 a)
         .           {
         .           #if __has_builtin(__builtin_bswap128)
         .               return __builtin_bswap128(a);
         .           #else
         .               return int128_make128(bswap64(int128_gethi(a)), bswap64(int128_getlo(a)));
         .           #endif
-- line 187 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/include/exec/cpu-all.h
--------------------------------------------------------------------------------
Ir                  

-- line 396 ----------------------------------------
         .            * tlb_hit_page: return true if page aligned @addr is a hit against the
         .            * TLB entry @tlb_addr
         .            *
         .            * @addr: virtual address to test (must be page aligned)
         .            * @tlb_addr: TLB entry address (a CPUTLBEntry addr_read/write/code value)
         .            */
         .           static inline bool tlb_hit_page(target_ulong tlb_addr, target_ulong addr)
         .           {
38,671,103 ( 0.05%)      return addr == (tlb_addr & (TARGET_PAGE_MASK | TLB_INVALID_MASK));
         .           }
         .           
         .           /**
         .            * tlb_hit: return true if @addr is a hit against the TLB entry @tlb_addr
         .            *
         .            * @addr: virtual address to test (need not be page aligned)
         .            * @tlb_addr: TLB entry address (a CPUTLBEntry addr_read/write/code value)
         .            */
         .           static inline bool tlb_hit(target_ulong tlb_addr, target_ulong addr)
         .           {
46,675,356 ( 0.06%)      return tlb_hit_page(tlb_addr, addr & TARGET_PAGE_MASK);
         .           }
         .           
         .           #ifdef CONFIG_TCG
         .           /* accel/tcg/translate-all.c */
         .           void dump_exec_info(GString *buf);
         .           #endif /* CONFIG_TCG */
         .           
         .           #endif /* !CONFIG_USER_ONLY */
-- line 423 ----------------------------------------
-- line 430 ----------------------------------------
         .           /**
         .            * cpu_set_cpustate_pointers(cpu)
         .            * @cpu: The cpu object
         .            *
         .            * Set the generic pointers in CPUState into the outer object.
         .            */
         .           static inline void cpu_set_cpustate_pointers(ArchCPU *cpu)
         .           {
         2 ( 0.00%)      cpu->parent_obj.env_ptr = &cpu->env;
         2 ( 0.00%)      cpu->parent_obj.icount_decr_ptr = &cpu->neg.icount_decr;
         .           }
         .           
         .           /**
         .            * env_archcpu(env)
         .            * @env: The architecture environment
         .            *
         .            * Return the ArchCPU associated with the environment.
         .            */
         .           static inline ArchCPU *env_archcpu(CPUArchState *env)
         .           {
     2,830 ( 0.00%)      return container_of(env, ArchCPU, env);
         .           }
         .           
         .           /**
         .            * env_cpu(env)
         .            * @env: The architecture environment
         .            *
         .            * Return the CPUState associated with the environment.
         .            */
         .           static inline CPUState *env_cpu(CPUArchState *env)
         .           {
19,224,194 ( 0.03%)      return &env_archcpu(env)->parent_obj;
         .           }
         .           
         .           /**
         .            * env_neg(env)
         .            * @env: The architecture environment
         .            *
         .            * Return the CPUNegativeOffsetState associated with the environment.
         .            */
-- line 469 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/async.c
--------------------------------------------------------------------------------
Ir                 

-- line 64 ----------------------------------------
        .               void *opaque;
        .               QSLIST_ENTRY(QEMUBH) next;
        .               unsigned flags;
        .           };
        .           
        .           /* Called concurrently from any thread */
        .           static void aio_bh_enqueue(QEMUBH *bh, unsigned new_flags)
        .           {
   18,604 ( 0.00%)      AioContext *ctx = bh->ctx;
        .               unsigned old_flags;
        .           
        .               /*
        .                * The memory barrier implicit in qatomic_fetch_or makes sure that:
        .                * 1. idle & any writes needed by the callback are done before the
        .                *    locations are read in the aio_bh_poll.
        .                * 2. ctx is loaded before the callback has a chance to execute and bh
        .                *    could be freed.
        .                */
  111,624 ( 0.00%)      old_flags = qatomic_fetch_or(&bh->flags, BH_PENDING | new_flags);
   37,208 ( 0.00%)      if (!(old_flags & BH_PENDING)) {
   19,824 ( 0.00%)          QSLIST_INSERT_HEAD_ATOMIC(&ctx->bh_list, bh, next);
        .               }
        .           
   37,208 ( 0.00%)      aio_notify(ctx);
  130,228 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/async.c:aio_notify (18,604x)
        .               /*
        .                * Workaround for record/replay.
        .                * vCPU execution should be suspended when new BH is set.
        .                * This is needed to avoid guest timeouts caused
        .                * by the long cycles of the execution.
        .                */
   18,604 ( 0.00%)      icount_notify_exit();
  111,624 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/icount.c:icount_notify_exit (18,604x)
        .           }
        .           
        .           /* Only called from aio_bh_poll() and aio_ctx_finalize() */
        .           static QEMUBH *aio_bh_dequeue(BHList *head, unsigned *flags)
        .           {
    5,662 ( 0.00%)      QEMUBH *bh = QSLIST_FIRST_RCU(head);
        .           
   11,324 ( 0.00%)      if (!bh) {
        .                   return NULL;
        .               }
        .           
   11,324 ( 0.00%)      QSLIST_REMOVE_HEAD(head, next);
        .           
        .               /*
        .                * The qatomic_and is paired with aio_bh_enqueue().  The implicit memory
        .                * barrier ensures that the callback sees all writes done by the scheduling
        .                * thread.  It also ensures that the scheduling thread sees the cleared
        .                * flag before bh->cb has run, and thus will call aio_notify again if
        .                * necessary.
        .                */
   16,986 ( 0.00%)      *flags = qatomic_fetch_and(&bh->flags,
        .                                         ~(BH_PENDING | BH_SCHEDULED | BH_IDLE));
        .               return bh;
        .           }
        .           
        .           void aio_bh_schedule_oneshot_full(AioContext *ctx, QEMUBHFunc *cb,
        .                                             void *opaque, const char *name)
        .           {
        .               QEMUBH *bh;
-- line 123 ----------------------------------------
-- line 128 ----------------------------------------
        .                   .opaque = opaque,
        .                   .name = name,
        .               };
        .               aio_bh_enqueue(bh, BH_SCHEDULED | BH_ONESHOT);
        .           }
        .           
        .           QEMUBH *aio_bh_new_full(AioContext *ctx, QEMUBHFunc *cb, void *opaque,
        .                                   const char *name)
       30 ( 0.00%)  {
        .               QEMUBH *bh;
        6 ( 0.00%)      bh = g_new(QEMUBH, 1);
      651 ( 0.00%)  => ???:0x0000000004e3b870 (3x)
       18 ( 0.00%)      *bh = (QEMUBH){
        .                   .ctx = ctx,
        .                   .cb = cb,
        .                   .opaque = opaque,
        .                   .name = name,
        .               };
        .               return bh;
       18 ( 0.00%)  }
        .           
        .           void aio_bh_call(QEMUBH *bh)
    2,831 ( 0.00%)  {
   11,324 ( 0.00%)      bh->cb(bh->opaque);
    5,660 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/main-loop.c:notify_event_cb (2,830x)
      588 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/async.c:co_schedule_bh_cb (1x)
        .           }
        .           
        .           /* Multiple occurrences of aio_bh_poll cannot be called concurrently. */
        .           int aio_bh_poll(AioContext *ctx)
   28,310 ( 0.00%)  {
        .               BHListSlice slice;
        .               BHListSlice *s;
    2,831 ( 0.00%)      int ret = 0;
        .           
    5,662 ( 0.00%)      QSLIST_MOVE_ATOMIC(&slice.bh_list, &ctx->bh_list);
   16,986 ( 0.00%)      QSIMPLEQ_INSERT_TAIL(&ctx->bh_slice_list, &slice, next);
        .           
   28,310 ( 0.00%)      while ((s = QSIMPLEQ_FIRST(&ctx->bh_slice_list))) {
        .                   QEMUBH *bh;
        .                   unsigned flags;
        .           
        .                   bh = aio_bh_dequeue(&s->bh_list, &flags);
        .                   if (!bh) {
   25,479 ( 0.00%)              QSIMPLEQ_REMOVE_HEAD(&ctx->bh_slice_list, next);
    2,831 ( 0.00%)              continue;
        .                   }
        .           
   11,324 ( 0.00%)          if ((flags & (BH_SCHEDULED | BH_DELETED)) == BH_SCHEDULED) {
        .                       /* Idle BHs don't count as progress */
        .                       if (!(flags & BH_IDLE)) {
   11,324 ( 0.00%)                  ret = 1;
        .                       }
    5,662 ( 0.00%)              aio_bh_call(bh);
   20,403 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/async.c:aio_bh_call (2,831x)
        .                   }
    5,662 ( 0.00%)          if (flags & (BH_DELETED | BH_ONESHOT)) {
        .                       g_free(bh);
        .                   }
        .               }
        .           
        .               return ret;
   31,141 ( 0.00%)  }
        .           
        .           void qemu_bh_schedule_idle(QEMUBH *bh)
        .           {
        .               aio_bh_enqueue(bh, BH_SCHEDULED | BH_IDLE);
        .           }
        .           
        .           void qemu_bh_schedule(QEMUBH *bh)
   37,208 ( 0.00%)  {
        .               aio_bh_enqueue(bh, BH_SCHEDULED);
   18,604 ( 0.00%)  }
        .           
        .           /* This func is async.
        .            */
        .           void qemu_bh_cancel(QEMUBH *bh)
        .           {
        .               qatomic_and(&bh->flags, ~BH_SCHEDULED);
        .           }
        .           
-- line 204 ----------------------------------------
-- line 209 ----------------------------------------
        .           {
        .               aio_bh_enqueue(bh, BH_DELETED);
        .           }
        .           
        .           static int64_t aio_compute_bh_timeout(BHList *head, int timeout)
        .           {
        .               QEMUBH *bh;
        .           
1,089,551 ( 0.00%)      QSLIST_FOREACH_RCU(bh, head, next) {
   14,155 ( 0.00%)          if ((bh->flags & (BH_SCHEDULED | BH_DELETED)) == BH_SCHEDULED) {
    5,662 ( 0.00%)              if (bh->flags & BH_IDLE) {
        .                           /* idle bottom halves will be polled at least
        .                            * every 10ms */
        .                           timeout = 10000000;
        .                       } else {
        .                           /* non-idle bottom halves will be executed
        .                            * immediately */
    2,831 ( 0.00%)                  return 0;
        .                       }
        .                   }
        .               }
        .           
  718,818 ( 0.00%)      return timeout;
    2,831 ( 0.00%)  }
        .           
        .           int64_t
        .           aio_compute_timeout(AioContext *ctx)
1,086,720 ( 0.00%)  {
        .               BHListSlice *s;
        .               int64_t deadline;
        .               int timeout = -1;
        .           
1,086,720 ( 0.00%)      timeout = aio_compute_bh_timeout(&ctx->bh_list, timeout);
1,833,848 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/async.c:aio_compute_bh_timeout (362,240x)
  724,480 ( 0.00%)      if (timeout == 0) {
    2,831 ( 0.00%)          return 0;
        .               }
        .           
1,797,045 ( 0.00%)      QSIMPLEQ_FOREACH(s, &ctx->bh_slice_list, next) {
        .                   timeout = aio_compute_bh_timeout(&s->bh_list, timeout);
        .                   if (timeout == 0) {
        .                       return 0;
        .                   }
        .               }
        .           
1,078,227 ( 0.00%)      deadline = timerlistgroup_deadline_ns(&ctx->tlg);
54,630,168 ( 0.07%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:timerlistgroup_deadline_ns (359,409x)
  718,818 ( 0.00%)      if (deadline == 0) {
        .                   return 0;
        .               } else {
        .                   return qemu_soonest_timeout(timeout, deadline);
        .               }
  724,480 ( 0.00%)  }
        .           
        .           static gboolean
        .           aio_ctx_prepare(GSource *source, gint    *timeout)
2,173,440 ( 0.00%)  {
        .               AioContext *ctx = (AioContext *) source;
        .           
1,086,720 ( 0.00%)      qatomic_set(&ctx->notify_me, qatomic_read(&ctx->notify_me) | 1);
        .           
        .               /*
        .                * Write ctx->notify_me before computing the timeout
        .                * (reading bottom half flags, etc.).  Pairs with
        .                * smp_mb in aio_notify().
        .                */
  362,240 ( 0.00%)      smp_mb();
        .           
        .               /* We assume there is no timeout already supplied */
1,448,960 ( 0.00%)      *timeout = qemu_timeout_ns_to_ms(aio_compute_timeout(ctx));
64,761,564 ( 0.09%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/async.c:aio_compute_timeout (362,240x)
1,814,031 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:qemu_timeout_ns_to_ms (362,240x)
        .           
1,448,960 ( 0.00%)      if (aio_prepare(ctx)) {
5,071,360 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/aio-posix.c:aio_prepare (362,240x)
        .                   *timeout = 0;
        .               }
        .           
1,448,960 ( 0.00%)      return *timeout == 0;
1,448,960 ( 0.00%)  }
        .           
        .           static gboolean
        .           aio_ctx_check(GSource *source)
1,078,227 ( 0.00%)  {
        .               AioContext *ctx = (AioContext *) source;
        .               QEMUBH *bh;
        .               BHListSlice *s;
        .           
        .               /* Finish computing the timeout before clearing the flag.  */
1,078,227 ( 0.00%)      qatomic_store_release(&ctx->notify_me, qatomic_read(&ctx->notify_me) & ~1);
  359,409 ( 0.00%)      aio_notify_accept(ctx);
1,437,636 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/async.c:aio_notify_accept (359,409x)
        .           
1,437,636 ( 0.00%)      QSLIST_FOREACH_RCU(bh, &ctx->bh_list, next) {
        .                   if ((bh->flags & (BH_SCHEDULED | BH_DELETED)) == BH_SCHEDULED) {
        .                       return true;
        .                   }
        .               }
        .           
1,078,227 ( 0.00%)      QSIMPLEQ_FOREACH(s, &ctx->bh_slice_list, next) {
        .                   QSLIST_FOREACH_RCU(bh, &s->bh_list, next) {
        .                       if ((bh->flags & (BH_SCHEDULED | BH_DELETED)) == BH_SCHEDULED) {
        .                           return true;
        .                       }
        .                   }
        .               }
3,234,681 ( 0.00%)      return aio_pending(ctx) || (timerlistgroup_deadline_ns(&ctx->tlg) == 0);
54,630,168 ( 0.07%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:timerlistgroup_deadline_ns (359,409x)
33,258,063 ( 0.05%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/aio-posix.c:aio_pending (359,409x)
  718,818 ( 0.00%)  }
        .           
        .           static gboolean
        .           aio_ctx_dispatch(GSource     *source,
        .                            GSourceFunc  callback,
        .                            gpointer     user_data)
    5,662 ( 0.00%)  {
        .               AioContext *ctx = (AioContext *) source;
        .           
    5,662 ( 0.00%)      assert(callback == NULL);
    2,831 ( 0.00%)      aio_dispatch(ctx);
  756,528 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/aio-posix.c:aio_dispatch (2,831x)
        .               return true;
    8,493 ( 0.00%)  }
        .           
        .           static void
        .           aio_ctx_finalize(GSource     *source)
        .           {
        .               AioContext *ctx = (AioContext *) source;
        .               QEMUBH *bh;
        .               unsigned flags;
        .           
-- line 330 ----------------------------------------
-- line 382 ----------------------------------------
        .           static GSourceFuncs aio_source_funcs = {
        .               aio_ctx_prepare,
        .               aio_ctx_check,
        .               aio_ctx_dispatch,
        .               aio_ctx_finalize
        .           };
        .           
        .           GSource *aio_get_g_source(AioContext *ctx)
        6 ( 0.00%)  {
        2 ( 0.00%)      aio_context_use_g_source(ctx);
       12 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/aio-posix.c:aio_context_use_g_source (2x)
        4 ( 0.00%)      g_source_ref(&ctx->source);
       26 ( 0.00%)  => ???:0x0000000004e3b630 (2x)
        .               return &ctx->source;
        6 ( 0.00%)  }
        .           
        .           ThreadPool *aio_get_thread_pool(AioContext *ctx)
        .           {
        .               if (!ctx->thread_pool) {
        .                   ctx->thread_pool = thread_pool_new(ctx);
        .               }
        .               return ctx->thread_pool;
        .           }
-- line 402 ----------------------------------------
-- line 439 ----------------------------------------
        .           LuringState *aio_get_linux_io_uring(AioContext *ctx)
        .           {
        .               assert(ctx->linux_io_uring);
        .               return ctx->linux_io_uring;
        .           }
        .           #endif
        .           
        .           void aio_notify(AioContext *ctx)
   18,608 ( 0.00%)  {
        .               /*
        .                * Write e.g. bh->flags before writing ctx->notified.  Pairs with smp_mb in
        .                * aio_notify_accept.
        .                */
        .               smp_wmb();
   18,608 ( 0.00%)      qatomic_set(&ctx->notified, true);
        .           
        .               /*
        .                * Write ctx->notified before reading ctx->notify_me.  Pairs
        .                * with smp_mb in aio_ctx_prepare or aio_poll.
        .                */
   18,608 ( 0.00%)      smp_mb();
   55,824 ( 0.00%)      if (qatomic_read(&ctx->notify_me)) {
        .                   event_notifier_set(&ctx->notifier);
        .               }
   18,608 ( 0.00%)  }
        .           
        .           void aio_notify_accept(AioContext *ctx)
  359,409 ( 0.00%)  {
  359,409 ( 0.00%)      qatomic_set(&ctx->notified, false);
        .           
        .               /*
        .                * Write ctx->notified before reading e.g. bh->flags.  Pairs with smp_wmb
        .                * in aio_notify.
        .                */
  359,409 ( 0.00%)      smp_mb();
  359,409 ( 0.00%)  }
        .           
        .           static void aio_timerlist_notify(void *opaque, QEMUClockType type)
        1 ( 0.00%)  {
        1 ( 0.00%)      aio_notify(opaque);
        7 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/async.c:aio_notify (1x)
        .           }
        .           
        .           static void aio_context_notifier_cb(EventNotifier *e)
        .           {
        .               AioContext *ctx = container_of(e, AioContext, notifier);
        .           
        .               event_notifier_test_and_clear(&ctx->notifier);
        .           }
-- line 486 ----------------------------------------
-- line 495 ----------------------------------------
        .           }
        .           
        .           static void aio_context_notifier_poll_ready(EventNotifier *e)
        .           {
        .               /* Do nothing, we just wanted to kick the event loop */
        .           }
        .           
        .           static void co_schedule_bh_cb(void *opaque)
        5 ( 0.00%)  {
        .               AioContext *ctx = opaque;
        .               QSLIST_HEAD(, Coroutine) straight, reversed;
        .           
        2 ( 0.00%)      QSLIST_MOVE_ATOMIC(&reversed, &ctx->scheduled_coroutines);
        2 ( 0.00%)      QSLIST_INIT(&straight);
        .           
        5 ( 0.00%)      while (!QSLIST_EMPTY(&reversed)) {
        .                   Coroutine *co = QSLIST_FIRST(&reversed);
        2 ( 0.00%)          QSLIST_REMOVE_HEAD(&reversed, co_scheduled_next);
        1 ( 0.00%)          QSLIST_INSERT_HEAD(&straight, co, co_scheduled_next);
        .               }
        .           
        2 ( 0.00%)      while (!QSLIST_EMPTY(&straight)) {
        .                   Coroutine *co = QSLIST_FIRST(&straight);
        1 ( 0.00%)          QSLIST_REMOVE_HEAD(&straight, co_scheduled_next);
        .                   trace_aio_co_schedule_bh_cb(ctx, co);
        2 ( 0.00%)          aio_context_acquire(ctx);
       11 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/async.c:aio_context_acquire (1x)
        .           
        .                   /* Protected by write barrier in qemu_aio_coroutine_enter */
        1 ( 0.00%)          qatomic_set(&co->scheduled, NULL);
        3 ( 0.00%)          qemu_aio_coroutine_enter(ctx, co);
      536 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-coroutine.c:qemu_aio_coroutine_enter (1x)
        2 ( 0.00%)          aio_context_release(ctx);
        9 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/async.c:aio_context_release (1x)
        .               }
        4 ( 0.00%)  }
        .           
        .           AioContext *aio_context_new(Error **errp)
       10 ( 0.00%)  {
        .               int ret;
        .               AioContext *ctx;
        .           
        8 ( 0.00%)      ctx = (AioContext *) g_source_new(&aio_source_funcs, sizeof(AioContext));
    1,037 ( 0.00%)  => ???:0x0000000004e3c580 (2x)
        2 ( 0.00%)      QSLIST_INIT(&ctx->bh_list);
        6 ( 0.00%)      QSIMPLEQ_INIT(&ctx->bh_slice_list);
        4 ( 0.00%)      aio_context_setup(ctx);
       46 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/aio-posix.c:aio_context_setup (2x)
        .           
        8 ( 0.00%)      ret = event_notifier_init(&ctx->notifier, false);
       80 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/event_notifier-posix.c:event_notifier_init (2x)
        4 ( 0.00%)      if (ret < 0) {
        .                   error_setg_errno(errp, -ret, "Failed to initialize event notifier");
        .                   goto fail;
        .               }
        6 ( 0.00%)      g_source_set_can_recurse(&ctx->source, true);
       58 ( 0.00%)  => ???:0x0000000004e3bb20 (2x)
        4 ( 0.00%)      qemu_lockcnt_init(&ctx->list_lock);
        6 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/lockcnt.c:qemu_lockcnt_init (2x)
        .           
       12 ( 0.00%)      ctx->co_schedule_bh = aio_bh_new(ctx, co_schedule_bh_cb, ctx);
      482 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/async.c:aio_bh_new_full (2x)
        2 ( 0.00%)      QSLIST_INIT(&ctx->scheduled_coroutines);
        .           
       14 ( 0.00%)      aio_set_event_notifier(ctx, &ctx->notifier,
    1,628 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/aio-posix.c:aio_set_event_notifier (2x)
        .                                      false,
        .                                      aio_context_notifier_cb,
        .                                      aio_context_notifier_poll,
        .                                      aio_context_notifier_poll_ready);
        .           #ifdef CONFIG_LINUX_AIO
        .               ctx->linux_aio = NULL;
        .           #endif
        .           
        .           #ifdef CONFIG_LINUX_IO_URING
        .               ctx->linux_io_uring = NULL;
        .           #endif
        .           
        2 ( 0.00%)      ctx->thread_pool = NULL;
        4 ( 0.00%)      qemu_rec_mutex_init(&ctx->lock);
      216 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_rec_mutex_init (2x)
        8 ( 0.00%)      timerlistgroup_init(&ctx->tlg, aio_timerlist_notify, ctx);
    2,960 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:timerlistgroup_init (2x)
        .           
        2 ( 0.00%)      ctx->poll_ns = 0;
        2 ( 0.00%)      ctx->poll_max_ns = 0;
        2 ( 0.00%)      ctx->poll_grow = 0;
        2 ( 0.00%)      ctx->poll_shrink = 0;
        .           
        2 ( 0.00%)      ctx->aio_max_batch = 0;
        .           
        4 ( 0.00%)      ctx->thread_pool_min = 0;
        .               ctx->thread_pool_max = THREAD_POOL_MAX_THREADS_DEFAULT;
        .           
        .               return ctx;
        .           fail:
        .               g_source_destroy(&ctx->source);
        .               return NULL;
       10 ( 0.00%)  }
        .           
        .           void aio_co_schedule(AioContext *ctx, Coroutine *co)
        4 ( 0.00%)  {
        .               trace_aio_co_schedule(ctx, co);
        1 ( 0.00%)      const char *scheduled = qatomic_cmpxchg(&co->scheduled, NULL,
        .                                                      __func__);
        .           
        5 ( 0.00%)      if (scheduled) {
        .                   fprintf(stderr,
        .                           "%s: Co-routine was already scheduled in '%s'\n",
        .                           __func__, scheduled);
        .                   abort();
        .               }
        .           
        .               /* The coroutine might run and release the last ctx reference before we
        .                * invoke qemu_bh_schedule().  Take a reference to keep ctx alive until
        .                * we're done.
        .                */
        1 ( 0.00%)      aio_context_ref(ctx);
       15 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/async.c:aio_context_ref (1x)
        .           
        7 ( 0.00%)      QSLIST_INSERT_HEAD_ATOMIC(&ctx->scheduled_coroutines,
        .                                         co, co_scheduled_next);
        2 ( 0.00%)      qemu_bh_schedule(ctx->co_schedule_bh);
       35 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/async.c:qemu_bh_schedule (1x)
        .           
        2 ( 0.00%)      aio_context_unref(ctx);
       40 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/async.c:aio_context_unref (1x)
        3 ( 0.00%)  }
        .           
        .           typedef struct AioCoRescheduleSelf {
        .               Coroutine *co;
        .               AioContext *new_ctx;
        .           } AioCoRescheduleSelf;
        .           
        .           static void aio_co_reschedule_self_bh(void *opaque)
        .           {
-- line 615 ----------------------------------------
-- line 663 ----------------------------------------
        .               } else {
        .                   aio_context_acquire(ctx);
        .                   qemu_aio_coroutine_enter(ctx, co);
        .                   aio_context_release(ctx);
        .               }
        .           }
        .           
        .           void aio_context_ref(AioContext *ctx)
        1 ( 0.00%)  {
        1 ( 0.00%)      g_source_ref(&ctx->source);
       13 ( 0.00%)  => ???:0x0000000004e3b630 (1x)
        .           }
        .           
        .           void aio_context_unref(AioContext *ctx)
        1 ( 0.00%)  {
        1 ( 0.00%)      g_source_unref(&ctx->source);
       38 ( 0.00%)  => ???:0x0000000004e3b470 (1x)
        .           }
        .           
        .           void aio_context_acquire(AioContext *ctx)
        1 ( 0.00%)  {
        6 ( 0.00%)      qemu_rec_mutex_lock(&ctx->lock);
        4 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_rec_mutex_lock_impl (1x)
        .           }
        .           
        .           void aio_context_release(AioContext *ctx)
        1 ( 0.00%)  {
        4 ( 0.00%)      qemu_rec_mutex_unlock(&ctx->lock);
        4 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_rec_mutex_unlock_impl (1x)
        .           }
        .           
       19 ( 0.00%)  QEMU_DEFINE_STATIC_CO_TLS(AioContext *, my_aiocontext)
       28 ( 0.00%)  => ???:0x0000000004e3cc50 (2x)
        .           
        .           AioContext *qemu_get_current_aio_context(void)
        2 ( 0.00%)  {
        2 ( 0.00%)      AioContext *ctx = get_my_aiocontext();
       20 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/async.c:get_my_aiocontext (1x)
        2 ( 0.00%)      if (ctx) {
        .                   return ctx;
        .               }
        .               if (qemu_mutex_iothread_locked()) {
        .                   /* Possibly in a vCPU thread.  */
        .                   return qemu_get_aio_context();
        .               }
        .               return NULL;
        3 ( 0.00%)  }
        .           
        .           void qemu_set_current_aio_context(AioContext *ctx)
        3 ( 0.00%)  {
        3 ( 0.00%)      assert(!get_my_aiocontext());
       20 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/async.c:get_my_aiocontext (1x)
        2 ( 0.00%)      set_my_aiocontext(ctx);
       21 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/async.c:set_my_aiocontext (1x)
        1 ( 0.00%)  }
        .           
        .           void aio_context_set_thread_pool_params(AioContext *ctx, int64_t min,
        .                                                   int64_t max, Error **errp)
        .           {
        .           
        .               if (min > max || !max || min > INT_MAX || max > INT_MAX) {
        .                   error_setg(errp, "bad thread-pool-min/thread-pool-max values");
        .                   return;
-- line 717 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c
--------------------------------------------------------------------------------
Ir                  

-- line 75 ----------------------------------------
         .           };
         .           
         .           static Type type_interface;
         .           
         .           static GHashTable *type_table_get(void)
         .           {
         .               static GHashTable *type_table;
         .           
15,487,207 ( 0.02%)      if (type_table == NULL) {
         6 ( 0.00%)          type_table = g_hash_table_new(g_str_hash, g_str_equal);
       716 ( 0.00%)  => ???:0x0000000004e3d240 (1x)
         .               }
         .           
         .               return type_table;
         .           }
         .           
         .           static bool enumerating_types;
         .           
         .           static void type_table_add(TypeImpl *ti)
     2,308 ( 0.00%)  {
     2,308 ( 0.00%)      assert(!enumerating_types);
     4,616 ( 0.00%)      g_hash_table_insert(type_table_get(), (void *)ti->name, ti);
   489,708 ( 0.00%)  => ???:0x0000000004e3b6a0 (1,154x)
     2,308 ( 0.00%)  }
         .           
         .           static TypeImpl *type_table_lookup(const char *name)
         .           {
15,477,029 ( 0.02%)      return g_hash_table_lookup(type_table_get(), name);
    12,490 ( 0.00%)  => ???:0x0000000004e3bdd0 (90x)
         .           }
         .           
         .           static TypeImpl *type_new(const TypeInfo *info)
    19,596 ( 0.00%)  {
     6,532 ( 0.00%)      TypeImpl *ti = g_malloc0(sizeof(*ti));
   935,604 ( 0.00%)  => ???:0x0000000004e3cc20 (3,266x)
         .               int i;
         .           
     9,798 ( 0.00%)      g_assert(info->name != NULL);
         .           
     6,532 ( 0.00%)      if (type_table_lookup(info->name) != NULL) {
         .                   fprintf(stderr, "Registering `%s' which already exists\n", info->name);
         .                   abort();
         .               }
         .           
     9,798 ( 0.00%)      ti->name = g_strdup(info->name);
   866,595 ( 0.00%)  => ???:0x0000000004e3b620 (3,266x)
     9,798 ( 0.00%)      ti->parent = g_strdup(info->parent);
   845,252 ( 0.00%)  => ???:0x0000000004e3b620 (3,266x)
         .           
     6,532 ( 0.00%)      ti->class_size = info->class_size;
     6,532 ( 0.00%)      ti->instance_size = info->instance_size;
     6,532 ( 0.00%)      ti->instance_align = info->instance_align;
         .           
     6,532 ( 0.00%)      ti->class_init = info->class_init;
     6,532 ( 0.00%)      ti->class_base_init = info->class_base_init;
     6,532 ( 0.00%)      ti->class_data = info->class_data;
         .           
     6,532 ( 0.00%)      ti->instance_init = info->instance_init;
     6,532 ( 0.00%)      ti->instance_post_init = info->instance_post_init;
     6,532 ( 0.00%)      ti->instance_finalize = info->instance_finalize;
         .           
     6,532 ( 0.00%)      ti->abstract = info->abstract;
         .           
    18,545 ( 0.00%)      for (i = 0; info->interfaces && info->interfaces[i].type; i++) {
       430 ( 0.00%)          ti->interfaces[i].typename = g_strdup(info->interfaces[i].type);
    57,637 ( 0.00%)  => ???:0x0000000004e3b620 (215x)
         .               }
     3,266 ( 0.00%)      ti->num_interfaces = i;
         .           
         .               return ti;
    22,862 ( 0.00%)  }
         .           
         .           static TypeImpl *type_register_internal(const TypeInfo *info)
         .           {
         .               TypeImpl *ti;
     2,310 ( 0.00%)      ti = type_new(info);
     1,556 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_new (2x)
         .           
     2,307 ( 0.00%)      type_table_add(ti);
       525 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_table_add (2x)
         .               return ti;
         .           }
         .           
         .           TypeImpl *type_register(const TypeInfo *info)
     2,304 ( 0.00%)  {
     2,304 ( 0.00%)      assert(info->parent);
         .               return type_register_internal(info);
     3,456 ( 0.00%)  }
         .           
         .           TypeImpl *type_register_static(const TypeInfo *info)
       874 ( 0.00%)  {
       874 ( 0.00%)      return type_register(info);
 1,305,875 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_register (874x)
         .           }
         .           
         .           void type_register_static_array(const TypeInfo *infos, int nr_infos)
       140 ( 0.00%)  {
         .               int i;
         .           
       172 ( 0.00%)      for (i = 0; i < nr_infos; i++) {
        96 ( 0.00%)          type_register_static(&infos[i]);
    89,245 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_register_static (48x)
         .               }
        56 ( 0.00%)  }
         .           
         .           static TypeImpl *type_get_by_name(const char *name)
         .           {
10,311,492 ( 0.01%)      if (name == NULL) {
         .                   return NULL;
         .               }
         .           
         .               return type_table_lookup(name);
         .           }
         .           
         .           static TypeImpl *type_get_parent(TypeImpl *type)
    86,034 ( 0.00%)  {
93,015,844 ( 0.13%)      if (!type->parent_type && type->parent) {
     1,151 ( 0.00%)          type->parent_type = type_get_by_name(type->parent);
     2,302 ( 0.00%)          if (!type->parent_type) {
         .                       fprintf(stderr, "Type '%s' is missing its parent '%s'\n",
         .                               type->name, type->parent);
         .                       abort();
         .                   }
         .               }
         .           
         .               return type->parent_type;
   143,390 ( 0.00%)  }
         .           
         .           static bool type_has_parent(TypeImpl *type)
         .           {
         .               return (type->parent != NULL);
         .           }
         .           
         .           static size_t type_class_get_size(TypeImpl *ti)
         .           {
    19,368 ( 0.00%)      if (ti->class_size) {
         .                   return ti->class_size;
         .               }
         .           
     6,268 ( 0.00%)      if (type_has_parent(ti)) {
     6,266 ( 0.00%)          return type_class_get_size(type_get_parent(ti));
   225,054 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_get_parent (972x)
         .               }
         .           
         1 ( 0.00%)      return sizeof(ObjectClass);
         .           }
         .           
         .           static size_t type_object_get_size(TypeImpl *ti)
         .           {
    42,997 ( 0.00%)      if (ti->instance_size) {
         .                   return ti->instance_size;
         .               }
         .           
    22,984 ( 0.00%)      if (type_has_parent(ti)) {
    18,720 ( 0.00%)          return type_object_get_size(type_get_parent(ti));
     6,899 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_get_parent (433x)
         .               }
         .           
         .               return 0;
         .           }
         .           
         .           size_t object_type_get_instance_size(const char *typename)
         .           {
         .               TypeImpl *type = type_get_by_name(typename);
         .           
         .               g_assert(type != NULL);
         .               return type_object_get_size(type);
         .           }
         .           
         .           static bool type_is_ancestor(TypeImpl *type, TypeImpl *target_type)
30,938,454 ( 0.04%)  {
30,938,454 ( 0.04%)      assert(target_type);
         .           
         .               /* Check if target_type is a direct ancestor of type */
30,948,619 ( 0.04%)      while (type) {
82,537,970 ( 0.11%)          if (type == target_type) {
 5,156,181 ( 0.01%)              return true;
         .                   }
         .           
         .                   type = type_get_parent(type);
         .               }
         .           
 5,156,637 ( 0.01%)      return false;
41,251,272 ( 0.06%)  }
         .           
         .           static void type_initialize(TypeImpl *ti);
         .           
         .           static void type_initialize_interface(TypeImpl *ti, TypeImpl *interface_type,
         .                                                 TypeImpl *parent_type)
    23,232 ( 0.00%)  {
         .               InterfaceClass *new_iface;
    33,792 ( 0.00%)      TypeInfo info = { };
         .               TypeImpl *iface_impl;
         .           
     4,224 ( 0.00%)      info.parent = parent_type->name;
    12,672 ( 0.00%)      info.name = g_strdup_printf("%s::%s", ti->name, interface_type->name);
 2,996,444 ( 0.00%)  => ???:0x0000000004e3b7e0 (2,112x)
     2,112 ( 0.00%)      info.abstract = true;
         .           
     6,336 ( 0.00%)      iface_impl = type_new(&info);
 2,410,271 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_new (2,112x)
     2,112 ( 0.00%)      iface_impl->parent_type = parent_type;
         .               type_initialize(iface_impl);
     4,224 ( 0.00%)      g_free((char *)info.name);
   200,640 ( 0.00%)  => ???:0x0000000004e3a950 (2,112x)
         .           
     2,112 ( 0.00%)      new_iface = (InterfaceClass *)iface_impl->class;
     4,224 ( 0.00%)      new_iface->concrete_class = ti->class;
     2,112 ( 0.00%)      new_iface->interface_type = interface_type;
         .           
     8,448 ( 0.00%)      ti->class->interfaces = g_slist_append(ti->class->interfaces, new_iface);
   506,937 ( 0.00%)  => ???:0x0000000004e3ce60 (2,112x)
    25,344 ( 0.00%)  }
 2,816,215 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_initialize.part.0'2 (2,112x)
         .           
         .           static void object_property_free(gpointer data)
        36 ( 0.00%)  {
         .               ObjectProperty *prop = data;
         .           
        36 ( 0.00%)      if (prop->defval) {
         .                   qobject_unref(prop->defval);
         .                   prop->defval = NULL;
         .               }
        24 ( 0.00%)      g_free(prop->name);
     1,376 ( 0.00%)  => ???:0x0000000004e3a950 (12x)
        24 ( 0.00%)      g_free(prop->type);
     1,404 ( 0.00%)  => ???:0x0000000004e3a950 (12x)
        24 ( 0.00%)      g_free(prop->description);
       120 ( 0.00%)  => ???:0x0000000004e3a950 (12x)
        24 ( 0.00%)      g_free(prop);
     1,286 ( 0.00%)  => ???:0x0000000004e3a950 (12x)
        12 ( 0.00%)  }
         .           
    26,120 ( 0.00%)  static void type_initialize(TypeImpl *ti)
         .           {
         .               TypeImpl *parent;
         .           
    44,126 ( 0.00%)      if (ti->class) {
         .                   return;
         .               }
         .           
     3,265 ( 0.00%)      ti->class_size = type_class_get_size(ti);
     3,265 ( 0.00%)      ti->instance_size = type_object_get_size(ti);
         .               /* Any type with zero instance_size is implicitly abstract.
         .                * This means interface types are all abstract.
         .                */
     1,395 ( 0.00%)      if (ti->instance_size == 0) {
 1,727,027 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_initialize.part.0'2 (100x)
     2,132 ( 0.00%)          ti->abstract = true;
         .               }
    16,325 ( 0.00%)      if (type_is_ancestor(ti, type_interface)) {
    72,764 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_is_ancestor (1,018x)
     4,264 ( 0.00%)          assert(ti->instance_size == 0);
     4,264 ( 0.00%)          assert(ti->abstract);
     4,264 ( 0.00%)          assert(!ti->instance_init);
     4,264 ( 0.00%)          assert(!ti->instance_post_init);
     4,264 ( 0.00%)          assert(!ti->instance_finalize);
     6,396 ( 0.00%)          assert(!ti->num_interfaces);
         .               }
     9,795 ( 0.00%)      ti->class = g_malloc0(ti->class_size);
   278,899 ( 0.00%)  => ???:0x0000000004e3cc20 (1,018x)
         .           
     9,795 ( 0.00%)      parent = type_get_parent(ti);
    11,198 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_get_parent (1,018x)
     6,530 ( 0.00%)      if (parent) {
         .                   type_initialize(parent);
         .                   GSList *e;
         .                   int i;
         .           
     9,789 ( 0.00%)          g_assert(parent->class_size <= ti->class_size);
     9,789 ( 0.00%)          g_assert(parent->instance_size <= ti->instance_size);
         .                   memcpy(ti->class, parent->class, parent->class_size);
     6,526 ( 0.00%)          ti->class->interfaces = NULL;
         .           
    19,703 ( 0.00%)          for (e = parent->class->interfaces; e; e = e->next) {
     1,897 ( 0.00%)              InterfaceClass *iface = e->data;
         .                       ObjectClass *klass = OBJECT_CLASS(iface);
         .           
     7,588 ( 0.00%)              type_initialize_interface(ti, iface->interface_type, klass->type);
 7,284,691 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_initialize_interface (1,703x)
         .                   }
         .           
    10,977 ( 0.00%)          for (i = 0; i < ti->num_interfaces; i++) {
       430 ( 0.00%)              TypeImpl *t = type_get_by_name(ti->interfaces[i].typename);
       430 ( 0.00%)              if (!t) {
         .                           error_report("missing interface '%s' for object '%s'",
         .                                        ti->interfaces[i].typename, parent->name);
         .                           abort();
         .                       }
     2,317 ( 0.00%)              for (e = ti->class->interfaces; e; e = e->next) {
       848 ( 0.00%)                  TypeImpl *target_type = OBJECT_CLASS(e->data)->type;
         .           
         .                           if (type_is_ancestor(target_type, t)) {
         .                               break;
         .                           }
         .                       }
         .           
         .                       if (e) {
         .                           continue;
         .                       }
         .           
     1,075 ( 0.00%)              type_initialize_interface(ti, t, t);
   852,364 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_initialize_interface (194x)
         .                   }
         .               }
         .           
    22,855 ( 0.00%)      ti->class->properties = g_hash_table_new_full(g_str_hash, g_str_equal, NULL,
   883,215 ( 0.00%)  => ???:0x0000000004e3b5d0 (1,018x)
         .                                                             object_property_free);
         .           
     6,530 ( 0.00%)      ti->class->type = ti;
         .           
    28,517 ( 0.00%)      while (parent) {
    37,878 ( 0.00%)          if (parent->class_base_init) {
     3,546 ( 0.00%)              parent->class_base_init(ti->class, ti->class_data);
   245,832 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/qdev.c:device_class_base_init (794x)
   188,418 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/pci/pci.c:pci_device_class_base_init (150x)
    81,412 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/machine.c:machine_class_base_init (109x)
         .                   }
    37,878 ( 0.00%)          parent = type_get_parent(parent);
    41,087 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_get_parent (3,365x)
         .               }
         .           
     9,795 ( 0.00%)      if (ti->class_init) {
     3,138 ( 0.00%)          ti->class_init(ti->class, ti->class_data);
 2,573,957 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/block/m25p80.c:m25p80_class_init (134x)
   120,186 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../migration/migration.c:migration_class_init (1x)
   114,004 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/tz-ppc.c:tz_ppc_class_init (1x)
   106,456 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/virtio/virtio-pci.c:virtio_pci_generic_class_init (15x)
    99,686 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/virtio-net.c:virtio_net_class_init (1x)
    98,288 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/block/virtio-blk.c:virtio_blk_class_init (1x)
    98,189 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/nvme/ctrl.c:nvme_class_init (1x)
    97,285 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/scsi/scsi-disk.c:scsi_hd_class_initfn (1x)
    88,232 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/nvme/ns.c:nvme_ns_class_init (1x)
    80,576 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/scsi/scsi-disk.c:scsi_cd_class_initfn (1x)
    71,658 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/hcd-uhci.c:uhci_data_class_init (8x)
    67,099 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/armsse.c:armsse_class_init (3x)
    66,692 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/ide/qdev.c:ide_hd_class_init (1x)
    64,755 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/eepro100.c:eepro100_class_init (13x)
    59,990 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/e1000.c:e1000_class_init (3x)
    52,519 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/block/pflash_cfi02.c:pflash_cfi02_class_init (1x)
    48,322 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/ide/qdev.c:ide_cd_class_init (1x)
    46,312 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/dma/pl330.c:pl330_class_init (1x)
    45,450 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/dev-storage-classic.c:usb_msd_class_storage_initfn (1x)
    38,853 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/virtio/virtio-pci.c:virtio_pci_base_class_init (16x)
    37,322 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../block/throttle-groups.c:throttle_group_obj_class_init (1x)
    36,986 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/scsi/megasas.c:megasas_class_init (2x)
    33,767 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/aspeed.c:aspeed_machine_qcom_dc_scm_v1_class_init (1x)
    33,434 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/block/pflash_cfi01.c:pflash_cfi01_class_init (1x)
    30,234 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/armv7m.c:armv7m_class_init (1x)
    29,406 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/display/vga-pci.c:vga_class_init (1x)
    28,674 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/pci-bridge/gen_pcie_root_port.c:gen_rp_dev_class_init (1x)
    28,527 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/scsi/vhost-scsi.c:vhost_scsi_class_init (1x)
    28,269 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/scsi/virtio-scsi.c:virtio_scsi_class_init (1x)
    28,258 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/xilinx_axienet.c:xilinx_enet_class_init (1x)
    27,842 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/npcm7xx_boards.c:mori_bmc_machine_class_init (1x)
    27,447 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/sensor/tmp421.c:tmp421_class_init (3x)
    27,093 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/scsi/vhost-user-scsi.c:vhost_user_scsi_class_init (1x)
    26,203 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/arm_gicv3_common.c:arm_gicv3_common_class_init (1x)
    25,816 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/scsi/scsi-disk.c:scsi_block_class_initfn (1x)
    23,663 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/pci-bridge/pci_bridge_dev.c:pci_bridge_dev_class_init (1x)
    21,562 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/display/vga-pci.c:secondary_class_init (1x)
    21,513 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/cadence_gem.c:gem_class_init (1x)
    21,343 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/virtio/virtio-balloon.c:virtio_balloon_class_init (1x)
    20,313 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/char/ipoctal232.c:ipoctal_class_init (1x)
    20,253 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/stellaris.c:stellaris_sys_class_init (1x)
    20,218 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/adc/max111x.c:max1111_class_init (1x)
    17,872 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/dma/xilinx_axidma.c:axidma_class_init (1x)
    17,073 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/mem/cxl_type3.c:ct3_class_init (1x)
    16,728 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/hcd-xhci-nec.c:nec_xhci_class_init (1x)
    16,690 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/pci-bridge/cxl_root_port.c:cxl_root_port_class_init (1x)
    15,809 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/arm_gic_common.c:arm_gic_common_class_init (1x)
    15,207 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/block/vhost-user-blk.c:vhost_user_blk_class_init (1x)
    15,135 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/display/bochs-display.c:bochs_display_class_init (1x)
    15,073 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/display/virtio-gpu.c:virtio_gpu_class_init (1x)
    14,903 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/display/bcm2835_fb.c:bcm2835_fb_class_init (1x)
    14,689 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/e1000e.c:e1000e_class_init (1x)
    14,488 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/virtio/virtio-mem.c:virtio_mem_class_init (1x)
    13,865 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/generic-loader.c:generic_loader_class_init (1x)
    13,326 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/allwinner-sun8i-emac.c:allwinner_sun8i_emac_class_init (1x)
    13,206 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/tz-msc.c:tz_msc_class_init (1x)
    13,168 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/msf2-soc.c:m2sxxx_soc_class_init (1x)
    12,339 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/hcd-xhci.c:xhci_class_init (1x)
    12,097 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/virt.c:virt_2_6_class_init (1x)
    11,950 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/sd/sdhci-pci.c:sdhci_pci_class_init (1x)
    11,716 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../ui/input-barrier.c:input_barrier_class_init (1x)
    11,641 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/char/serial-pci-multi.c:multi_4x_serial_pci_class_initfn (1x)
    11,507 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/virt.c:virt_2_7_class_init (1x)
    11,361 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/aspeed.c:aspeed_machine_quanta_q71l_class_init (1x)
    11,360 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/block/onenand.c:onenand_class_init (1x)
    11,301 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/aspeed.c:aspeed_machine_romulus_class_init (1x)
    11,294 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/virtio/virtio-rng.c:virtio_rng_class_init (1x)
    11,256 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/nrf51_soc.c:nrf51_soc_class_init (1x)
    11,256 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/rocker/rocker.c:rocker_class_init (1x)
    11,250 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/mps2-scc.c:mps2_scc_class_init (1x)
    11,108 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/mv88w8618_eth.c:mv88w8618_eth_class_init (1x)
    10,997 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/pci/pcie_port.c:pcie_slot_class_init (1x)
    10,959 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/display/i2c-ddc.c:i2c_ddc_class_init (1x)
    10,903 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/msf2-emac.c:msf2_emac_class_init (1x)
    10,856 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/vmxnet3.c:vmxnet3_class_init (1x)
    10,810 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/virt.c:virt_2_8_class_init (1x)
    10,806 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/ivshmem.c:ivshmem_doorbell_class_init (1x)
    10,573 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/ivshmem.c:ivshmem_plain_class_init (1x)
    10,206 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/display/vhost-user-gpu.c:vhost_user_gpu_class_init (1x)
    10,186 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/gpio/npcm7xx_gpio.c:npcm7xx_gpio_class_init (1x)
     9,947 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/iotkit-sysctl.c:iotkit_sysctl_class_init (1x)
     9,918 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/cpu.c:cpu_register_class_init (29x)
     9,893 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/virtio/virtio-iommu.c:virtio_iommu_class_init (1x)
     9,873 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/virt.c:virt_2_9_class_init (1x)
     9,829 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/smmu-common.c:smmu_base_class_init (1x)
     9,746 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/mps2-fpgaio.c:mps2_fpgaio_class_init (1x)
     9,668 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/virt.c:virt_2_10_class_init (1x)
     9,657 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/adc/max111x.c:max1110_class_init (1x)
     9,653 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/scsi/vmw_pvscsi.c:pvscsi_class_init (1x)
     9,623 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/virtio/vhost-user-fs.c:vuf_class_init (1x)
     9,560 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/virt.c:virt_2_11_class_init (1x)
     9,539 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/display/ati.c:ati_vga_class_init (1x)
     9,467 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/acpi/erst.c:erst_class_init (1x)
     9,403 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/armv7m.c:bitband_class_init (1x)
     9,301 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/arm_sysctl.c:arm_sysctl_class_init (1x)
     9,230 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/i2c/aspeed_i2c.c:aspeed_i2c_bus_class_init (1x)
     9,220 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/iotkit-sysinfo.c:iotkit_sysinfo_class_init (1x)
     9,206 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/hcd-ohci.c:ohci_sysbus_class_init (1x)
     9,205 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/timer/allwinner-a10-pit.c:a10_pit_class_init (1x)
     9,162 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/dev-audio.c:usb_audio_class_init (1x)
     8,986 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/ssi/aspeed_smc.c:aspeed_smc_flash_class_init (1x)
     8,939 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/imx_fec.c:imx_eth_class_init (1x)
     8,913 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/virt.c:virt_2_12_class_init (1x)
     8,781 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/char/exynos4210_uart.c:exynos4210_uart_class_init (1x)
     8,692 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/arm_gicv3_its.c:gicv3_its_class_init (1x)
     8,509 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/virtio/virtio-mmio.c:virtio_mmio_class_init (1x)
     8,172 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/virt.c:virt_3_0_class_init (1x)
     8,167 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/virt.c:virt_3_1_class_init (1x)
     7,897 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/nvram/fw_cfg.c:fw_cfg_mem_class_init (1x)
     7,769 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../backends/hostmem-file.c:file_backend_class_init (1x)
     7,622 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/virtio/virtio-crypto.c:virtio_crypto_class_init (1x)
     7,592 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/display/cirrus_vga.c:cirrus_vga_class_init (1x)
     7,489 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/dma/pl080.c:pl080_class_init (1x)
     7,455 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/pci-bridge/pci_expander_bridge.c:pxb_pcie_dev_class_init (1x)
     7,449 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/pci-bridge/pci_expander_bridge.c:pxb_dev_class_init (1x)
     7,448 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/pci-bridge/pci_expander_bridge.c:pxb_cxl_dev_class_init (1x)
     7,398 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/dev-hid.c:usb_tablet_class_initfn (1x)
     7,367 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/guest-loader.c:guest_loader_class_init (1x)
     7,328 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/tz-mpc.c:tz_mpc_class_init (1x)
     7,327 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/virt.c:virt_4_0_class_init (1x)
     7,279 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/hcd-ohci-pci.c:ohci_pci_class_init (1x)
     7,255 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/scsi/scsi-generic.c:scsi_generic_class_initfn (1x)
     7,253 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/char/serial-pci-multi.c:multi_2x_serial_pci_class_initfn (1x)
     7,156 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/nvram/eeprom_at24c.c:at24c_eeprom_class_init (1x)
     7,075 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../backends/hostmem-memfd.c:memfd_backend_class_init (1x)
     7,059 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../ui/input-linux.c:input_linux_class_init (1x)
     7,049 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/timer/sse-timer.c:sse_timer_class_init (1x)
     6,926 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/virt.c:virt_4_1_class_init (1x)
     6,813 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/lan9118.c:lan9118_class_init (1x)
     6,784 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/i2c/aspeed_i2c.c:aspeed_i2c_class_init (1x)
     6,776 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/sd/sd.c:sd_class_init (1x)
     6,727 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../crypto/tlscreds.c:qcrypto_tls_creds_class_init (1x)
     6,688 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/ftgmac100.c:aspeed_mii_class_init (1x)
     6,651 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/tpm/tpm_tis_sysbus.c:tpm_tis_sysbus_class_init (1x)
     6,644 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/dev-mtp.c:usb_mtp_class_initfn (1x)
     6,610 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/block/nand.c:nand_class_init (1x)
     6,609 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/ftgmac100.c:ftgmac100_class_init (1x)
     6,553 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/allwinner_emac.c:aw_emac_class_init (1x)
     6,437 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/virt.c:virt_4_2_class_init (1x)
     6,397 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../crypto/tlscredsx509.c:qcrypto_tls_creds_x509_class_init (1x)
     6,388 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/led.c:led_class_init (1x)
     6,385 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/char/serial.c:serial_class_init (1x)
     6,154 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/tcg-all.c:tcg_accel_class_init (1x)
     6,150 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/char/virtio-serial-bus.c:virtio_serial_class_init (1x)
     6,042 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../net/filter-mirror.c:filter_redirector_class_init (1x)
     5,967 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/npcm7xx_gcr.c:npcm7xx_gcr_class_init (1x)
     5,924 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/dev-serial.c:usb_serial_class_initfn (1x)
     5,920 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/nrf51_rng.c:nrf51_rng_class_init (1x)
     5,653 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/nvram/fw_cfg.c:fw_cfg_io_class_init (1x)
     5,637 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/scsi/mptsas.c:mptsas1068_class_init (1x)
     5,495 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/gpio/imx_gpio.c:imx_gpio_class_init (1x)
     5,434 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/display/vmware_vga.c:vmsvga_class_init (1x)
     5,352 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../iothread.c:iothread_class_init (1x)
     5,340 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/dev-hid.c:usb_keyboard_class_initfn (1x)
     5,329 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/timer/xilinx_timer.c:xilinx_timer_class_init (1x)
     5,267 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/msf2-sysreg.c:msf2_sysreg_class_init (1x)
     5,199 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/virt.c:virt_5_0_class_init (1x)
     5,193 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/dev-hub.c:usb_hub_class_initfn (1x)
     5,143 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/audio/pl041.c:pl041_device_class_init (1x)
     5,137 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/virtio/vhost-vsock.c:vhost_vsock_class_init (1x)
     4,963 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/char/serial.c:serial_mm_class_init (1x)
     4,921 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/arm_gicv2m.c:gicv2m_class_init (1x)
     4,914 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/fsl-imx7.c:fsl_imx7_class_init (1x)
     4,910 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/thread-context.c:thread_context_class_init (1x)
     4,890 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/adc/aspeed_adc.c:aspeed_adc_engine_class_init (1x)
     4,819 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/pci-bridge/xio3130_downstream.c:xio3130_downstream_class_init (1x)
     4,793 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/platform-bus.c:platform_bus_class_init (1x)
     4,777 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/dev-network.c:usb_net_class_initfn (1x)
     4,764 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/spitz.c:sl_nand_class_init (1x)
     4,760 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/pcnet-pci.c:pcnet_class_init (1x)
     4,760 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/rtl8139.c:rtl8139_class_init (1x)
     4,758 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/tulip.c:tulip_class_init (1x)
     4,757 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/ne2000-pci.c:ne2000_class_init (1x)
     4,754 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/fsl-imx6ul.c:fsl_imx6ul_class_init (1x)
     4,721 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/char/cmsdk-apb-uart.c:cmsdk_apb_uart_class_init (1x)
     4,708 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/timer/pxa2xx_timer.c:pxa25x_timer_dev_class_init (1x)
     4,708 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/timer/pxa2xx_timer.c:pxa27x_timer_dev_class_init (1x)
     4,681 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/allwinner-h3-dramc.c:allwinner_h3_dramc_class_init (1x)
     4,592 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/cpu/a9mpcore.c:a9mp_priv_class_init (1x)
     4,582 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/pxa2xx.c:pxa2xx_i2c_class_init (1x)
     4,582 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/cpu/arm11mpcore.c:mpcore_priv_class_init (1x)
     4,582 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/cpu/a15mpcore.c:a15mp_priv_class_init (1x)
     4,570 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/npcm7xx_emc.c:npcm7xx_emc_class_init (1x)
     4,565 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/smc91c111.c:smc91c111_class_init (1x)
     4,563 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/xgmac.c:xgmac_enet_class_init (1x)
     4,558 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/timer/arm_timer.c:sp804_class_init (1x)
     4,548 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/pxa2xx_gpio.c:pxa2xx_gpio_class_init (1x)
     4,427 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../authz/listfile.c:qauthz_list_file_class_init (1x)
     4,412 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/virt.c:virt_5_1_class_init (1x)
     4,408 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/pci-host/gpex.c:gpex_host_class_init (1x)
     4,407 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/stellaris_enet.c:stellaris_enet_class_init (1x)
     4,361 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../net/filter-mirror.c:filter_mirror_class_init (1x)
     4,179 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../backends/dbus-vmstate.c:dbus_vmstate_class_init (1x)
     4,117 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/pci-bridge/pcie_pci_bridge.c:pcie_pci_bridge_class_init (1x)
     4,115 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../crypto/tlscredspsk.c:qcrypto_tls_creds_psk_class_init (1x)
     4,076 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/unimp.c:unimp_class_init (1x)
     3,908 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../crypto/secret.c:qcrypto_secret_class_init (1x)
     3,739 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/qtest.c:qtest_class_init (1x)
     3,711 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/mem/nvdimm.c:nvdimm_class_init (1x)
     3,708 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/cpu_tcg.c:arm_v7m_class_init (6x)
     3,683 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../net/dump.c:filter_dump_class_init (1x)
     3,669 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../net/can/can_host.c:can_host_class_init (1x)
     3,639 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../authz/list.c:qauthz_list_class_init (1x)
     3,632 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/acpi/generic_event_device.c:acpi_ged_class_init (1x)
     3,605 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/ssi/xilinx_spips.c:xlnx_zynqmp_qspips_class_init (1x)
     3,566 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/cpu/core.c:cpu_core_class_init (1x)
     3,546 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/hcd-dwc2.c:dwc2_class_init (1x)
     3,484 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../chardev/char-socket.c:char_socket_class_init (1x)
     3,421 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/mps2-tz.c:mps3tz_an524_class_init (1x)
     3,402 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/pci-host/versatile.c:pci_vpb_class_init (1x)
     3,370 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/dev-hid.c:usb_mouse_class_initfn (1x)
     3,326 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/virt.c:virt_5_2_class_init (1x)
     3,247 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/rtc/pl031.c:pl031_class_init (1x)
     3,233 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/dev-smartcard-reader.c:ccid_class_initfn (1x)
     3,204 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/watchdog/wdt_imx2.c:imx2_wdt_class_init (1x)
     3,197 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/input/virtio-input-hid.c:virtio_tablet_class_init (1x)
     3,197 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/input/virtio-input-hid.c:virtio_mouse_class_init (1x)
     3,175 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/dev-serial.c:usb_braille_class_initfn (1x)
     3,130 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/dev-uas.c:usb_uas_class_initfn (1x)
     3,109 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/ssi/npcm7xx_fiu.c:npcm7xx_fiu_class_init (1x)
     3,102 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/nvram/fw_cfg.c:fw_cfg_class_init (1x)
     3,078 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/timer/mss-timer.c:mss_timer_class_init (1x)
     3,062 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/virtio/vhost-user-vsock.c:vuv_class_init (1x)
     3,057 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/audio/wm8750.c:wm8750_class_init (1x)
     3,045 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/hcd-ehci-pci.c:ehci_class_init (1x)
     3,043 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/vexpress.c:vexpress_a15_class_init (1x)
     2,998 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/timer/stm32f2xx_timer.c:stm32f2xx_timer_class_init (1x)
     2,968 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/char/virtio-console.c:virtserialport_class_init (1x)
     2,941 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/omap_intc.c:omap2_intc_class_init (1x)
     2,934 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/audio/ac97.c:ac97_class_init (1x)
     2,933 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/audio/es1370.c:es1370_class_init (1x)
     2,923 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/virtio/vhost-user-rng.c:vu_rng_class_init (1x)
     2,921 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/virtio/vhost-user-i2c.c:vu_i2c_class_init (1x)
     2,921 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/virtio/vhost-user-gpio.c:vu_gpio_class_init (1x)
     2,912 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/char/cadence_uart.c:cadence_uart_class_init (1x)
     2,909 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/pci-bridge/cxl_upstream.c:cxl_upstream_class_init (1x)
     2,899 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/input/virtio-input-host.c:virtio_input_host_class_init (1x)
     2,885 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/adc/npcm7xx_adc.c:npcm7xx_adc_class_init (1x)
     2,875 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/pci-testdev.c:pci_testdev_class_init (1x)
     2,874 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/char/serial-pci.c:serial_pci_class_initfn (1x)
     2,870 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/fby35.c:fby35_class_init (1x)
     2,858 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/u2f-passthru.c:u2f_passthru_class_init (1x)
     2,816 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/arm_l2x0.c:l2x0_class_init (1x)
     2,810 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/pvpanic-pci.c:pvpanic_pci_class_init (1x)
     2,791 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/gpio/omap_gpio.c:omap_gpio_class_init (1x)
     2,769 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/gpio/omap_gpio.c:omap2_gpio_class_init (1x)
     2,752 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/bcm2835_cprman.c:cprman_class_init (1x)
     2,746 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/xilinx_intc.c:xilinx_intc_class_init (1x)
     2,722 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/dma/pxa2xx_dma.c:pxa2xx_dma_class_init (1x)
     2,721 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/i2c/omap_i2c.c:omap_i2c_class_init (1x)
     2,717 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/vfio/pci.c:vfio_pci_nohotplug_dev_class_init (1x)
     2,714 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/char/imx_serial.c:imx_serial_class_init (1x)
     2,713 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/pxa2xx.c:pxa2xx_fir_class_init (1x)
     2,711 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/char/digic-uart.c:digic_uart_class_init (1x)
     2,710 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/char/bcm2835_aux.c:bcm2835_aux_class_init (1x)
     2,709 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/allwinner-sid.c:allwinner_sid_class_init (1x)
     2,708 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/fsl-imx25.c:fsl_imx25_class_init (1x)
     2,706 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/ssi/xilinx_spi.c:xilinx_spi_class_init (1x)
     2,704 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/iotkit-secctl.c:iotkit_secctl_class_init (1x)
     2,695 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../authz/simple.c:qauthz_simple_class_init (1x)
     2,693 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../scsi/pr-manager-helper.c:pr_manager_helper_class_init (1x)
     2,683 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/virt.c:virt_6_0_class_init (1x)
     2,681 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/a9scu.c:a9_scu_class_init (1x)
     2,679 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/timer/arm_mptimer.c:arm_mptimer_class_init (1x)
     2,675 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/arm11scu.c:arm11_scu_class_init (1x)
     2,671 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/nvram/nrf51_nvm.c:nrf51_nvm_class_init (1x)
     2,668 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:armv7m_nvic_class_init (1x)
     2,666 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/cpu/cluster.c:cpu_cluster_class_init (1x)
     2,657 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/aspeed_i3c.c:aspeed_i3c_device_class_init (1x)
     2,652 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/omap_intc.c:omap_intc_class_init (1x)
     2,625 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../net/filter-rewriter.c:colo_rewriter_class_init (1x)
     2,623 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/aspeed_lpc.c:aspeed_lpc_class_init (1x)
     2,621 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/or-irq.c:or_irq_class_init (1x)
     2,608 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/sd/aspeed_sdhci.c:aspeed_sdhci_class_init (1x)
     2,608 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/bcm2835_property.c:bcm2835_property_class_init (1x)
     2,560 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/exynos4210_combiner.c:exynos4210_combiner_class_init (1x)
     2,555 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/strongarm.c:strongarm_uart_class_init (1x)
     2,553 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/char/nrf51_uart.c:nrf51_uart_class_init (1x)
     2,551 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/char/stm32f2xx_usart.c:stm32f2xx_usart_class_init (1x)
     2,549 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/char/xilinx_uartlite.c:xilinx_uartlite_class_init (1x)
     2,548 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/fsl-imx6.c:fsl_imx6_class_init (1x)
     2,519 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/timer/a9gtimer.c:a9_gtimer_class_init (1x)
     2,517 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/exynos4210_gic.c:exynos4210_gic_class_init (1x)
     2,515 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/cpu/realview_mpcore.c:mpcore_rirq_class_init (1x)
     2,486 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/vexpress.c:vexpress_class_init (1x)
     2,468 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/stm32f100_soc.c:stm32f100_soc_class_init (1x)
     2,468 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/stm32f205_soc.c:stm32f205_soc_class_init (1x)
     2,468 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/stm32f405_soc.c:stm32f405_soc_class_init (1x)
     2,461 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/integratorcp.c:core_class_init (1x)
     2,453 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/split-irq.c:split_irq_class_init (1x)
     2,419 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/armsse-cpuid.c:armsse_cpuid_class_init (1x)
     2,396 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../backends/cryptodev-vhost-user.c:cryptodev_vhost_user_class_init (1x)
     2,352 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../backends/rng-random.c:rng_random_class_init (1x)
     2,327 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../backends/rng-egd.c:rng_egd_class_init (1x)
     2,322 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../crypto/tlscredsanon.c:qcrypto_tls_creds_anon_class_init (1x)
     2,305 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/timer/nrf51_timer.c:nrf51_timer_class_init (1x)
     2,263 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/dev-smartcard-reader.c:ccid_card_class_init (1x)
     2,198 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../backends/rng.c:rng_backend_class_init (1x)
     2,186 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/virt.c:virt_6_1_class_init (1x)
     2,141 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../net/can/can_socketcan.c:can_host_socketcan_class_init (1x)
     2,122 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/nvme/subsys.c:nvme_subsys_class_init (1x)
     2,113 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../net/filter-buffer.c:filter_buffer_class_init (1x)
     2,044 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../crypto/secret_keyring.c:qcrypto_secret_keyring_class_init (1x)
     2,018 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/hcd-ehci-pci.c:ehci_data_class_init (3x)
     1,870 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../backends/vhost-user.c:vhost_user_backend_class_init (1x)
     1,771 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/raspi.c:raspi0_machine_class_init (1x)
     1,760 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/raspi.c:raspi1ap_machine_class_init (1x)
     1,760 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/raspi.c:raspi2b_machine_class_init (1x)
     1,441 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/virt.c:virt_6_2_class_init (1x)
     1,160 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/display/vga-pci.c:vga_pci_class_init (1x)
     1,127 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/pci-bridge/ioh3420.c:ioh3420_class_init (1x)
     1,089 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/sensor/isl_pmbus_vr.c:isl69259_class_init (1x)
     1,070 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/input/vhost-user-input.c:vhost_input_class_init (1x)
     1,068 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/sensor/adm1272.c:adm1272_class_init (1x)
     1,068 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/sensor/max31785.c:max31785_class_init (1x)
     1,068 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/sensor/max34451.c:max34451_class_init (1x)
     1,065 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/sensor/isl_pmbus_vr.c:raa228000_class_init (1x)
     1,065 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/sensor/isl_pmbus_vr.c:raa229004_class_init (1x)
     1,041 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/pci-bridge/pci_expander_bridge.c:pxb_host_class_init (1x)
     1,013 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/arm_gicv3.c:arm_gicv3_class_init (1x)
       963 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/sensor/emc141x.c:emc1414_class_init (1x)
       963 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/sensor/emc141x.c:emc1413_class_init (1x)
       943 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/virt.c:virt_7_0_class_init (1x)
       941 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/mps2-tz.c:mps2tz_an521_class_init (1x)
       941 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/mps2-tz.c:mps2tz_an505_class_init (1x)
       935 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/mps2-tz.c:mps3tz_an547_class_init (1x)
       819 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/pci-bridge/pci_expander_bridge.c:pxb_bus_class_init (3x)
       757 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/chipidea.c:chipidea_class_init (1x)
       755 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/hcd-ehci-sysbus.c:ehci_aw_h3_class_init (1x)
       755 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/hcd-ehci-sysbus.c:ehci_ppc4xx_class_init (1x)
       754 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/vfio/calxeda-xgmac.c:vfio_calxeda_xgmac_class_init (1x)
       754 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/hcd-ehci-sysbus.c:ehci_npcm7xx_class_init (1x)
       754 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/hcd-ehci-sysbus.c:fusbh200_ehci_class_init (1x)
       753 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/hcd-ehci-sysbus.c:ehci_exynos4210_class_init (1x)
       753 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/hcd-ehci-sysbus.c:ehci_platform_class_init (1x)
       753 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/hcd-ehci-sysbus.c:ehci_tegra2_class_init (1x)
       736 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/sd/ssi-sd.c:ssi_sd_class_init (1x)
       734 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/display/ssd0323.c:ssd0323_class_init (1x)
       733 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/adc/max111x.c:max111x_class_init (1x)
       732 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/spitz.c:spitz_lcdtg_class_init (1x)
       732 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/spitz.c:corgi_ssp_class_init (1x)
       731 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/input/ads7846.c:ads7846_class_init (1x)
       709 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/rtc/allwinner-rtc.c:allwinner_rtc_sun7i_class_init (1x)
       700 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/pci-bridge/cxl_downstream.c:cxl_dsp_class_init (1x)
       695 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/ide/microdrive.c:dscm1xxxx_class_init (1x)
       691 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/ide/microdrive.c:microdrive_class_init (1x)
       690 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/pci-bridge/xio3130_upstream.c:xio3130_upstream_class_init (1x)
       689 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/i2c/smbus_eeprom.c:smbus_eeprom_class_initfn (1x)
       688 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/pci-host/designware.c:designware_pcie_host_class_init (1x)
       686 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/pci-bridge/pci_expander_bridge.c:pxb_cxl_host_class_init (1x)
       686 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/scsi/scsi-bus.c:scsi_bus_class_init (1x)
       686 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/bus.c:usb_bus_class_init (1x)
       681 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/pci-host/designware.c:designware_pcie_root_class_init (1x)
       678 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/vfio/amd-xgbe.c:vfio_amd_xgbe_class_init (1x)
       678 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/pci-bridge/pci_bridge_dev.c:pci_bridge_dev_seat_class_init (1x)
       674 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/pci-bridge/i82801b11.c:i82801b11_bridge_class_init (1x)
       673 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/timer/aspeed_timer.c:aspeed_1030_timer_class_init (1x)
       673 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/timer/aspeed_timer.c:aspeed_2400_timer_class_init (1x)
       673 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/timer/aspeed_timer.c:aspeed_2600_timer_class_init (1x)
       673 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/timer/aspeed_timer.c:aspeed_2500_timer_class_init (1x)
       672 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/npcm7xx_pwm.c:npcm7xx_pwm_class_init (1x)
       672 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/timer/npcm7xx_timer.c:npcm7xx_timer_class_init (1x)
       672 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/zynq_slcr.c:zynq_slcr_class_init (1x)
       672 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/i2c/npcm7xx_smbus.c:npcm7xx_smbus_class_init (1x)
       672 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/npcm7xx_mft.c:npcm7xx_mft_class_init (1x)
       672 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/npcm7xx_clk.c:npcm7xx_clk_class_init (1x)
       671 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/scsi/esp-pci.c:dc390_class_init (1x)
       670 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/npcm7xx_rng.c:npcm7xx_rng_class_init (1x)
       668 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/audio/intel-hda.c:intel_hda_class_init_ich9 (1x)
       668 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/virtio/virtio-pci.c:virtio_pci_bus_class_init (1x)
       668 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/audio/intel-hda.c:intel_hda_class_init_ich6 (1x)
       668 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/watchdog/wdt_i6300esb.c:i6300esb_class_init (1x)
       666 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/can/can_mioe3680_pci.c:mioe3680_pci_class_init (1x)
       666 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/can/can_pcm3680_pci.c:pcm3680i_pci_class_init (1x)
       666 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/can/ctucan_pci.c:ctucan_pci_class_init (1x)
       666 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/aspeed_scu.c:aspeed_2600_scu_class_init (1x)
       666 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/aspeed_scu.c:aspeed_1030_scu_class_init (1x)
       665 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/scsi/esp-pci.c:esp_pci_class_init (1x)
       665 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/can/can_kvaser_pci.c:kvaser_pci_class_init (1x)
       664 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/aspeed_scu.c:aspeed_2500_scu_class_init (1x)
       664 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/aspeed_scu.c:aspeed_2400_scu_class_init (1x)
       663 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/ssi/aspeed_smc.c:aspeed_1030_fmc_class_init (1x)
       663 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/ide/ich.c:ich_ahci_class_init (1x)
       662 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/ssi/aspeed_smc.c:aspeed_2500_fmc_class_init (1x)
       662 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/ssi/aspeed_smc.c:aspeed_2600_fmc_class_init (1x)
       662 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/smmuv3.c:smmuv3_class_init (1x)
       662 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/ssi/aspeed_smc.c:aspeed_2400_fmc_class_init (1x)
       661 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/ssi/xilinx_spips.c:xilinx_qspips_class_init (1x)
       661 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/ssi/aspeed_smc.c:aspeed_1030_spi2_class_init (1x)
       661 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/ssi/aspeed_smc.c:aspeed_1030_spi1_class_init (1x)
       661 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/ipack/tpci200.c:tpci200_class_init (1x)
       660 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/ssi/aspeed_smc.c:aspeed_2600_spi2_class_init (1x)
       660 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/pci-host/gpex.c:gpex_root_class_init (1x)
       660 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/ssi/aspeed_smc.c:aspeed_2600_spi1_class_init (1x)
       659 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/display/virtio-gpu-base.c:virtio_gpu_base_class_init (1x)
       659 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/edu.c:edu_class_init (1x)
       659 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/aspeed_hace.c:aspeed_ast1030_hace_class_init (1x)
       659 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/aspeed_hace.c:aspeed_ast2600_hace_class_init (1x)
       659 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/aspeed_hace.c:aspeed_ast2400_hace_class_init (1x)
       659 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/aspeed_hace.c:aspeed_ast2500_hace_class_init (1x)
       658 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/watchdog/wdt_aspeed.c:aspeed_1030_wdt_class_init (1x)
       658 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/ssi/aspeed_smc.c:aspeed_2400_spi1_class_init (1x)
       658 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/watchdog/wdt_aspeed.c:aspeed_2500_wdt_class_init (1x)
       658 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/watchdog/wdt_aspeed.c:aspeed_2600_wdt_class_init (1x)
       657 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/ssi/aspeed_smc.c:aspeed_2500_spi1_class_init (1x)
       657 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/aspeed_sdmc.c:aspeed_2600_sdmc_class_init (1x)
       657 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/ssi/aspeed_smc.c:aspeed_2500_spi2_class_init (1x)
       656 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/pci-host/versatile.c:versatile_pci_host_class_init (1x)
       656 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/aspeed_sdmc.c:aspeed_2500_sdmc_class_init (1x)
       656 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/watchdog/wdt_aspeed.c:aspeed_2400_wdt_class_init (1x)
       656 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/ssi/aspeed_smc.c:aspeed_2400_smc_class_init (1x)
       656 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/aspeed_sdmc.c:aspeed_2400_sdmc_class_init (1x)
       653 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/aspeed_xdma.c:aspeed_2500_xdma_class_init (1x)
       653 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/aspeed_xdma.c:aspeed_2600_xdma_class_init (1x)
       653 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/aspeed_xdma.c:aspeed_2400_xdma_class_init (1x)
       652 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/input/ps2.c:ps2_kbd_class_init (1x)
       652 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/input/ps2.c:ps2_mouse_class_init (1x)
       652 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/i2c/aspeed_i2c.c:aspeed_2500_i2c_class_init (1x)
       651 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/i2c/aspeed_i2c.c:aspeed_2600_i2c_class_init (1x)
       651 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/i2c/aspeed_i2c.c:aspeed_1030_i2c_class_init (1x)
       651 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/virtio/virtio-mmio.c:virtio_mmio_bus_class_init (1x)
       650 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/i2c/aspeed_i2c.c:aspeed_2400_i2c_class_init (1x)
       647 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/input/pl050.c:pl050_kbd_class_init (1x)
       647 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/input/pl050.c:pl050_mouse_class_init (1x)
       647 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/u2f.c:u2f_key_class_init (1x)
       645 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/dev-wacom.c:usb_wacom_class_init (1x)
       643 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/pca9552.c:pca9552_class_init (1x)
       642 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/adc/aspeed_adc.c:aspeed_1030_adc_class_init (1x)
       642 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/virt.c:virt_7_1_class_init (1x)
       642 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/adc/aspeed_adc.c:aspeed_2600_adc_class_init (1x)
       641 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/aspeed_ast10x0.c:aspeed_soc_ast1030_class_init (1x)
       638 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/dev-serial.c:usb_serial_dev_class_init (1x)
       636 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/dma/xilinx_axidma.c:xilinx_axidma_stream_class_init (2x)
       635 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/audio/hda-codec.c:hda_audio_output_class_init (1x)
       635 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/audio/hda-codec.c:hda_audio_micro_class_init (1x)
       635 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/mps2-tz.c:mps2tz_class_init (1x)
       635 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/audio/hda-codec.c:hda_audio_duplex_class_init (1x)
       635 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/bcm2836.c:bcm2836_class_init (1x)
       633 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/bcm2836.c:bcm2835_class_init (1x)
       631 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/gpio/max7310.c:max7310_class_init (1x)
       631 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/input/lm832x.c:lm8323_class_init (1x)
       631 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/display/sii9022.c:sii9022_class_init (1x)
       629 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/sensor/dps310.c:dps310_class_init (1x)
       629 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/display/ssd0303.c:ssd0303_class_init (1x)
       629 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/rtc/twl92230.c:twl92230_class_init (1x)
       629 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/sensor/tmp105.c:tmp105_class_init (1x)
       629 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/rtc/ds1338.c:ds1338_class_init (1x)
       629 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/sensor/lsm303dlhc_mag.c:lsm303dlhc_mag_class_init (1x)
       627 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/rtc/m41t80.c:m41t80_class_init (1x)
       625 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/i2c/aspeed_i2c.c:aspeed_i2c_bus_slave_class_init (1x)
       624 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/arm_gic.c:arm_gic_class_init (1x)
       623 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/imx25_ccm.c:imx25_ccm_class_init (1x)
       623 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/imx7_ccm.c:imx7_ccm_class_init (1x)
       623 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/imx31_ccm.c:imx31_ccm_class_init (1x)
       623 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/imx6_ccm.c:imx6_ccm_class_init (1x)
       623 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/imx6ul_ccm.c:imx6ul_ccm_class_init (1x)
       605 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/aspeed.c:aspeed_machine_palmetto_class_init (1x)
       595 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/aspeed.c:aspeed_machine_bletchley_class_init (1x)
       595 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/aspeed.c:aspeed_machine_fuji_class_init (1x)
       594 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/aspeed.c:aspeed_machine_g220a_class_init (1x)
       594 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/aspeed.c:aspeed_machine_fp5280g2_class_init (1x)
       594 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/aspeed.c:aspeed_machine_tacoma_class_init (1x)
       594 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/aspeed.c:aspeed_machine_rainier_class_init (1x)
       594 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/aspeed.c:aspeed_machine_ast2600_evb_class_init (1x)
       594 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/aspeed.c:aspeed_machine_qcom_firework_class_init (1x)
       593 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/aspeed.c:aspeed_machine_witherspoon_class_init (1x)
       593 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/aspeed.c:aspeed_machine_ast2500_evb_class_init (1x)
       592 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/aspeed.c:aspeed_machine_sonorapass_class_init (1x)
       588 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/npcm7xx_boards.c:gbs_bmc_machine_class_init (1x)
       588 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/npcm7xx_boards.c:gsj_machine_class_init (1x)
       588 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/npcm7xx_boards.c:kudo_bmc_machine_class_init (1x)
       576 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/npcm7xx_boards.c:npcm750_evb_machine_class_init (1x)
       560 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/pci/pci.c:pcie_bus_class_init (2x)
       475 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../backends/hostmem-ram.c:ram_backend_class_init (1x)
       458 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/sd/allwinner-sdhost.c:allwinner_sdhost_sun4i_class_init (1x)
       458 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/sd/allwinner-sdhost.c:allwinner_sdhost_sun5i_class_init (1x)
       422 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/tosa.c:tosa_ssp_class_init (1x)
       402 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/char/virtio-console.c:virtconsole_class_init (1x)
       395 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../backends/cryptodev-builtin.c:cryptodev_builtin_class_init (1x)
       363 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../net/colo-compare.c:colo_compare_class_init (1x)
       363 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../net/can/can_core.c:can_bus_class_init (1x)
       359 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/main-loop.c:main_loop_class_init (1x)
       356 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/rtc/allwinner-rtc.c:allwinner_rtc_sun4i_class_init (1x)
       356 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/rtc/allwinner-rtc.c:allwinner_rtc_sun6i_class_init (1x)
       350 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/hcd-xhci-pci.c:qemu_xhci_class_init (1x)
       350 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/scsi/lsi53c895a.c:lsi53c810_class_init (1x)
       339 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/gpio/aspeed_gpio.c:aspeed_gpio_ast2600_3_3v_class_init (1x)
       339 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/gpio/aspeed_gpio.c:aspeed_gpio_1030_class_init (1x)
       339 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/gpio/aspeed_gpio.c:aspeed_gpio_2500_class_init (1x)
       339 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/gpio/aspeed_gpio.c:aspeed_gpio_ast2400_class_init (1x)
       339 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/gpio/aspeed_gpio.c:aspeed_gpio_ast2600_1_8v_class_init (1x)
       335 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/nvram/npcm7xx_otp.c:npcm7xx_fuse_array_class_init (1x)
       335 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/nvram/npcm7xx_otp.c:npcm7xx_key_storage_class_init (1x)
       329 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/dev-hid.c:usb_hid_class_initfn (1x)
       328 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/dev-storage-bot.c:usb_msd_class_bot_initfn (1x)
       323 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../backends/rng-builtin.c:rng_builtin_class_init (1x)
       317 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/tosa.c:tosa_dac_class_init (1x)
       317 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/pxa2xx.c:pxa2xx_i2c_slave_class_init (1x)
       315 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/xilinx_axienet.c:xilinx_enet_control_stream_class_init (1x)
       315 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/net/xilinx_axienet.c:xilinx_enet_data_stream_class_init (1x)
       313 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/imx6_src.c:imx6_src_class_init (1x)
       313 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/aspeed_i3c.c:aspeed_i3c_class_init (1x)
       313 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/ide/ahci-allwinner.c:allwinner_ahci_class_init (1x)
       313 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/timer/imx_epit.c:imx_epit_class_init (1x)
       313 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/aspeed_vic.c:aspeed_vic_class_init (1x)
       313 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/aspeed_sbc.c:aspeed_ast2600_sbc_class_init (1x)
       313 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/imx-usb-phy.c:imx_usbphy_class_init (1x)
       313 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/ssi/imx_spi.c:imx_spi_class_init (1x)
       313 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/imx_rngc.c:imx_rngc_class_init (1x)
       313 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/i2c/imx_i2c.c:imx_i2c_class_init (1x)
       313 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/i2c/microbit_i2c.c:microbit_i2c_class_init (1x)
       313 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/sd/npcm7xx_sdhci.c:npcm7xx_sdhci_class_init (1x)
       312 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/audio/marvell_88w8618.c:mv88w8618_audio_class_init (1x)
       312 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/scsi/esp.c:sysbus_esp_class_init (1x)
       311 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/timer/cmsdk-apb-dualtimer.c:cmsdk_apb_dualtimer_class_init (1x)
       311 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/bcm2835_mbox.c:bcm2835_mbox_class_init (1x)
       311 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/ssi/mss-spi.c:mss_spi_class_init (1x)
       311 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/bcm2835_thermal.c:bcm2835_thermal_class_init (1x)
       311 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/timer/cmsdk-apb-timer.c:cmsdk_apb_timer_class_init (1x)
       311 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/timer/armv7m_systick.c:systick_class_init (1x)
       311 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/gpio/gpio_key.c:gpio_key_class_init (1x)
       311 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/timer/bcm2835_systmr.c:bcm2835_systmr_class_init (1x)
       311 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/pxa2xx.c:pxa2xx_rtc_sysbus_class_init (1x)
       311 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/bcm2835_mphi.c:mphi_class_init (1x)
       311 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/strongarm.c:strongarm_ssp_class_init (1x)
       311 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/strongarm.c:strongarm_rtc_sysbus_class_init (1x)
       311 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/timer/sse-counter.c:sse_counter_class_init (1x)
       311 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/ssi/pl022.c:pl022_class_init (1x)
       311 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/gpio/bcm2835_gpio.c:bcm2835_gpio_class_init (1x)
       311 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/watchdog/cmsdk-apb-watchdog.c:cmsdk_apb_watchdog_class_init (1x)
       311 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/imx7_ccm.c:imx7_analog_class_init (1x)
       311 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/imx_gpcv2.c:imx_gpcv2_class_init (1x)
       311 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/allwinner-a10-pic.c:aw_a10_pic_class_init (1x)
       311 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/aspeed_peci.c:aspeed_peci_class_init (1x)
       311 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/rtc/aspeed_rtc.c:aspeed_rtc_class_init (1x)
       311 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/display/exynos4210_fimd.c:exynos4210_fimd_class_init (1x)
       311 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/dma/bcm2835_dma.c:bcm2835_dma_class_init (1x)
       311 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/imx_avic.c:imx_avic_class_init (1x)
       311 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/gpio/nrf51_gpio.c:nrf51_gpio_class_init (1x)
       311 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/display/ramfb-standalone.c:ramfb_class_initfn (1x)
       311 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/highbank.c:highbank_regs_class_init (1x)
       310 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/display/pl110.c:pl110_class_init (1x)
       310 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/sd/pl181.c:pl181_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/i2c/exynos4210_i2c.c:exynos4210_i2c_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/armsse-mhu.c:armsse_mhu_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/spitz.c:spitz_keyboard_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/pxa2xx.c:pxa2xx_ssp_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/bcm2835_rng.c:bcm2835_rng_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/stm32f4xx_exti.c:stm32f4xx_exti_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/strongarm.c:strongarm_gpio_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/ssi/stm32f2xx_spi.c:stm32f2xx_spi_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/bcm2835_ic.c:bcm2835_ic_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/timer/exynos4210_mct.c:exynos4210_mct_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/strongarm.c:strongarm_pic_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/musicpal.c:musicpal_lcd_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/bcm2835_powermgt.c:bcm2835_powermgt_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/pxa2xx_pic.c:pxa2xx_pic_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/sd/bcm2835_sdhost.c:bcm2835_sdhost_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/gpio/zaurus.c:scoop_sysbus_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/musicpal.c:mv88w8618_pit_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/allwinner-h3-ccu.c:allwinner_h3_ccu_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/adc/zynq-xadc.c:zynq_xadc_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/exynos4210_rng.c:exynos4210_rng_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/exynos4210_clk.c:exynos4210_clk_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/pl190.c:pl190_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/sd/pxa2xx_mmci.c:pxa2xx_mmci_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/dma/xlnx-zynq-devcfg.c:xlnx_zynq_devcfg_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/exynos4210_pmu.c:exynos4210_pmu_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/musicpal.c:musicpal_gpio_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/stm32f4xx_syscfg.c:stm32f4xx_syscfg_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/musicpal.c:mv88w8618_pic_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/armsse-cpu-pwrctrl.c:pwrctrl_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/allwinner-cpucfg.c:allwinner_cpucfg_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/strongarm.c:strongarm_ppc_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/allwinner-h3-sysctrl.c:allwinner_h3_sysctrl_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/timer/exynos4210_pwm.c:exynos4210_pwm_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/arm_gicv3_its_common.c:gicv3_its_common_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/mem/npcm7xx_mc.c:npcm7xx_mc_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/bcm2836_control.c:bcm2836_control_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/timer/stellaris-gptm.c:stellaris_gptm_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/timer/cadence_ttc.c:cadence_ttc_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/adc/stm32f2xx_adc.c:stm32f2xx_adc_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/mst_fpga.c:mst_fpga_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/timer/digic-timer.c:digic_timer_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/usb/tusb6010.c:tusb6010_class_init (1x)
       309 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/rtc/exynos4210_rtc.c:exynos4210_rtc_class_init (1x)
       308 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/i2c/i2c_mux_pca954x.c:pca9548_class_init (1x)
       308 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/i2c/i2c_mux_pca954x.c:pca9546_class_init (1x)
       308 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/i2c/bitbang_i2c.c:gpio_i2c_class_init (1x)
       307 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/bcm2835_peripherals.c:bcm2835_peripherals_class_init (1x)
       307 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/integratorcp.c:icp_control_class_init (1x)
       307 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/musicpal.c:musicpal_key_class_init (1x)
       307 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/versatilepb.c:vpb_sic_class_init (1x)
       307 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/stellaris.c:stellaris_i2c_class_init (1x)
       307 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/imx7_gpr.c:imx7_gpr_class_init (1x)
       307 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/imx7_snvs.c:imx7_snvs_class_init (1x)
       307 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/realview_gic.c:realview_gic_class_init (1x)
       307 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/stellaris.c:stellaris_adc_class_init (1x)
       307 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/stm32f2xx_syscfg.c:stm32f2xx_syscfg_class_init (1x)
       307 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/integratorcp.c:icp_pic_class_init (1x)
       307 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/musicpal.c:mv88w8618_wlan_class_init (1x)
       307 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/exynos4210.c:exynos4210_class_init (1x)
       307 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/musicpal.c:mv88w8618_flashcfg_class_init (1x)
       307 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../net/filter-replay.c:filter_replay_class_init (1x)
       305 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/vmcoreinfo.c:vmcoreinfo_device_class_init (1x)
       304 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/fsl-imx31.c:fsl_imx31_class_init (1x)
       303 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/bcm2835_cprman.c:pll_class_init (1x)
       303 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/bcm2835_cprman.c:clock_mux_class_init (1x)
       303 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/npcm7xx_clk.c:npcm7xx_clk_pll_class_init (1x)
       303 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/npcm7xx_clk.c:npcm7xx_clk_divider_class_init (1x)
       303 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/bcm2835_cprman.c:pll_channel_class_init (1x)
       303 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/npcm7xx_clk.c:npcm7xx_clk_sel_class_init (1x)
       302 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/allwinner-a10.c:aw_a10_class_init (1x)
       302 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/allwinner-h3.c:allwinner_h3_class_init (1x)
       302 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/digic.c:digic_class_init (1x)
       301 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/scsi/esp.c:esp_class_init (1x)
       301 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/bcm2835_cprman.c:dsi0hsck_mux_class_init (1x)
       300 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/register.c:register_class_init (1x)
       299 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/virt.c:virt_7_2_class_init (1x)
       297 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/npcm7xx.c:npcm750_class_init (1x)
       295 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/sd/sdhci.c:sdhci_bus_class_init (1x)
       295 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/sd/pl181.c:pl181_bus_class_init (1x)
       295 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/sd/pxa2xx_mmci.c:pxa2xx_mmci_bus_class_init (1x)
       293 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/sd/allwinner-sdhost.c:allwinner_sdhost_bus_class_init (1x)
       273 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/sysbus.c:system_bus_class_init (1x)
       273 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/ide/qdev.c:ide_bus_class_init (1x)
       271 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/char/virtio-serial-bus.c:virtser_bus_class_init (1x)
        74 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/aspeed.c:aspeed_minibmc_machine_ast1030_evb_class_init (1x)
        70 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/aspeed.c:aspeed_machine_supermicrox11_bmc_class_init (1x)
        69 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/aspeed.c:aspeed_machine_fby35_class_init (1x)
        67 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/mps2.c:mps2_an500_class_init (1x)
        66 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/musca.c:musca_b1_class_init (1x)
        66 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/mps2.c:mps2_an511_class_init (1x)
        66 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/musca.c:musca_a_class_init (1x)
        66 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/mps2.c:mps2_an386_class_init (1x)
        66 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/mps2.c:mps2_an385_class_init (1x)
        63 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/spitz.c:borzoipda_class_init (1x)
        63 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/spitz.c:terrierpda_class_init (1x)
        63 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/vexpress.c:vexpress_a9_class_init (1x)
        63 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/spitz.c:akitapda_class_init (1x)
        63 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/spitz.c:spitzpda_class_init (1x)
        52 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../backends/tpm/tpm_passthrough.c:tpm_passthrough_class_init (1x)
        50 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../backends/tpm/tpm_emulator.c:tpm_emulator_class_init (1x)
        47 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../io/channel-socket.c:qio_channel_socket_class_init (1x)
        45 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../io/channel-tls.c:qio_channel_tls_class_init (1x)
        43 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/xx-arm-board.c:machine_xx_arm_class_init (1x)
        43 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../io/channel-websock.c:qio_channel_websock_class_init (1x)
        41 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/orangepi.c:orangepi_machine_init_class_init (1x)
        41 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../chardev/char-mux.c:char_mux_class_init (1x)
        41 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../io/channel-file.c:qio_channel_file_class_init (1x)
        41 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../io/channel-null.c:qio_channel_null_class_init (1x)
        39 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/nseries.c:n810_class_init (1x)
        39 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../migration/channel-block.c:qio_channel_block_class_init (1x)
        39 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../io/channel-command.c:qio_channel_command_class_init (1x)
        39 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/cubieboard.c:cubieboard_machine_init_class_init (1x)
        39 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../io/channel-buffer.c:qio_channel_buffer_class_init (1x)
        39 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/nseries.c:n800_class_init (1x)
        38 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/xilinx_zynq.c:zynq_machine_class_init (1x)
        37 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/musicpal.c:musicpal_machine_init_class_init (1x)
        37 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/palm.c:palmte_machine_init_class_init (1x)
        37 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/highbank.c:highbank_class_init (1x)
        37 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/collie.c:collie_machine_class_init (1x)
        37 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/highbank.c:midway_class_init (1x)
        37 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/versatilepb.c:versatilepb_class_init (1x)
        37 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/omap_sx1.c:sx1_machine_v2_class_init (1x)
        37 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/omap_sx1.c:sx1_machine_v1_class_init (1x)
        37 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/versatilepb.c:versatileab_class_init (1x)
        36 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/realview.c:realview_eb_mpcore_class_init (1x)
        36 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/integratorcp.c:integratorcp_machine_init_class_init (1x)
        36 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/null-machine.c:machine_none_machine_init_class_init (1x)
        35 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/exynos4_boards.c:nuri_class_init (1x)
        35 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../chardev/msmouse.c:char_msmouse_class_init (1x)
        35 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../chardev/char-pty.c:char_pty_class_init (1x)
        35 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/sabrelite.c:sabrelite_machine_init_class_init (1x)
        35 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../chardev/wctablet.c:wctablet_chr_class_init (1x)
        35 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/realview.c:realview_eb_class_init (1x)
        35 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/realview.c:realview_pbx_a9_class_init (1x)
        35 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../chardev/char-udp.c:char_udp_class_init (1x)
        35 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/exynos4_boards.c:smdkc210_class_init (1x)
        35 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/digic_boards.c:canon_a1100_machine_init_class_init (1x)
        35 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/virtio/virtio-iommu.c:virtio_iommu_memory_region_class_init (1x)
        34 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/gumstix.c:verdex_class_init (1x)
        34 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/z2.c:z2_machine_init_class_init (1x)
        34 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/imx25_pdk.c:imx25_pdk_machine_init_class_init (1x)
        34 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/stellaris.c:lm3s6965evb_class_init (1x)
        34 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/mainstone.c:mainstone2_machine_init_class_init (1x)
        34 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/stellaris.c:lm3s811evb_class_init (1x)
        34 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/mcimx6ul-evk.c:mcimx6ul_evk_machine_init_class_init (1x)
        34 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/realview.c:realview_pb_a8_class_init (1x)
        34 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/kzm.c:kzm_machine_init_class_init (1x)
        34 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/mcimx7d-sabre.c:mcimx7d_sabre_machine_init_class_init (1x)
        33 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/tosa.c:tosapda_machine_init_class_init (1x)
        33 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/tz-mpc.c:tz_mpc_iommu_memory_region_class_init (1x)
        33 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../chardev/char-parallel.c:char_parallel_class_init (1x)
        33 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/xx-common-tcgloop.c:xx_accel_class_init (1x)
        33 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/msf2-som.c:emcraft_sf2_machine_init_class_init (1x)
        33 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../chardev/char-ringbuf.c:char_ringbuf_class_init (1x)
        33 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/mps2.c:mps2_class_init (1x)
        33 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../chardev/char-stdio.c:char_stdio_class_init (1x)
        33 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../chardev/char-serial.c:char_serial_class_init (1x)
        33 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/qtest/qtest.c:qtest_accel_class_init (1x)
        32 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../gdbstub/gdbstub.c:char_gdb_class_init (1x)
        32 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/netduino2.c:netduino2_machine_init_class_init (1x)
        32 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/gumstix.c:connex_class_init (1x)
        32 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/microbit.c:microbit_machine_class_init (1x)
        31 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../chardev/char-file.c:char_file_class_init (1x)
        31 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/stm32vldiscovery.c:stm32vldiscovery_machine_init_class_init (1x)
        31 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/qtest/qtest.c:qtest_accel_ops_class_init (1x)
        31 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/smmuv3.c:smmuv3_iommu_memory_region_class_init (1x)
        31 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../chardev/char-pipe.c:char_pipe_class_init (1x)
        31 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/arm/netduinoplus2.c:netduinoplus2_machine_init_class_init (1x)
        29 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../chardev/char-null.c:char_null_class_init (1x)
        29 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/tcg-accel-ops.c:tcg_accel_ops_class_init (1x)
        29 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../chardev/testdev.c:char_testdev_class_init (1x)
        29 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/xx-common-tcgloop.c:xx_accel_ops_class_init (1x)
         2 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/misc/armv7m_ras.c:armv7m_ras_class_init (1x)
         2 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../backends/confidential-guest-support.c:confidential_guest_support_class_init (1x)
         .               }
    25,074 ( 0.00%)  }
         .           
         .           static void object_init_with_type(Object *obj, TypeImpl *ti)
        49 ( 0.00%)  {
       524 ( 0.00%)      if (type_has_parent(ti)) {
       443 ( 0.00%)          object_init_with_type(obj, type_get_parent(ti));
        11 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_get_parent (1x)
         .               }
         .           
       786 ( 0.00%)      if (ti->instance_init) {
       135 ( 0.00%)          ti->instance_init(obj);
        26 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/qdev.c:device_initfn (1x)
         .               }
        41 ( 0.00%)  }
         .           
         .           static void object_post_init_with_type(Object *obj, TypeImpl *ti)
         .           {
       786 ( 0.00%)      if (ti->instance_post_init) {
        16 ( 0.00%)          ti->instance_post_init(obj);
       641 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/qdev.c:device_post_init (3x)
       107 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../backends/hostmem.c:host_memory_backend_post_init (1x)
         .               }
         .           
       524 ( 0.00%)      if (type_has_parent(ti)) {
       429 ( 0.00%)          object_post_init_with_type(obj, type_get_parent(ti));
     1,254 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_get_parent (114x)
         .               }
         .           }
         .           
         .           bool object_apply_global_props(Object *obj, const GPtrArray *props,
         .                                          Error **errp)
       408 ( 0.00%)  {
         .               int i;
         .           
        68 ( 0.00%)      if (!props) {
        34 ( 0.00%)          return true;
         .               }
         .           
        64 ( 0.00%)      for (i = 0; i < props->len; i++) {
         .                   GlobalProperty *p = g_ptr_array_index(props, i);
         .                   Error *err = NULL;
         .           
         .                   if (object_dynamic_cast(obj, p->driver) == NULL) {
         .                       continue;
         .                   }
         .                   if (p->optional && !object_property_find(obj, p->property)) {
         .                       continue;
-- line 409 ----------------------------------------
-- line 422 ----------------------------------------
         .                           return false;
         .                       } else {
         .                           warn_report_err(err);
         .                       }
         .                   }
         .               }
         .           
         .               return true;
       408 ( 0.00%)  }
         .           
         .           /*
         .            * Global property defaults
         .            * Slot 0: accelerator's global property defaults
         .            * Slot 1: machine's global property defaults
         .            * Slot 2: global properties from legacy command line option
         .            * Each is a GPtrArray of of GlobalProperty.
         .            * Applied in order, later entries override earlier ones.
-- line 438 ----------------------------------------
-- line 459 ----------------------------------------
         .               g_ptr_array_add(object_compat_props[2], g);
         .           }
         .           
         .           /*
         .            * Set machine's global property defaults to @compat_props.
         .            * May be called at most once.
         .            */
         .           void object_set_machine_compat_props(GPtrArray *compat_props)
         1 ( 0.00%)  {
         2 ( 0.00%)      assert(!object_compat_props[1]);
         2 ( 0.00%)      object_compat_props[1] = compat_props;
         .           }
         .           
         .           /*
         .            * Set accelerator's global property defaults to @compat_props.
         .            * May be called at most once.
         .            */
         .           void object_set_accelerator_compat_props(GPtrArray *compat_props)
         1 ( 0.00%)  {
         2 ( 0.00%)      assert(!object_compat_props[0]);
         2 ( 0.00%)      object_compat_props[0] = compat_props;
         .           }
         .           
         .           void object_apply_compat_props(Object *obj)
        45 ( 0.00%)  {
         .               int i;
         .           
         .               for (i = 0; i < ARRAY_SIZE(object_compat_props); i++) {
       108 ( 0.00%)          object_apply_global_props(obj, object_compat_props[i],
       765 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_apply_global_props (27x)
         .                                             i == 2 ? &error_fatal : &error_abort);
         .               }
        27 ( 0.00%)  }
         .           
         .           static void object_class_property_init_all(Object *obj)
         .           {
         .               ObjectPropertyIterator iter;
         .               ObjectProperty *prop;
         .           
       714 ( 0.00%)      object_class_property_iter_init(&iter, object_get_class(obj));
     4,312 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_class_property_iter_init (98x)
       294 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_get_class (98x)
     1,587 ( 0.00%)      while ((prop = object_property_iter_next(&iter))) {
    42,574 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_iter_next (302x)
       744 ( 0.00%)          if (prop->init) {
       224 ( 0.00%)              prop->init(obj, prop);
    45,410 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_init_defval (53x)
         .                   }
         .               }
         .           }
         .           
         .           static void object_initialize_with_type(Object *obj, size_t size, TypeImpl *type)
     1,309 ( 0.00%)  {
         .               type_initialize(type);
         .           
       357 ( 0.00%)      g_assert(type->instance_size >= sizeof(Object));
       238 ( 0.00%)      g_assert(type->abstract == false);
       238 ( 0.00%)      g_assert(size >= type->instance_size);
         .           
         .               memset(obj, 0, type->instance_size);
       238 ( 0.00%)      obj->class = type->class;
       238 ( 0.00%)      object_ref(obj);
       882 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_ref (98x)
         .               object_class_property_init_all(obj);
       714 ( 0.00%)      obj->properties = g_hash_table_new_full(g_str_hash, g_str_equal,
    79,009 ( 0.00%)  => ???:0x0000000004e3b5d0 (98x)
         .                                                       NULL, object_property_free);
         .               object_init_with_type(obj, type);
         .               object_post_init_with_type(obj, type);
     1,071 ( 0.00%)  }
         .           
         .           void object_initialize(void *data, size_t size, const char *typename)
       130 ( 0.00%)  {
         .               TypeImpl *type = type_get_by_name(typename);
         .           
         .           #ifdef CONFIG_MODULES
         .               if (!type) {
         .                   int rv = module_load_qom(typename, &error_fatal);
         .                   if (rv > 0) {
         .                       type = type_get_by_name(typename);
         .                   } else {
         .                       error_report("missing object type '%s'", typename);
         .                       exit(1);
         .                   }
         .               }
         .           #endif
        52 ( 0.00%)      if (!type) {
         .                   error_report("missing object type '%s'", typename);
         .                   abort();
         .               }
         .           
        78 ( 0.00%)      object_initialize_with_type(data, size, type);
   292,381 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_initialize_with_type (18x)
        78 ( 0.00%)  }
         .           
         .           bool object_initialize_child_with_props(Object *parentobj,
         .                                                   const char *propname,
         .                                                   void *childobj, size_t size,
         .                                                   const char *type,
         .                                                   Error **errp, ...)
        35 ( 0.00%)  {
         .               va_list vargs;
         .               bool ok;
         .           
        30 ( 0.00%)      va_start(vargs, errp);
        20 ( 0.00%)      ok = object_initialize_child_with_propsv(parentobj, propname,
   185,134 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_initialize_child_with_propsv (1x)
         .                                                        childobj, size, type, errp,
         .                                                        vargs);
         .               va_end(vargs);
        10 ( 0.00%)      return ok;
        25 ( 0.00%)  }
         .           
         .           bool object_initialize_child_with_propsv(Object *parentobj,
         .                                                    const char *propname,
         .                                                    void *childobj, size_t size,
         .                                                    const char *type,
         .                                                    Error **errp, va_list vargs)
        60 ( 0.00%)  {
         .               bool ok = false;
         .               Object *obj;
         .               UserCreatable *uc;
         .           
        10 ( 0.00%)      object_initialize(childobj, size, type);
   182,061 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_initialize (1x)
         .               obj = OBJECT(childobj);
         .           
        35 ( 0.00%)      if (!object_set_propv(obj, errp, vargs)) {
        22 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_set_propv (1x)
         .                   goto out;
         .               }
         .           
        20 ( 0.00%)      object_property_add_child(parentobj, propname, obj);
     2,571 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_add_child (1x)
         .           
        20 ( 0.00%)      uc = (UserCreatable *)object_dynamic_cast(obj, TYPE_USER_CREATABLE);
       412 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_dynamic_cast (1x)
        10 ( 0.00%)      if (uc) {
         .                   if (!user_creatable_complete(uc, errp)) {
         .                       object_unparent(obj);
         .                       goto out;
         .                   }
         .               }
         .           
         .               ok = true;
         .           
-- line 591 ----------------------------------------
-- line 593 ----------------------------------------
         .               /*
         .                * We want @obj's reference to be 1 on success, 0 on failure.
         .                * On success, it's 2: one taken by object_initialize(), and one
         .                * by object_property_add_child().
         .                * On failure in object_initialize() or earlier, it's 1.
         .                * On failure afterwards, it's also 1: object_unparent() releases
         .                * the reference taken by object_property_add_child().
         .                */
        10 ( 0.00%)      object_unref(obj);
        28 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_unref (1x)
         .               return ok;
        35 ( 0.00%)  }
         .           
         .           void object_initialize_child_internal(Object *parent,
         .                                                 const char *propname,
         .                                                 void *child, size_t size,
         .                                                 const char *type)
        10 ( 0.00%)  {
        20 ( 0.00%)      object_initialize_child_with_props(parent, propname, child, size, type,
   185,158 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_initialize_child_with_props (1x)
         .                                                  &error_abort, NULL);
        10 ( 0.00%)  }
         .           
         .           static inline bool object_property_is_child(ObjectProperty *prop)
         .           {
     9,339 ( 0.00%)      return strstart(prop->type, "child<", NULL);
       459 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/cutils.c:strstart (9x)
         .           }
         .           
         .           static void object_property_del_all(Object *obj)
         .           {
        20 ( 0.00%)      g_autoptr(GHashTable) done = g_hash_table_new(NULL, NULL);
     1,373 ( 0.00%)  => ???:0x0000000004e3d240 (2x)
         .               ObjectProperty *prop;
         .               ObjectPropertyIterator iter;
         .               bool released;
         .           
         .               do {
         .                   released = false;
        30 ( 0.00%)          object_property_iter_init(&iter, obj);
       248 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_iter_init (8x)
       290 ( 0.00%)          while ((prop = object_property_iter_next(&iter)) != NULL) {
     5,636 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_iter_next (44x)
       260 ( 0.00%)              if (g_hash_table_add(done, prop)) {
     9,005 ( 0.00%)  => ???:0x0000000004e3c710 (42x)
        84 ( 0.00%)                  if (prop->release) {
        24 ( 0.00%)                      prop->release(obj, prop->name, prop->opaque);
    10,355 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_finalize_child_property'2 (2x)
        66 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_release_link_property (4x)
         .                               released = true;
         .                               break;
         .                           }
         .                       }
         .                   }
         6 ( 0.00%)      } while (released);
         .           
         8 ( 0.00%)      g_hash_table_unref(obj->properties);
     2,084 ( 0.00%)  => ???:0x0000000004e3c1e0 (2x)
         4 ( 0.00%)  }
         .           
         .           static void object_property_del_child(Object *obj, Object *child)
         .           {
         .               ObjectProperty *prop;
         .               GHashTableIter iter;
         .               gpointer key, value;
         .           
        14 ( 0.00%)      g_hash_table_iter_init(&iter, obj->properties);
        24 ( 0.00%)  => ???:0x0000000004e3b910 (2x)
       512 ( 0.00%)      while (g_hash_table_iter_next(&iter, &key, &value)) {
     4,706 ( 0.00%)  => ???:0x0000000004e3be50 (85x)
        85 ( 0.00%)          prop = value;
       188 ( 0.00%)          if (object_property_is_child(prop) && prop->opaque == child) {
         6 ( 0.00%)              if (prop->release) {
         8 ( 0.00%)                  prop->release(obj, prop->name, prop->opaque);
    32,636 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_finalize_child_property (2x)
         2 ( 0.00%)                  prop->release = NULL;
         .                       }
         .                       break;
         .                   }
         .               }
         8 ( 0.00%)      g_hash_table_iter_init(&iter, obj->properties);
        24 ( 0.00%)  => ???:0x0000000004e3b910 (2x)
       512 ( 0.00%)      while (g_hash_table_iter_next(&iter, &key, &value)) {
     4,706 ( 0.00%)  => ???:0x0000000004e3be50 (85x)
        85 ( 0.00%)          prop = value;
       188 ( 0.00%)          if (object_property_is_child(prop) && prop->opaque == child) {
         4 ( 0.00%)              g_hash_table_iter_remove(&iter);
       890 ( 0.00%)  => ???:0x0000000004e3ba50 (2x)
         2 ( 0.00%)              break;
         .                   }
         .               }
         .           }
         .           
         .           void object_unparent(Object *obj)
        16 ( 0.00%)  {
        12 ( 0.00%)      if (obj->parent) {
         .                   object_property_del_child(obj->parent, obj);
         .               }
        22 ( 0.00%)  }
         .           
         .           static void object_deinit(Object *obj, TypeImpl *type)
         .           {
        36 ( 0.00%)      if (type->instance_finalize) {
         8 ( 0.00%)          type->instance_finalize(obj);
       102 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/qdev.c:device_finalize (2x)
         .               }
         .           
        24 ( 0.00%)      if (type_has_parent(type)) {
        24 ( 0.00%)          object_deinit(obj, type_get_parent(type));
        66 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_get_parent (6x)
         .               }
         .           }
         .           
         .           static void object_finalize(void *data)
         .           {
         .               Object *obj = data;
         8 ( 0.00%)      TypeImpl *ti = obj->class->type;
         .           
         .               object_property_del_all(obj);
         .               object_deinit(obj, ti);
         .           
        12 ( 0.00%)      g_assert(obj->ref == 0);
         8 ( 0.00%)      g_assert(obj->parent == NULL);
        12 ( 0.00%)      if (obj->free) {
         .                   obj->free(obj);
         .               }
         .           }
         .           
         .           /* Find the minimum alignment guaranteed by the system malloc. */
         .           #if __STDC_VERSION__ >= 201112L
         .           typedef max_align_t qemu_max_align_t;
         .           #else
-- line 706 ----------------------------------------
-- line 708 ----------------------------------------
         .               long l;
         .               void *p;
         .               double d;
         .               long double ld;
         .           } qemu_max_align_t;
         .           #endif
         .           
         .           static Object *object_new_with_type(Type type)
       465 ( 0.00%)  {
         .               Object *obj;
         .               size_t size, align;
         .               void (*obj_free)(void *);
         .           
       186 ( 0.00%)      g_assert(type != NULL);
         .               type_initialize(type);
         .           
        93 ( 0.00%)      size = type->instance_size;
        93 ( 0.00%)      align = type->instance_align;
         .           
         .               /*
         .                * Do not use qemu_memalign unless required.  Depending on the
         .                * implementation, extra alignment implies extra overhead.
         .                */
       186 ( 0.00%)      if (likely(align <= __alignof__(qemu_max_align_t))) {
       279 ( 0.00%)          obj = g_malloc(size);
    28,802 ( 0.00%)  => ???:0x0000000004e3b870 (87x)
        93 ( 0.00%)          obj_free = g_free;
         .               } else {
         .                   obj = qemu_memalign(align, size);
         .                   obj_free = qemu_vfree;
         .               }
         .           
       372 ( 0.00%)      object_initialize_with_type(obj, size, type);
   297,541 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_initialize_with_type (80x)
     8,938 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_initialize_with_type'2 (7x)
        93 ( 0.00%)      obj->free = obj_free;
         .           
         .               return obj;
       651 ( 0.00%)  }
         .           
         .           Object *object_new_with_class(ObjectClass *klass)
         2 ( 0.00%)  {
         4 ( 0.00%)      return object_new_with_type(klass->type);
    43,184 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_new_with_type (2x)
         .           }
         .           
         .           Object *object_new(const char *typename)
       270 ( 0.00%)  {
         .               TypeImpl *ti = type_get_by_name(typename);
         .           
       180 ( 0.00%)      return object_new_with_type(ti);
   179,620 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_new_with_type (84x)
     9,104 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_new_with_type'2 (6x)
        90 ( 0.00%)  }
         .           
         .           
         .           Object *object_new_with_props(const char *typename,
         .                                         Object *parent,
         .                                         const char *id,
         .                                         Error **errp,
         .                                         ...)
         9 ( 0.00%)  {
         .               va_list vargs;
         .               Object *obj;
         .           
         6 ( 0.00%)      va_start(vargs, errp);
         2 ( 0.00%)      obj = object_new_with_propv(typename, parent, id, errp, vargs);
   118,474 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_new_with_propv (1x)
         .               va_end(vargs);
         .           
         .               return obj;
         5 ( 0.00%)  }
         .           
         .           
         .           Object *object_new_with_propv(const char *typename,
         .                                         Object *parent,
         .                                         const char *id,
         .                                         Error **errp,
         .                                         va_list vargs)
        13 ( 0.00%)  {
         .               Object *obj;
         .               ObjectClass *klass;
         .               UserCreatable *uc;
         .           
         2 ( 0.00%)      klass = object_class_by_name(typename);
       257 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_class_by_name (1x)
         2 ( 0.00%)      if (!klass) {
         .                   error_setg(errp, "invalid object type: %s", typename);
         .                   return NULL;
         .               }
         .           
         4 ( 0.00%)      if (object_class_is_abstract(klass)) {
         4 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_class_is_abstract (1x)
         .                   error_setg(errp, "object type '%s' is abstract", typename);
         .                   return NULL;
         .               }
         3 ( 0.00%)      obj = object_new_with_type(klass->type);
   115,087 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_new_with_type (1x)
         .           
         6 ( 0.00%)      if (!object_set_propv(obj, errp, vargs)) {
        22 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_set_propv (1x)
         .                   goto error;
         .               }
         .           
         2 ( 0.00%)      if (id != NULL) {
         4 ( 0.00%)          object_property_add_child(parent, id, obj);
     2,599 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_add_child (1x)
         .               }
         .           
         4 ( 0.00%)      uc = (UserCreatable *)object_dynamic_cast(obj, TYPE_USER_CREATABLE);
       424 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_dynamic_cast (1x)
         2 ( 0.00%)      if (uc) {
         .                   if (!user_creatable_complete(uc, errp)) {
         .                       if (id != NULL) {
         .                           object_unparent(obj);
         .                       }
         .                       goto error;
         .                   }
         .               }
         .           
         2 ( 0.00%)      object_unref(obj);
        28 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_unref (1x)
         .               return obj;
         .           
         .            error:
         .               object_unref(obj);
         .               return NULL;
         9 ( 0.00%)  }
         .           
         .           
         .           bool object_set_props(Object *obj,
         .                                Error **errp,
         .                                ...)
         .           {
         .               va_list vargs;
         .               bool ret;
-- line 829 ----------------------------------------
-- line 834 ----------------------------------------
         .           
         .               return ret;
         .           }
         .           
         .           
         .           bool object_set_propv(Object *obj,
         .                                Error **errp,
         .                                va_list vargs)
        42 ( 0.00%)  {
         .               const char *propname;
         .           
        44 ( 0.00%)      propname = va_arg(vargs, char *);
        12 ( 0.00%)      while (propname != NULL) {
         .                   const char *value = va_arg(vargs, char *);
         .           
         .                   g_assert(value != NULL);
         .                   if (!object_property_parse(obj, propname, value, errp)) {
         .                       return false;
         .                   }
         4 ( 0.00%)          propname = va_arg(vargs, char *);
         .               }
         .           
         6 ( 0.00%)      return true;
        24 ( 0.00%)  }
         .           
         .           
         .           Object *object_dynamic_cast(Object *obj, const char *typename)
     1,832 ( 0.00%)  {
     4,580 ( 0.00%)      if (obj && object_class_dynamic_cast(object_get_class(obj), typename)) {
    92,341 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_class_dynamic_cast (458x)
     1,374 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_get_class (458x)
         .                   return obj;
         .               }
         .           
       439 ( 0.00%)      return NULL;
     2,290 ( 0.00%)  }
         .           
         .           Object *object_dynamic_cast_assert(Object *obj, const char *typename,
         .                                              const char *file, int line, const char *func)
 8,591,448 ( 0.01%)  {
         .               trace_object_dynamic_cast_assert(obj ? obj->class->type->name : "(null)",
         .                                                typename, file, line, func);
         .           
         .           #ifdef CONFIG_QOM_CAST_DEBUG
         .               int i;
         .               Object *inst;
         .           
         .               for (i = 0; obj && i < OBJECT_CLASS_CAST_CACHE; i++) {
-- line 879 ----------------------------------------
-- line 898 ----------------------------------------
         .                                  qatomic_read(&obj->class->object_cast_cache[i]));
         .                   }
         .                   qatomic_set(&obj->class->object_cast_cache[i - 1], typename);
         .               }
         .           
         .           out:
         .           #endif
         .               return obj;
 4,295,724 ( 0.01%)  }
         .           
         .           ObjectClass *object_class_dynamic_cast(ObjectClass *class,
         .                                                  const char *typename)
41,242,952 ( 0.06%)  {
     2,362 ( 0.00%)      ObjectClass *ret = NULL;
         .               TypeImpl *target_type;
         .               TypeImpl *type;
         .           
10,310,738 ( 0.01%)      if (!class) {
         .                   return NULL;
         .               }
         .           
         .               /* A simple fast path that can trigger a lot for leaf classes.  */
15,466,107 ( 0.02%)      type = class->type;
10,310,738 ( 0.01%)      if (type->name == typename) {
         .                   return class;
         .               }
         .           
         .               target_type = type_get_by_name(typename);
10,310,738 ( 0.01%)      if (!target_type) {
         .                   /* target class type unknown, so fail the cast */
         .                   return NULL;
         .               }
         .           
25,775,408 ( 0.04%)      if (type->class->interfaces &&
15,464,442 ( 0.02%)              type_is_ancestor(target_type, type_interface)) {
175,244,240 ( 0.24%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_is_ancestor (5,154,814x)
       521 ( 0.00%)          int found = 0;
         .                   GSList *i;
         .           
     6,456 ( 0.00%)          for (i = class->interfaces; i; i = i->next) {
     1,631 ( 0.00%)              ObjectClass *target_class = i->data;
         .           
     1,631 ( 0.00%)              if (type_is_ancestor(target_class->type, target_type)) {
         .                           ret = target_class;
       572 ( 0.00%)                  found++;
         .                       }
         .                    }
         .           
         .                   /* The match was ambiguous, don't allow a cast */
     1,042 ( 0.00%)          if (found > 1) {
         .                       ret = NULL;
         .                   }
25,773,695 ( 0.04%)      } else if (type_is_ancestor(type, target_type)) {
144,346,584 ( 0.20%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_is_ancestor (5,154,739x)
         .                   ret = class;
         .               }
         .           
         .               return ret;
46,398,321 ( 0.06%)  }
         .           
         .           ObjectClass *object_class_dynamic_cast_assert(ObjectClass *class,
         .                                                         const char *typename,
         .                                                         const char *file, int line,
         .                                                         const char *func)
30,922,764 ( 0.04%)  {
         .               ObjectClass *ret;
         .           
         .               trace_object_class_dynamic_cast_assert(class ? class->type->name : "(null)",
         .                                                      typename, file, line, func);
         .           
         .           #ifdef CONFIG_QOM_CAST_DEBUG
         .               int i;
         .           
         .               for (i = 0; class && i < OBJECT_CLASS_CAST_CACHE; i++) {
         .                   if (qatomic_read(&class->class_cast_cache[i]) == typename) {
         .                       ret = class;
         .                       goto out;
         .                   }
         .               }
         .           #else
46,382,974 ( 0.06%)      if (!class || !class->interfaces) {
         .                   return class;
         .               }
         .           #endif
         .           
 5,153,501 ( 0.01%)      ret = object_class_dynamic_cast(class, typename);
1,216,390,809 ( 1.67%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_class_dynamic_cast (5,153,501x)
10,307,002 ( 0.01%)      if (!ret && class) {
         .                   fprintf(stderr, "%s:%d:%s: Object %p is not an instance of type %s\n",
         .                           file, line, func, class, typename);
         .                   abort();
         .               }
         .           
         .           #ifdef CONFIG_QOM_CAST_DEBUG
         .               if (class && ret == class) {
         .                   for (i = 1; i < OBJECT_CLASS_CAST_CACHE; i++) {
-- line 990 ----------------------------------------
-- line 991 ----------------------------------------
         .                       qatomic_set(&class->class_cast_cache[i - 1],
         .                                  qatomic_read(&class->class_cast_cache[i]));
         .                   }
         .                   qatomic_set(&class->class_cast_cache[i - 1], typename);
         .               }
         .           out:
         .           #endif
         .               return ret;
30,923,057 ( 0.04%)  }
         .           
         .           const char *object_get_typename(const Object *obj)
       135 ( 0.00%)  {
       405 ( 0.00%)      return obj->class->type->name;
       135 ( 0.00%)  }
         .           
         .           ObjectClass *object_get_class(Object *obj)
 5,151,938 ( 0.01%)  {
 5,151,938 ( 0.01%)      return obj->class;
 5,151,938 ( 0.01%)  }
         .           
         .           bool object_class_is_abstract(ObjectClass *klass)
       298 ( 0.00%)  {
       596 ( 0.00%)      return klass->type->abstract;
       298 ( 0.00%)  }
         .           
         .           const char *object_class_get_name(ObjectClass *klass)
       122 ( 0.00%)  {
       244 ( 0.00%)      return klass->type->name;
       122 ( 0.00%)  }
         .           
         .           ObjectClass *object_class_by_name(const char *typename)
        99 ( 0.00%)  {
         .               TypeImpl *type = type_get_by_name(typename);
         .           
        66 ( 0.00%)      if (!type) {
         2 ( 0.00%)          return NULL;
         .               }
         .           
         .               type_initialize(type);
         .           
         4 ( 0.00%)      return type->class;
        74 ( 0.00%)  }
    81,879 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_initialize.part.0'2 (4x)
         .           
         .           ObjectClass *module_object_class_by_name(const char *typename)
         9 ( 0.00%)  {
         .               ObjectClass *oc;
         .           
         9 ( 0.00%)      oc = object_class_by_name(typename);
     2,065 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_class_by_name (9x)
         .           #ifdef CONFIG_MODULES
         .               if (!oc) {
         .                   Error *local_err = NULL;
         .                   int rv = module_load_qom(typename, &local_err);
         .                   if (rv > 0) {
         .                       oc = object_class_by_name(typename);
         .                   } else if (rv < 0) {
         .                       error_report_err(local_err);
         .                   }
         .               }
         .           #endif
         .               return oc;
         .           }
         .           
         .           ObjectClass *object_class_get_parent(ObjectClass *class)
    51,288 ( 0.00%)  {
    12,822 ( 0.00%)      TypeImpl *type = type_get_parent(class->type);
         .           
         .               if (!type) {
         .                   return NULL;
         .               }
         .           
         .               type_initialize(type);
         .           
         .               return type->class;
    64,110 ( 0.00%)  }
         .           
         .           typedef struct OCFData
         .           {
         .               void (*fn)(ObjectClass *klass, void *opaque);
         .               const char *implements_type;
         .               bool include_abstract;
         .               void *opaque;
         .           } OCFData;
         .           
         .           static void object_class_foreach_tramp(gpointer key, gpointer value,
         .                                                  gpointer opaque)
     6,918 ( 0.00%)  {
         .               OCFData *data = opaque;
         .               TypeImpl *type = value;
         .               ObjectClass *k;
         .           
         .               type_initialize(type);
     2,036 ( 0.00%)      k = type->class;
         .           
     4,612 ( 0.00%)      if (!data->include_abstract && type->abstract) {
         .                   return;
         .               }
         .           
     4,960 ( 0.00%)      if (data->implements_type && 
     1,984 ( 0.00%)          !object_class_dynamic_cast(k, data->implements_type)) {
   269,632 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_class_dynamic_cast (992x)
         .                   return;
         .               }
         .           
       420 ( 0.00%)      data->fn(k, data->opaque);
    32,655 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_class_get_list_tramp (105x)
     6,543 ( 0.00%)  }
18,513,661 ( 0.03%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_initialize.part.0 (1,018x)
         .           
         .           void object_class_foreach(void (*fn)(ObjectClass *klass, void *opaque),
         .                                     const char *implements_type, bool include_abstract,
         .                                     void *opaque)
         5 ( 0.00%)  {
         4 ( 0.00%)      OCFData data = { fn, implements_type, include_abstract, opaque };
         .           
         1 ( 0.00%)      enumerating_types = true;
         3 ( 0.00%)      g_hash_table_foreach(type_table_get(), object_class_foreach_tramp, &data);
18,888,124 ( 0.03%)  => ???:0x0000000004e3ceb0 (1x)
         1 ( 0.00%)      enumerating_types = false;
         5 ( 0.00%)  }
         .           
     1,417 ( 0.00%)  static int do_object_child_foreach(Object *obj,
         .                                              int (*fn)(Object *child, void *opaque),
         .                                              void *opaque, bool recurse)
         .           {
         .               GHashTableIter iter;
         .               ObjectProperty *prop;
         .               int ret = 0;
         .           
       545 ( 0.00%)      g_hash_table_iter_init(&iter, obj->properties);
        12 ( 0.00%)  => ???:0x0000000004e3b910 (1x)
     2,329 ( 0.00%)      while (g_hash_table_iter_next(&iter, NULL, (gpointer *)&prop)) {
       195 ( 0.00%)  => ???:0x0000000004e3be50 (4x)
       522 ( 0.00%)          if (object_property_is_child(prop)) {
       216 ( 0.00%)              Object *child = prop->opaque;
         .           
       432 ( 0.00%)              ret = fn(child, opaque);
       867 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/qdev.c:qdev_assert_realized_properly_cb (3x)
       216 ( 0.00%)              if (ret != 0) {
         .                           break;
         .                       }
       324 ( 0.00%)              if (recurse) {
       540 ( 0.00%)                  ret = do_object_child_foreach(child, fn, opaque, true);
    69,817 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:do_object_child_foreach.isra.0'2 (3x)
       216 ( 0.00%)                  if (ret != 0) {
         .                               break;
         .                           }
         .                       }
         .                   }
         .               }
         .               return ret;
     1,199 ( 0.00%)  }
         .           
         .           int object_child_foreach(Object *obj, int (*fn)(Object *child, void *opaque),
         .                                    void *opaque)
         .           {
         .               return do_object_child_foreach(obj, fn, opaque, false);
         .           }
         .           
         .           int object_child_foreach_recursive(Object *obj,
         .                                              int (*fn)(Object *child, void *opaque),
         .                                              void *opaque)
         1 ( 0.00%)  {
         3 ( 0.00%)      return do_object_child_foreach(obj, fn, opaque, true);
    71,174 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:do_object_child_foreach.isra.0 (1x)
         .           }
         .           
         .           static void object_class_get_list_tramp(ObjectClass *klass, void *opaque)
       315 ( 0.00%)  {
         .               GSList **list = opaque;
         .           
       420 ( 0.00%)      *list = g_slist_prepend(*list, klass);
    31,710 ( 0.00%)  => ???:0x0000000004e3ae50 (105x)
       210 ( 0.00%)  }
         .           
         .           GSList *object_class_get_list(const char *implements_type,
         .                                         bool include_abstract)
         5 ( 0.00%)  {
         1 ( 0.00%)      GSList *list = NULL;
         .           
         5 ( 0.00%)      object_class_foreach(object_class_get_list_tramp,
18,888,146 ( 0.03%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_class_foreach (1x)
         .                                    implements_type, include_abstract, &list);
         1 ( 0.00%)      return list;
         5 ( 0.00%)  }
         .           
         .           static gint object_class_cmp(gconstpointer a, gconstpointer b)
         .           {
         .               return strcasecmp(object_class_get_name((ObjectClass *)a),
         .                                 object_class_get_name((ObjectClass *)b));
         .           }
         .           
         .           GSList *object_class_get_list_sorted(const char *implements_type,
         .                                                bool include_abstract)
         .           {
         .               return g_slist_sort(object_class_get_list(implements_type, include_abstract),
         .                                   object_class_cmp);
         .           }
         .           
         .           Object *object_ref(void *objptr)
       540 ( 0.00%)  {
         .               Object *obj = OBJECT(objptr);
         .               uint32_t ref;
         .           
       540 ( 0.00%)      if (!obj) {
         .                   return NULL;
         .               }
       540 ( 0.00%)      ref = qatomic_fetch_inc(&obj->ref);
         .               /* Assert waaay before the integer overflows */
       540 ( 0.00%)      g_assert(ref < INT_MAX);
         .               return obj;
       270 ( 0.00%)  }
         .           
         .           void object_unref(void *objptr)
       540 ( 0.00%)  {
         .               Object *obj = OBJECT(objptr);
       108 ( 0.00%)      if (!obj) {
         .                   return;
         .               }
       200 ( 0.00%)      g_assert(obj->ref > 0);
         .           
         .               /* parent always holds a reference to its children */
       100 ( 0.00%)      if (qatomic_fetch_dec(&obj->ref) == 1) {
         .                   object_finalize(obj);
         .               }
       540 ( 0.00%)  }
         .           
         .           ObjectProperty *
         .           object_property_try_add(Object *obj, const char *name, const char *type,
         .                                   ObjectPropertyAccessor *get,
         .                                   ObjectPropertyAccessor *set,
         .                                   ObjectPropertyRelease *release,
         .                                   void *opaque, Error **errp)
     4,228 ( 0.00%)  {
         .               ObjectProperty *prop;
       604 ( 0.00%)      size_t name_len = strlen(name);
     4,496 ( 0.00%)  => ???:0x0000000004e3b0d0 (281x)
         .           
     1,510 ( 0.00%)      if (name_len >= 3 && !memcmp(name + name_len - 3, "[*]", 4)) {
         .                   int i;
         .                   ObjectProperty *ret = NULL;
        80 ( 0.00%)          char *name_no_array = g_strdup(name);
     3,475 ( 0.00%)  => ???:0x0000000004e3b620 (20x)
         .           
        20 ( 0.00%)          name_no_array[name_len - 3] = '\0';
        43 ( 0.00%)          for (i = 0; i < INT16_MAX; ++i) {
       126 ( 0.00%)              char *full_name = g_strdup_printf("%s[%d]", name_no_array, i);
    27,944 ( 0.00%)  => ???:0x0000000004e3b7e0 (21x)
         .           
       210 ( 0.00%)              ret = object_property_try_add(obj, full_name, type, get, set,
    38,877 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_try_add'2 (21x)
         .                                                     release, opaque, NULL);
        42 ( 0.00%)              g_free(full_name);
     1,995 ( 0.00%)  => ???:0x0000000004e3a950 (21x)
       105 ( 0.00%)              if (ret) {
         .                           break;
         .                       }
         .                   }
        60 ( 0.00%)          g_free(name_no_array);
     1,900 ( 0.00%)  => ???:0x0000000004e3a950 (20x)
        20 ( 0.00%)          assert(ret);
         .                   return ret;
         .               }
         .           
     1,410 ( 0.00%)      if (object_property_find(obj, name) != NULL) {
   232,371 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_find (261x)
        12 ( 0.00%)          error_setg(errp, "attempt to add duplicate property '%s' to object (type '%s')",
        57 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/error.c:error_setg_internal (1x)
         5 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_get_typename (1x)
         .                              name, object_get_typename(obj));
         4 ( 0.00%)          return NULL;
         .               }
         .           
       843 ( 0.00%)      prop = g_malloc0(sizeof(*prop));
    71,206 ( 0.00%)  => ???:0x0000000004e3cc20 (261x)
         .           
       843 ( 0.00%)      prop->name = g_strdup(name);
    56,065 ( 0.00%)  => ???:0x0000000004e3b620 (261x)
       843 ( 0.00%)      prop->type = g_strdup(type);
    60,871 ( 0.00%)  => ???:0x0000000004e3b620 (261x)
         .           
       281 ( 0.00%)      prop->get = get;
       562 ( 0.00%)      prop->set = set;
       281 ( 0.00%)      prop->release = release;
       562 ( 0.00%)      prop->opaque = opaque;
         .           
     1,124 ( 0.00%)      g_hash_table_insert(obj->properties, prop->name, prop);
   112,810 ( 0.00%)  => ???:0x0000000004e3b6a0 (261x)
         .               return prop;
     2,718 ( 0.00%)  }
         .           
         .           ObjectProperty *
         .           object_property_add(Object *obj, const char *name, const char *type,
         .                               ObjectPropertyAccessor *get,
         .                               ObjectPropertyAccessor *set,
         .                               ObjectPropertyRelease *release,
         .                               void *opaque)
       338 ( 0.00%)  {
       507 ( 0.00%)      return object_property_try_add(obj, name, type, get, set, release,
   331,901 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_try_add (169x)
         .                                              opaque, &error_abort);
       338 ( 0.00%)  }
         .           
         .           ObjectProperty *
         .           object_class_property_add(ObjectClass *klass,
         .                                     const char *name,
         .                                     const char *type,
         .                                     ObjectPropertyAccessor *get,
         .                                     ObjectPropertyAccessor *set,
         .                                     ObjectPropertyRelease *release,
         .                                     void *opaque)
    34,216 ( 0.00%)  {
         .               ObjectProperty *prop;
         .           
     7,332 ( 0.00%)      assert(!object_class_property_find(klass, name));
 1,874,360 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_class_property_find (2,444x)
         .           
     7,332 ( 0.00%)      prop = g_malloc0(sizeof(*prop));
   655,249 ( 0.00%)  => ???:0x0000000004e3cc20 (2,444x)
         .           
     7,332 ( 0.00%)      prop->name = g_strdup(name);
   640,299 ( 0.00%)  => ???:0x0000000004e3b620 (2,444x)
     7,332 ( 0.00%)      prop->type = g_strdup(type);
   643,996 ( 0.00%)  => ???:0x0000000004e3b620 (2,444x)
         .           
     2,444 ( 0.00%)      prop->get = get;
     2,444 ( 0.00%)      prop->set = set;
     4,888 ( 0.00%)      prop->release = release;
     4,888 ( 0.00%)      prop->opaque = opaque;
         .           
     9,776 ( 0.00%)      g_hash_table_insert(klass->properties, prop->name, prop);
   867,630 ( 0.00%)  => ???:0x0000000004e3b6a0 (2,444x)
         .           
         .               return prop;
    21,996 ( 0.00%)  }
         .           
         .           ObjectProperty *object_property_find(Object *obj, const char *name)
     2,916 ( 0.00%)  {
         .               ObjectProperty *prop;
       972 ( 0.00%)      ObjectClass *klass = object_get_class(obj);
     1,458 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_get_class (486x)
         .           
       972 ( 0.00%)      prop = object_class_property_find(klass, name);
   353,107 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_class_property_find (486x)
       972 ( 0.00%)      if (prop) {
         .                   return prop;
         .               }
         .           
     1,404 ( 0.00%)      return g_hash_table_lookup(obj->properties, name);
    96,761 ( 0.00%)  => ???:0x0000000004e3bdd0 (468x)
     1,476 ( 0.00%)  }
         .           
         .           ObjectProperty *object_property_find_err(Object *obj, const char *name,
         .                                                    Error **errp)
     1,458 ( 0.00%)  {
       324 ( 0.00%)      ObjectProperty *prop = object_property_find(obj, name);
   184,356 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_find (162x)
       324 ( 0.00%)      if (!prop) {
         .                   error_setg(errp, "Property '%s.%s' not found",
         .                              object_get_typename(obj), name);
         .               }
         .               return prop;
     1,134 ( 0.00%)  }
         .           
         .           void object_property_iter_init(ObjectPropertyIterator *iter,
         .                                          Object *obj)
        60 ( 0.00%)  {
        30 ( 0.00%)      g_hash_table_iter_init(&iter->iter, obj->properties);
       120 ( 0.00%)  => ???:0x0000000004e3b910 (10x)
        30 ( 0.00%)      iter->nextclass = object_get_class(obj);
        30 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_get_class (10x)
        40 ( 0.00%)  }
         .           
         .           ObjectProperty *object_property_iter_next(ObjectPropertyIterator *iter)
     4,230 ( 0.00%)  {
         .               gpointer key, val;
     5,208 ( 0.00%)      while (!g_hash_table_iter_next(&iter->iter, &key, &val)) {
    39,348 ( 0.00%)  => ???:0x0000000004e3be50 (586x)
       858 ( 0.00%)          if (!iter->nextclass) {
         .                       return NULL;
         .                   }
       489 ( 0.00%)          g_hash_table_iter_init(&iter->iter, iter->nextclass->properties);
     1,956 ( 0.00%)  => ???:0x0000000004e3b910 (163x)
       489 ( 0.00%)          iter->nextclass = object_class_get_parent(iter->nextclass);
     2,608 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_class_get_parent (163x)
         .               }
       300 ( 0.00%)      return val;
     3,807 ( 0.00%)  }
         .           
         .           void object_class_property_iter_init(ObjectPropertyIterator *iter,
         .                                                ObjectClass *klass)
       714 ( 0.00%)  {
       357 ( 0.00%)      g_hash_table_iter_init(&iter->iter, klass->properties);
     1,428 ( 0.00%)  => ???:0x0000000004e3b910 (119x)
       357 ( 0.00%)      iter->nextclass = object_class_get_parent(klass);
     1,904 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_class_get_parent (119x)
       476 ( 0.00%)  }
         .           
         .           ObjectProperty *object_class_property_find(ObjectClass *klass, const char *name)
    29,430 ( 0.00%)  {
         .               ObjectClass *parent_klass;
         .           
    34,599 ( 0.00%)      parent_klass = object_class_get_parent(klass);
   200,432 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_class_get_parent (12,527x)
    25,102 ( 0.00%)      if (parent_klass) {
         .                   ObjectProperty *prop =
        39 ( 0.00%)              object_class_property_find(parent_klass, name);
     2,354 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_class_property_find'2 (13x)
    19,215 ( 0.00%)          if (prop) {
         .                       return prop;
         .                   }
         .               }
         .           
    37,637 ( 0.00%)      return g_hash_table_lookup(klass->properties, name);
 1,858,343 ( 0.00%)  => ???:0x0000000004e3bdd0 (12,504x)
    20,615 ( 0.00%)  }
         .           
         .           ObjectProperty *object_class_property_find_err(ObjectClass *klass,
         .                                                          const char *name,
         .                                                          Error **errp)
         .           {
         .               ObjectProperty *prop = object_class_property_find(klass, name);
         .               if (!prop) {
         .                   error_setg(errp, "Property '.%s' not found", name);
-- line 1369 ----------------------------------------
-- line 1399 ----------------------------------------
         .               }
         .               prop->get(obj, v, name, prop->opaque, &err);
         .               error_propagate(errp, err);
         .               return !err;
         .           }
         .           
         .           bool object_property_set(Object *obj, const char *name, Visitor *v,
         .                                    Error **errp)
       216 ( 0.00%)  {
       120 ( 0.00%)      ERRP_GUARD();
        72 ( 0.00%)      ObjectProperty *prop = object_property_find_err(obj, name, errp);
     4,481 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_find_err (8x)
         .           
        36 ( 0.00%)      if (prop == NULL) {
         .                   return false;
         .               }
         .           
        54 ( 0.00%)      if (!prop->set) {
         .                   error_setg(errp, "Property '%s.%s' is not writable",
         .                              object_get_typename(obj), name);
         .                   return false;
         .               }
       108 ( 0.00%)      prop->set(obj, v, name, prop->opaque, errp);
 2,676,112 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:property_set_bool (3x)
    11,367 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_set_link_property (2x)
     6,933 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/machine.c:machine_set_mem (1x)
       428 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/qdev-properties.c:field_prop_set (1x)
       148 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../backends/hostmem.c:host_memory_backend_set_size (1x)
        36 ( 0.00%)      return !*errp;
       180 ( 0.00%)  }
         .           
         .           bool object_property_set_str(Object *obj, const char *name,
         .                                        const char *value, Error **errp)
        60 ( 0.00%)  {
         6 ( 0.00%)      QString *qstr = qstring_from_str(value);
     1,575 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qobject/qstring.c:qstring_from_str (6x)
        48 ( 0.00%)      bool ok = object_property_set_qobject(obj, name, QOBJECT(qstr), errp);
    28,450 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/qom-qobject.c:object_property_set_qobject'2 (3x)
    15,769 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/qom-qobject.c:object_property_set_qobject (3x)
         .           
         .               qobject_unref(qstr);
         6 ( 0.00%)      return ok;
        36 ( 0.00%)  }
         .           
         .           char *object_property_get_str(Object *obj, const char *name,
         .                                         Error **errp)
         .           {
         .               QObject *ret = object_property_get_qobject(obj, name, errp);
         .               QString *qstring;
         .               char *retval;
         .           
-- line 1440 ----------------------------------------
-- line 1450 ----------------------------------------
         .               }
         .           
         .               qobject_unref(ret);
         .               return retval;
         .           }
         .           
         .           bool object_property_set_link(Object *obj, const char *name,
         .                                         Object *value, Error **errp)
        50 ( 0.00%)  {
         .               g_autofree char *path = NULL;
         .           
        10 ( 0.00%)      if (value) {
        15 ( 0.00%)          path = object_get_canonical_path(value);
    36,780 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_get_canonical_path (5x)
         .               }
        45 ( 0.00%)      return object_property_set_str(obj, name, path ?: "", errp);
    45,014 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_set_str (5x)
        35 ( 0.00%)  }
         .           
         .           Object *object_property_get_link(Object *obj, const char *name,
         .                                            Error **errp)
         .           {
         .               char *str = object_property_get_str(obj, name, errp);
         .               Object *target = NULL;
         .           
         .               if (str && *str) {
-- line 1473 ----------------------------------------
-- line 1479 ----------------------------------------
         .               }
         .           
         .               g_free(str);
         .               return target;
         .           }
         .           
         .           bool object_property_set_bool(Object *obj, const char *name,
         .                                         bool value, Error **errp)
        72 ( 0.00%)  {
        16 ( 0.00%)      QBool *qbool = qbool_from_bool(value);
       134 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qobject/qbool.c:qbool_from_bool (2x)
        64 ( 0.00%)      bool ok = object_property_set_qobject(obj, name, QOBJECT(qbool), errp);
 2,677,955 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/qom-qobject.c:object_property_set_qobject (2x)
         .           
         .               qobject_unref(qbool);
         8 ( 0.00%)      return ok;
        48 ( 0.00%)  }
         .           
         .           bool object_property_get_bool(Object *obj, const char *name,
         .                                         Error **errp)
         .           {
         .               QObject *ret = object_property_get_qobject(obj, name, errp);
         .               QBool *qbool;
         .               bool retval;
         .           
-- line 1501 ----------------------------------------
-- line 1511 ----------------------------------------
         .               }
         .           
         .               qobject_unref(ret);
         .               return retval;
         .           }
         .           
         .           bool object_property_set_int(Object *obj, const char *name,
         .                                        int64_t value, Error **errp)
        10 ( 0.00%)  {
         1 ( 0.00%)      QNum *qnum = qnum_from_int(value);
        68 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qobject/qnum.c:qnum_from_int (1x)
         8 ( 0.00%)      bool ok = object_property_set_qobject(obj, name, QOBJECT(qnum), errp);
     1,161 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/qom-qobject.c:object_property_set_qobject (1x)
         .           
         .               qobject_unref(qnum);
         1 ( 0.00%)      return ok;
         6 ( 0.00%)  }
         .           
         .           int64_t object_property_get_int(Object *obj, const char *name,
         .                                           Error **errp)
         .           {
         .               QObject *ret = object_property_get_qobject(obj, name, errp);
         .               QNum *qnum;
         .               int64_t retval;
         .           
-- line 1533 ----------------------------------------
-- line 1541 ----------------------------------------
         .                   retval = -1;
         .               }
         .           
         .               qobject_unref(ret);
         .               return retval;
         .           }
         .           
         .           static void object_property_init_defval(Object *obj, ObjectProperty *prop)
       360 ( 0.00%)  {
       180 ( 0.00%)      Visitor *v = qobject_input_visitor_new(prop->defval);
    27,966 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qapi/qobject-input-visitor.c:qobject_input_visitor_new (60x)
         .           
       180 ( 0.00%)      assert(prop->set != NULL);
       360 ( 0.00%)      prop->set(obj, v, prop->name, prop->opaque, &error_abort);
     9,011 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/qdev-properties.c:field_prop_set (60x)
         .           
       120 ( 0.00%)      visit_free(v);
    11,830 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qapi/qapi-visit-core.c:visit_free (60x)
       180 ( 0.00%)  }
         .           
         .           static void object_property_set_default(ObjectProperty *prop, QObject *defval)
         .           {
     3,576 ( 0.00%)      assert(!prop->defval);
     3,576 ( 0.00%)      assert(!prop->init);
         .           
     1,788 ( 0.00%)      prop->defval = defval;
     3,576 ( 0.00%)      prop->init = object_property_init_defval;
         .           }
         .           
         .           void object_property_set_default_bool(ObjectProperty *prop, bool value)
     1,266 ( 0.00%)  {
       844 ( 0.00%)      object_property_set_default(prop, QOBJECT(qbool_from_bool(value)));
    94,126 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qobject/qbool.c:qbool_from_bool (422x)
       844 ( 0.00%)  }
         .           
         .           void object_property_set_default_str(ObjectProperty *prop, const char *value)
       348 ( 0.00%)  {
        87 ( 0.00%)      object_property_set_default(prop, QOBJECT(qstring_from_str(value)));
    45,726 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qobject/qstring.c:qstring_from_str (87x)
       174 ( 0.00%)  }
         .           
         .           void object_property_set_default_int(ObjectProperty *prop, int64_t value)
        72 ( 0.00%)  {
        18 ( 0.00%)      object_property_set_default(prop, QOBJECT(qnum_from_int(value)));
     3,464 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qobject/qnum.c:qnum_from_int (18x)
        36 ( 0.00%)  }
         .           
         .           void object_property_set_default_uint(ObjectProperty *prop, uint64_t value)
     5,044 ( 0.00%)  {
     1,261 ( 0.00%)      object_property_set_default(prop, QOBJECT(qnum_from_uint(value)));
   264,021 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qobject/qnum.c:qnum_from_uint (1,261x)
     2,522 ( 0.00%)  }
         .           
         .           bool object_property_set_uint(Object *obj, const char *name,
         .                                         uint64_t value, Error **errp)
        10 ( 0.00%)  {
         1 ( 0.00%)      QNum *qnum = qnum_from_uint(value);
        68 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qobject/qnum.c:qnum_from_uint (1x)
         8 ( 0.00%)      bool ok = object_property_set_qobject(obj, name, QOBJECT(qnum), errp);
     1,915 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/qom-qobject.c:object_property_set_qobject'2 (1x)
         .           
         .               qobject_unref(qnum);
         1 ( 0.00%)      return ok;
         6 ( 0.00%)  }
         .           
         .           uint64_t object_property_get_uint(Object *obj, const char *name,
         .                                             Error **errp)
         .           {
         .               QObject *ret = object_property_get_qobject(obj, name, errp);
         .               QNum *qnum;
         .               uint64_t retval;
         .           
-- line 1603 ----------------------------------------
-- line 1676 ----------------------------------------
         .               visit_complete(v, &string);
         .           
         .           out:
         .               visit_free(v);
         .               return string;
         .           }
         .           
         .           const char *object_property_get_type(Object *obj, const char *name, Error **errp)
        10 ( 0.00%)  {
         5 ( 0.00%)      ObjectProperty *prop = object_property_find_err(obj, name, errp);
     3,849 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_find_err (5x)
        10 ( 0.00%)      if (prop == NULL) {
         .                   return NULL;
         .               }
         .           
         5 ( 0.00%)      return prop->type;
        10 ( 0.00%)  }
         .           
         .           Object *object_get_root(void)
        32 ( 0.00%)  {
         .               static Object *root;
         .           
        93 ( 0.00%)      if (!root) {
         3 ( 0.00%)          root = object_new("container");
     1,497 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_new (1x)
         .               }
         .           
         .               return root;
        32 ( 0.00%)  }
         .           
         .           Object *object_get_objects_root(void)
         2 ( 0.00%)  {
         4 ( 0.00%)      return container_get(object_get_root(), "/objects");
     6,583 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/container.c:container_get (1x)
         5 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_get_root (1x)
         1 ( 0.00%)  }
         .           
         .           Object *object_get_internal_root(void)
         .           {
         .               static Object *internal_root;
         .           
         .               if (!internal_root) {
         .                   internal_root = object_new("container");
         .               }
-- line 1715 ----------------------------------------
-- line 1726 ----------------------------------------
         .           
         .               path = object_get_canonical_path(child);
         .               visit_type_str(v, name, &path, errp);
         .               g_free(path);
         .           }
         .           
         .           static Object *object_resolve_child_property(Object *parent, void *opaque,
         .                                                        const char *part)
        62 ( 0.00%)  {
         .               return opaque;
        31 ( 0.00%)  }
         .           
         .           static void object_finalize_child_property(Object *obj, const char *name,
         .                                                      void *opaque)
        12 ( 0.00%)  {
         .               Object *child = opaque;
         .           
        16 ( 0.00%)      if (child->class->unparent) {
         4 ( 0.00%)          (child->class->unparent)(child);
        42 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/qdev.c:device_unparent (2x)
         .               }
         4 ( 0.00%)      child->parent = NULL;
         8 ( 0.00%)      object_unref(child);
    32,568 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_unref (2x)
         4 ( 0.00%)  }
         .           
         .           ObjectProperty *
         .           object_property_try_add_child(Object *obj, const char *name,
         .                                         Object *child, Error **errp)
       672 ( 0.00%)  {
         .               g_autofree char *type = NULL;
         .               ObjectProperty *op;
         .           
       336 ( 0.00%)      assert(!child->parent);
         .           
     1,120 ( 0.00%)      type = g_strdup_printf("child<%s>", object_get_typename(child));
   116,003 ( 0.00%)  => ???:0x0000000004e3b7e0 (112x)
       560 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_get_typename (112x)
         .           
     1,120 ( 0.00%)      op = object_property_try_add(obj, name, type, object_get_child_property,
   295,509 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_try_add (112x)
         .                                            NULL, object_finalize_child_property,
         .                                            child, errp);
       448 ( 0.00%)      if (!op) {
         .                   return NULL;
         .               }
       224 ( 0.00%)      op->resolve = object_resolve_child_property;
       224 ( 0.00%)      object_ref(child);
     1,008 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_ref (112x)
       112 ( 0.00%)      child->parent = obj;
         .               return op;
       784 ( 0.00%)  }
         .           
         .           ObjectProperty *
         .           object_property_add_child(Object *obj, const char *name,
         .                                     Object *child)
       109 ( 0.00%)  {
       218 ( 0.00%)      return object_property_try_add_child(obj, name, child, &error_abort);
   421,152 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_try_add_child (109x)
         .           }
         .           
         .           void object_property_allow_set_link(const Object *obj, const char *name,
         .                                               Object *val, Error **errp)
         3 ( 0.00%)  {
         .               /* Allow the link to be set, always */
         3 ( 0.00%)  }
         .           
         .           typedef struct {
         .               union {
         .                   Object **targetp;
         .                   Object *target; /* if OBJ_PROP_LINK_DIRECT, when holding the pointer  */
         .                   ptrdiff_t offset; /* if OBJ_PROP_LINK_CLASS */
         .               };
         .               void (*check)(const Object *, const char *, Object *, Error **);
         .               ObjectPropertyLinkFlags flags;
         .           } LinkProperty;
         .           
         .           static Object **
         .           object_link_get_targetp(Object *obj, LinkProperty *lprop)
         .           {
        27 ( 0.00%)      if (lprop->flags & OBJ_PROP_LINK_DIRECT) {
         .                   return &lprop->target;
         8 ( 0.00%)      } else if (lprop->flags & OBJ_PROP_LINK_CLASS) {
        29 ( 0.00%)          return (void *)obj + lprop->offset;
         .               } else {
         .                   return lprop->targetp;
         .               }
         .           }
         .           
         .           static void object_get_link_property(Object *obj, Visitor *v,
         .                                                const char *name, void *opaque,
         .                                                Error **errp)
-- line 1810 ----------------------------------------
-- line 1832 ----------------------------------------
         .            *
         .            * Returns: The matched object or NULL on path lookup failures.
         .            */
         .           static Object *object_resolve_link(Object *obj, const char *name,
         .                                              const char *path, Error **errp)
         .           {
         .               const char *type;
         .               char *target_type;
         5 ( 0.00%)      bool ambiguous = false;
         .               Object *target;
         .           
         .               /* Go from link<FOO> to FOO.  */
        25 ( 0.00%)      type = object_property_get_type(obj, name, NULL);
     3,889 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_get_type (5x)
        25 ( 0.00%)      target_type = g_strndup(&type[5], strlen(type) - 6);
       747 ( 0.00%)  => ???:0x0000000004e3ae00 (5x)
        80 ( 0.00%)  => ???:0x0000000004e3b0d0 (5x)
        40 ( 0.00%)      target = object_resolve_path_type(path, target_type, &ambiguous);
    28,234 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_resolve_path_type (5x)
         .           
        20 ( 0.00%)      if (ambiguous) {
         .                   error_setg(errp, "Path '%s' does not uniquely identify an object",
         .                              path);
        10 ( 0.00%)      } else if (!target) {
         .                   target = object_resolve_path(path, &ambiguous);
         .                   if (target || ambiguous) {
         .                       error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name, target_type);
         .                   } else {
         .                       error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,
         .                                 "Device '%s' not found", path);
         .                   }
         .                   target = NULL;
         .               }
        10 ( 0.00%)      g_free(target_type);
       475 ( 0.00%)  => ???:0x0000000004e3a950 (5x)
         .           
         .               return target;
         .           }
         .           
         .           static void object_set_link_property(Object *obj, Visitor *v,
         .                                                const char *name, void *opaque,
         .                                                Error **errp)
        80 ( 0.00%)  {
         5 ( 0.00%)      Error *local_err = NULL;
         .               LinkProperty *prop = opaque;
         .               Object **targetp = object_link_get_targetp(obj, prop);
        10 ( 0.00%)      Object *old_target = *targetp;
         .               Object *new_target;
         5 ( 0.00%)      char *path = NULL;
         .           
        30 ( 0.00%)      if (!visit_type_str(v, name, &path, errp)) {
       927 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qapi/qapi-visit-core.c:visit_type_str (5x)
         .                   return;
         .               }
         .           
        15 ( 0.00%)      if (*path) {
         .                   new_target = object_resolve_link(obj, name, path, errp);
         .                   if (!new_target) {
         .                       g_free(path);
         .                       return;
         .                   }
         .               } else {
         .                   new_target = NULL;
         .               }
         .           
        20 ( 0.00%)      g_free(path);
       475 ( 0.00%)  => ???:0x0000000004e3a950 (5x)
         .           
        25 ( 0.00%)      prop->check(obj, name, new_target, &local_err);
        50 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/qdev-properties.c:qdev_prop_allow_set_link_before_realize (2x)
         6 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_allow_set_link (3x)
        15 ( 0.00%)      if (local_err) {
         .                   error_propagate(errp, local_err);
         .                   return;
         .               }
         .           
         5 ( 0.00%)      *targetp = new_target;
        10 ( 0.00%)      if (prop->flags & OBJ_PROP_LINK_STRONG) {
        10 ( 0.00%)          object_ref(new_target);
        45 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_ref (5x)
        15 ( 0.00%)          object_unref(old_target);
       116 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_unref (5x)
         .               }
        55 ( 0.00%)  }
         .           
         .           static Object *object_resolve_link_property(Object *parent, void *opaque,
         .                                                       const char *part)
         .           {
         .               LinkProperty *lprop = opaque;
         .           
         .               return *object_link_get_targetp(parent, lprop);
         .           }
         .           
         .           static void object_release_link_property(Object *obj, const char *name,
         .                                                    void *opaque)
        12 ( 0.00%)  {
         .               LinkProperty *prop = opaque;
         .               Object **targetp = object_link_get_targetp(obj, prop);
         .           
        22 ( 0.00%)      if ((prop->flags & OBJ_PROP_LINK_STRONG) && *targetp) {
         .                   object_unref(*targetp);
         .               }
         .               if (!(prop->flags & OBJ_PROP_LINK_CLASS)) {
         .                   g_free(prop);
         .               }
         8 ( 0.00%)  }
         .           
         .           static ObjectProperty *
         .           object_add_link_prop(Object *obj, const char *name,
         .                                const char *type, void *ptr,
         .                                void (*check)(const Object *, const char *,
         .                                              Object *, Error **),
         .                                ObjectPropertyLinkFlags flags)
         .           {
        42 ( 0.00%)      LinkProperty *prop = g_malloc(sizeof(*prop));
     1,118 ( 0.00%)  => ???:0x0000000004e3b870 (14x)
         .               g_autofree char *full_type = NULL;
         .               ObjectProperty *op;
         .           
        14 ( 0.00%)      if (flags & OBJ_PROP_LINK_DIRECT) {
        14 ( 0.00%)          prop->target = ptr;
         .               } else {
         .                   prop->targetp = ptr;
         .               }
        14 ( 0.00%)      prop->check = check;
        14 ( 0.00%)      prop->flags = flags;
         .           
        70 ( 0.00%)      full_type = g_strdup_printf("link<%s>", type);
    15,038 ( 0.00%)  => ???:0x0000000004e3b7e0 (14x)
         .           
       182 ( 0.00%)      op = object_property_add(obj, name, full_type,
    32,742 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_add (14x)
         .                                        object_get_link_property,
         .                                        check ? object_set_link_property : NULL,
         .                                        object_release_link_property,
         .                                        prop);
        28 ( 0.00%)      op->resolve = object_resolve_link_property;
         .               return op;
         .           }
         .           
         .           ObjectProperty *
         .           object_property_add_link(Object *obj, const char *name,
         .                                    const char *type, Object **targetp,
         .                                    void (*check)(const Object *, const char *,
         .                                                  Object *, Error **),
         .                                    ObjectPropertyLinkFlags flags)
       196 ( 0.00%)  {
         .               return object_add_link_prop(obj, name, type, targetp, check, flags);
       126 ( 0.00%)  }
         .           
         .           ObjectProperty *
         .           object_class_property_add_link(ObjectClass *oc,
         .               const char *name,
         .               const char *type, ptrdiff_t offset,
         .               void (*check)(const Object *obj, const char *name,
         .                             Object *val, Error **errp),
         .               ObjectPropertyLinkFlags flags)
     1,022 ( 0.00%)  {
       219 ( 0.00%)      LinkProperty *prop = g_new0(LinkProperty, 1);
    18,219 ( 0.00%)  => ???:0x0000000004e3cc20 (73x)
         .               char *full_type;
         .               ObjectProperty *op;
         .           
       146 ( 0.00%)      prop->offset = offset;
        73 ( 0.00%)      prop->check = check;
       146 ( 0.00%)      prop->flags = flags | OBJ_PROP_LINK_CLASS;
         .           
       365 ( 0.00%)      full_type = g_strdup_printf("link<%s>", type);
    74,808 ( 0.00%)  => ???:0x0000000004e3b7e0 (73x)
         .           
       949 ( 0.00%)      op = object_class_property_add(oc, name, full_type,
   129,138 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_class_property_add (73x)
         .                                              object_get_link_property,
         .                                              check ? object_set_link_property : NULL,
         .                                              object_release_link_property,
         .                                              prop);
         .           
       146 ( 0.00%)      op->resolve = object_resolve_link_property;
         .           
       146 ( 0.00%)      g_free(full_type);
     6,935 ( 0.00%)  => ???:0x0000000004e3a950 (73x)
         .               return op;
       657 ( 0.00%)  }
         .           
         .           ObjectProperty *
         .           object_property_add_const_link(Object *obj, const char *name,
         .                                          Object *target)
         .           {
         .               return object_add_link_prop(obj, name,
         .                                           object_get_typename(target), target,
         .                                           NULL, OBJ_PROP_LINK_DIRECT);
         .           }
         .           
         .           const char *object_get_canonical_path_component(const Object *obj)
       414 ( 0.00%)  {
        46 ( 0.00%)      ObjectProperty *prop = NULL;
         .               GHashTableIter iter;
         .           
       138 ( 0.00%)      if (obj->parent == NULL) {
         .                   return NULL;
         .               }
         .           
       276 ( 0.00%)      g_hash_table_iter_init(&iter, obj->parent->properties);
       552 ( 0.00%)  => ???:0x0000000004e3b910 (46x)
     3,222 ( 0.00%)      while (g_hash_table_iter_next(&iter, NULL, (gpointer *)&prop)) {
    26,315 ( 0.00%)  => ???:0x0000000004e3be50 (537x)
     1,074 ( 0.00%)          if (!object_property_is_child(prop)) {
         .                       continue;
         .                   }
         .           
       507 ( 0.00%)          if (prop->opaque == obj) {
        46 ( 0.00%)              return prop->name;
         .                   }
         .               }
         .           
         .               /* obj had a parent but was not a child, should never happen */
         .               g_assert_not_reached();
         .               return NULL;
       414 ( 0.00%)  }
         .           
         .           char *object_get_canonical_path(const Object *obj)
       180 ( 0.00%)  {
        15 ( 0.00%)      Object *root = object_get_root();
        75 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_get_root (15x)
         .               char *newpath, *path = NULL;
         .           
        45 ( 0.00%)      if (obj == root) {
         .                   return g_strdup("/");
         .               }
         .           
         .               do {
       135 ( 0.00%)          const char *component = object_get_canonical_path_component(obj);
    47,498 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_get_canonical_path_component (45x)
         .           
        90 ( 0.00%)          if (!component) {
         .                       /* A canonical path must be complete, so discard what was
         .                        * collected so far.
         .                        */
         .                       g_free(path);
         .                       return NULL;
         .                   }
         .           
       390 ( 0.00%)          newpath = g_strdup_printf("/%s%s", component, path ? path : "");
    52,080 ( 0.00%)  => ???:0x0000000004e3b7e0 (45x)
        90 ( 0.00%)          g_free(path);
     3,000 ( 0.00%)  => ???:0x0000000004e3a950 (45x)
         .                   path = newpath;
        45 ( 0.00%)          obj = obj->parent;
        90 ( 0.00%)      } while (obj != root);
         .           
         .               return path;
       135 ( 0.00%)  }
         .           
         .           Object *object_resolve_path_component(Object *parent, const char *part)
       216 ( 0.00%)  {
        36 ( 0.00%)      ObjectProperty *prop = object_property_find(parent, part);
    23,518 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_find (36x)
        72 ( 0.00%)      if (prop == NULL) {
         .                   return NULL;
         .               }
         .           
        93 ( 0.00%)      if (prop->resolve) {
       124 ( 0.00%)          return prop->resolve(parent, prop->opaque, part);
        93 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_resolve_child_property (31x)
         .               } else {
         .                   return NULL;
         .               }
       118 ( 0.00%)  }
         .           
         .           static Object *object_resolve_abs_path(Object *parent,
         .                                                     char **parts,
         .                                                     const char *typename)
         .           {
         .               Object *child;
         .           
     1,719 ( 0.00%)      if (*parts == NULL) {
     1,660 ( 0.00%)          return object_dynamic_cast(parent, typename);
       610 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_dynamic_cast (3x)
         .               }
         .           
        32 ( 0.00%)      if (strcmp(*parts, "") == 0) {
         .                   return object_resolve_abs_path(parent, parts + 1, typename);
         .               }
         .           
        48 ( 0.00%)      child = object_resolve_path_component(parent, *parts);
    11,062 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_resolve_path_component (16x)
        32 ( 0.00%)      if (!child) {
         .                   return NULL;
         .               }
         .           
         .               return object_resolve_abs_path(child, parts + 1, typename);
         .           }
         .           
         .           static Object *object_resolve_partial_path(Object *parent,
         .                                                      char **parts,
         .                                                      const char *typename,
         .                                                      bool *ambiguous)
     4,905 ( 0.00%)  {
         .               Object *obj;
         .               GHashTableIter iter;
         .               ObjectProperty *prop;
         .           
         .               obj = object_resolve_abs_path(parent, parts, typename);
         .           
     1,635 ( 0.00%)      g_hash_table_iter_init(&iter, parent->properties);
        36 ( 0.00%)  => ???:0x0000000004e3b910 (3x)
     6,987 ( 0.00%)      while (g_hash_table_iter_next(&iter, NULL, (gpointer *)&prop)) {
       585 ( 0.00%)  => ???:0x0000000004e3be50 (12x)
         .                   Object *found;
         .           
     1,566 ( 0.00%)          if (!object_property_is_child(prop)) {
         .                       continue;
         .                   }
         .           
     1,944 ( 0.00%)          found = object_resolve_partial_path(prop->opaque, parts,
   182,850 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_resolve_partial_path'2 (9x)
         .                                                       typename, ambiguous);
       648 ( 0.00%)          if (found) {
         .                       if (obj) {
         .                           *ambiguous = true;
         .                           return NULL;
         .                       }
         .                       obj = found;
         .                   }
         .           
       648 ( 0.00%)          if (*ambiguous) {
         .                       return NULL;
         .                   }
         .               }
         .           
         .               return obj;
     3,924 ( 0.00%)  }
         .           
         .           Object *object_resolve_path_type(const char *path, const char *typename,
         .                                            bool *ambiguousp)
        88 ( 0.00%)  {
         .               Object *obj;
         .               char **parts;
         .           
        24 ( 0.00%)      parts = g_strsplit(path, "/", 0);
    14,515 ( 0.00%)  => ???:0x0000000004e3ba20 (8x)
        24 ( 0.00%)      assert(parts);
         .           
        34 ( 0.00%)      if (parts[0] == NULL || strcmp(parts[0], "") != 0) {
         3 ( 0.00%)          bool ambiguous = false;
        21 ( 0.00%)          obj = object_resolve_partial_path(object_get_root(), parts,
   184,897 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_resolve_partial_path (3x)
        15 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_get_root (3x)
         .                                                     typename, &ambiguous);
         6 ( 0.00%)          if (ambiguousp) {
         .                       *ambiguousp = ambiguous;
         .                   }
         .               } else {
        10 ( 0.00%)          obj = object_resolve_abs_path(object_get_root(), parts + 1, typename);
        25 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_get_root (5x)
         .               }
         .           
        16 ( 0.00%)      g_strfreev(parts);
     2,948 ( 0.00%)  => ???:0x0000000004e3bf30 (8x)
         .           
         .               return obj;
        80 ( 0.00%)  }
         .           
         .           Object *object_resolve_path(const char *path, bool *ambiguous)
         .           {
         .               return object_resolve_path_type(path, TYPE_OBJECT, ambiguous);
         .           }
         .           
         .           Object *object_resolve_path_at(Object *parent, const char *path)
         .           {
-- line 2165 ----------------------------------------
-- line 2232 ----------------------------------------
         .                                          prop);
         .           }
         .           
         .           ObjectProperty *
         .           object_class_property_add_str(ObjectClass *klass, const char *name,
         .                                              char *(*get)(Object *, Error **),
         .                                              void (*set)(Object *, const char *,
         .                                                          Error **))
       540 ( 0.00%)  {
       108 ( 0.00%)      StringProperty *prop = g_malloc0(sizeof(*prop));
    13,462 ( 0.00%)  => ???:0x0000000004e3cc20 (54x)
         .           
        54 ( 0.00%)      prop->get = get;
        54 ( 0.00%)      prop->set = set;
         .           
       810 ( 0.00%)      return object_class_property_add(klass, name, "string",
    79,055 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_class_property_add (54x)
         .                                                get ? property_get_str : NULL,
         .                                                set ? property_set_str : NULL,
         .                                                NULL,
         .                                                prop);
       324 ( 0.00%)  }
         .           
         .           typedef struct BoolProperty
         .           {
         .               bool (*get)(Object *, Error **);
         .               void (*set)(Object *, bool, Error **);
         .           } BoolProperty;
         .           
         .           static void property_get_bool(Object *obj, Visitor *v, const char *name,
-- line 2259 ----------------------------------------
-- line 2269 ----------------------------------------
         .                   return;
         .               }
         .           
         .               visit_type_bool(v, name, &value, errp);
         .           }
         .           
         .           static void property_set_bool(Object *obj, Visitor *v, const char *name,
         .                                         void *opaque, Error **errp)
        91 ( 0.00%)  {
         .               BoolProperty *prop = opaque;
         .               bool value;
         .           
        35 ( 0.00%)      if (!visit_type_bool(v, name, &value, errp)) {
       845 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qapi/qapi-visit-core.c:visit_type_bool (3x)
         .                   return;
         .               }
         .           
        28 ( 0.00%)      prop->set(obj, value, errp);
 2,675,149 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/qdev.c:device_set_realized (1x)
        14 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../backends/hostmem.c:host_memory_backend_set_use_canonical_path (1x)
        14 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/machine.c:machine_set_graphics (1x)
        56 ( 0.00%)  }
         .           
         .           ObjectProperty *
         .           object_property_add_bool(Object *obj, const char *name,
         .                                    bool (*get)(Object *, Error **),
         .                                    void (*set)(Object *, bool, Error **))
        10 ( 0.00%)  {
         2 ( 0.00%)      BoolProperty *prop = g_malloc0(sizeof(*prop));
       188 ( 0.00%)  => ???:0x0000000004e3cc20 (1x)
         .           
         1 ( 0.00%)      prop->get = get;
         1 ( 0.00%)      prop->set = set;
         .           
        15 ( 0.00%)      return object_property_add(obj, name, "bool",
     1,328 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_add (1x)
         .                                          get ? property_get_bool : NULL,
         .                                          set ? property_set_bool : NULL,
         .                                          property_release_data,
         .                                          prop);
         6 ( 0.00%)  }
         .           
         .           ObjectProperty *
         .           object_class_property_add_bool(ObjectClass *klass, const char *name,
         .                                               bool (*get)(Object *, Error **),
         .                                               void (*set)(Object *, bool, Error **))
       480 ( 0.00%)  {
        96 ( 0.00%)      BoolProperty *prop = g_malloc0(sizeof(*prop));
    11,952 ( 0.00%)  => ???:0x0000000004e3cc20 (48x)
         .           
        48 ( 0.00%)      prop->get = get;
        48 ( 0.00%)      prop->set = set;
         .           
       720 ( 0.00%)      return object_class_property_add(klass, name, "bool",
    79,591 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_class_property_add (48x)
         .                                                get ? property_get_bool : NULL,
         .                                                set ? property_set_bool : NULL,
         .                                                NULL,
         .                                                prop);
       288 ( 0.00%)  }
         .           
         .           static void property_get_enum(Object *obj, Visitor *v, const char *name,
         .                                         void *opaque, Error **errp)
         .           {
         .               EnumProperty *prop = opaque;
         .               int value;
         .               Error *err = NULL;
         .           
-- line 2328 ----------------------------------------
-- line 2368 ----------------------------------------
         .           }
         .           
         .           ObjectProperty *
         .           object_class_property_add_enum(ObjectClass *klass, const char *name,
         .                                               const char *typename,
         .                                               const QEnumLookup *lookup,
         .                                               int (*get)(Object *, Error **),
         .                                               void (*set)(Object *, int, Error **))
        84 ( 0.00%)  {
        12 ( 0.00%)      EnumProperty *prop = g_malloc(sizeof(*prop));
     1,302 ( 0.00%)  => ???:0x0000000004e3b870 (6x)
         .           
         6 ( 0.00%)      prop->lookup = lookup;
         6 ( 0.00%)      prop->get = get;
         6 ( 0.00%)      prop->set = set;
         .           
        90 ( 0.00%)      return object_class_property_add(klass, name, typename,
    10,541 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_class_property_add (6x)
         .                                                get ? property_get_enum : NULL,
         .                                                set ? property_set_enum : NULL,
         .                                                NULL,
         .                                                prop);
        48 ( 0.00%)  }
         .           
         .           typedef struct TMProperty {
         .               void (*get)(Object *, struct tm *, Error **);
         .           } TMProperty;
         .           
         .           static void property_get_tm(Object *obj, Visitor *v, const char *name,
         .                                       void *opaque, Error **errp)
         .           {
-- line 2396 ----------------------------------------
-- line 2506 ----------------------------------------
         .                                               void *opaque, Error **errp)
         .           {
         .               uint32_t value = *(uint32_t *)opaque;
         .               visit_type_uint32(v, name, &value, errp);
         .           }
         .           
         .           static void property_set_uint32_ptr(Object *obj, Visitor *v, const char *name,
         .                                               void *opaque, Error **errp)
        10 ( 0.00%)  {
         .               uint32_t *field = opaque;
         .               uint32_t value;
         .           
         4 ( 0.00%)      if (!visit_type_uint32(v, name, &value, errp)) {
       134 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qapi/qapi-visit-core.c:visit_type_uint32 (1x)
         .                   return;
         .               }
         .           
         2 ( 0.00%)      *field = value;
         6 ( 0.00%)  }
         .           
         .           static void property_get_uint64_ptr(Object *obj, Visitor *v, const char *name,
         .                                               void *opaque, Error **errp)
         .           {
         .               uint64_t value = *(uint64_t *)opaque;
         .               visit_type_uint64(v, name, &value, errp);
         .           }
         .           
-- line 2531 ----------------------------------------
-- line 2621 ----------------------------------------
         .               return object_class_property_add(klass, name, "uint16",
         .                                                getter, setter, NULL, (void *)v);
         .           }
         .           
         .           ObjectProperty *
         .           object_property_add_uint32_ptr(Object *obj, const char *name,
         .                                          const uint32_t *v,
         .                                          ObjectPropertyFlags flags)
         4 ( 0.00%)  {
         .               ObjectPropertyAccessor *getter = NULL;
         .               ObjectPropertyAccessor *setter = NULL;
         .           
         .               if ((flags & OBJ_PROP_FLAG_READ) == OBJ_PROP_FLAG_READ) {
         8 ( 0.00%)          getter = property_get_uint32_ptr;
         .               }
         .           
         .               if ((flags & OBJ_PROP_FLAG_WRITE) == OBJ_PROP_FLAG_WRITE) {
         6 ( 0.00%)          setter = property_set_uint32_ptr;
         .               }
         .           
        10 ( 0.00%)      return object_property_add(obj, name, "uint32",
     7,208 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_add (2x)
         .                                          getter, setter, NULL, (void *)v);
         4 ( 0.00%)  }
         .           
         .           ObjectProperty *
         .           object_class_property_add_uint32_ptr(ObjectClass *klass, const char *name,
         .                                                const uint32_t *v,
         .                                                ObjectPropertyFlags flags)
         .           {
         .               ObjectPropertyAccessor *getter = NULL;
         .               ObjectPropertyAccessor *setter = NULL;
-- line 2651 ----------------------------------------
-- line 2661 ----------------------------------------
         .               return object_class_property_add(klass, name, "uint32",
         .                                                getter, setter, NULL, (void *)v);
         .           }
         .           
         .           ObjectProperty *
         .           object_property_add_uint64_ptr(Object *obj, const char *name,
         .                                          const uint64_t *v,
         .                                          ObjectPropertyFlags flags)
        40 ( 0.00%)  {
         .               ObjectPropertyAccessor *getter = NULL;
         .               ObjectPropertyAccessor *setter = NULL;
         .           
         .               if ((flags & OBJ_PROP_FLAG_READ) == OBJ_PROP_FLAG_READ) {
        80 ( 0.00%)          getter = property_get_uint64_ptr;
         .               }
         .           
         .               if ((flags & OBJ_PROP_FLAG_WRITE) == OBJ_PROP_FLAG_WRITE) {
        60 ( 0.00%)          setter = property_set_uint64_ptr;
         .               }
         .           
       100 ( 0.00%)      return object_property_add(obj, name, "uint64",
    23,219 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_add (20x)
         .                                          getter, setter, NULL, (void *)v);
        40 ( 0.00%)  }
         .           
         .           ObjectProperty *
         .           object_class_property_add_uint64_ptr(ObjectClass *klass, const char *name,
         .                                                const uint64_t *v,
         .                                                ObjectPropertyFlags flags)
         .           {
         .               ObjectPropertyAccessor *getter = NULL;
         .               ObjectPropertyAccessor *setter = NULL;
-- line 2691 ----------------------------------------
-- line 2741 ----------------------------------------
         .           
         .               g_free(prop->target_name);
         .               g_free(prop);
         .           }
         .           
         .           ObjectProperty *
         .           object_property_add_alias(Object *obj, const char *name,
         .                                     Object *target_obj, const char *target_name)
       804 ( 0.00%)  {
         .               AliasProperty *prop;
         .               ObjectProperty *op;
         .               ObjectProperty *target_prop;
         .               g_autofree char *prop_type = NULL;
         .           
       335 ( 0.00%)      target_prop = object_property_find_err(target_obj, target_name,
    81,727 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_find_err (67x)
         .                                                      &error_abort);
         .           
       134 ( 0.00%)      if (object_property_is_child(target_prop)) {
       390 ( 0.00%)          prop_type = g_strdup_printf("link%s",
    61,102 ( 0.00%)  => ???:0x0000000004e3b7e0 (65x)
         .                                               target_prop->type + strlen("child"));
         .               } else {
         8 ( 0.00%)          prop_type = g_strdup(target_prop->type);
       212 ( 0.00%)  => ???:0x0000000004e3b620 (2x)
         .               }
         .           
       134 ( 0.00%)      prop = g_malloc(sizeof(*prop));
    14,297 ( 0.00%)  => ???:0x0000000004e3b870 (67x)
       134 ( 0.00%)      prop->target_obj = target_obj;
       268 ( 0.00%)      prop->target_name = g_strdup(target_name);
    17,879 ( 0.00%)  => ???:0x0000000004e3b620 (67x)
         .           
       670 ( 0.00%)      op = object_property_add(obj, name, prop_type,
   176,133 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_add (67x)
         .                                        property_get_alias,
         .                                        property_set_alias,
         .                                        property_release_alias,
         .                                        prop);
       134 ( 0.00%)      op->resolve = property_resolve_alias;
       335 ( 0.00%)      if (target_prop->defval) {
         1 ( 0.00%)          op->defval = qobject_ref(target_prop->defval);
         .               }
         .           
       268 ( 0.00%)      object_property_set_description(obj, op->name,
    87,994 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_set_description (67x)
         .                                               target_prop->description);
         .               return op;
       603 ( 0.00%)  }
         .           
         .           void object_property_set_description(Object *obj, const char *name,
         .                                                const char *description)
       360 ( 0.00%)  {
         .               ObjectProperty *op;
         .           
       216 ( 0.00%)      op = object_property_find_err(obj, name, &error_abort);
    90,303 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_find_err (72x)
       144 ( 0.00%)      g_free(op->description);
       720 ( 0.00%)  => ???:0x0000000004e3a950 (72x)
       216 ( 0.00%)      op->description = g_strdup(description);
       504 ( 0.00%)  => ???:0x0000000004e3b620 (72x)
       288 ( 0.00%)  }
         .           
         .           void object_class_property_set_description(ObjectClass *klass,
         .                                                      const char *name,
         .                                                      const char *description)
    11,285 ( 0.00%)  {
         .               ObjectProperty *op;
         .           
     6,771 ( 0.00%)      op = g_hash_table_lookup(klass->properties, name);
   460,061 ( 0.00%)  => ???:0x0000000004e3bdd0 (2,257x)
     4,514 ( 0.00%)      g_free(op->description);
    22,570 ( 0.00%)  => ???:0x0000000004e3a950 (2,257x)
     6,771 ( 0.00%)      op->description = g_strdup(description);
   148,331 ( 0.00%)  => ???:0x0000000004e3b620 (2,257x)
     9,028 ( 0.00%)  }
         .           
         .           static void object_class_init(ObjectClass *klass, void *data)
         1 ( 0.00%)  {
         4 ( 0.00%)      object_class_property_add_str(klass, "type", object_get_type,
     1,229 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_class_property_add_str (1x)
         .                                             NULL);
         .           }
         .           
         .           static void register_types(void)
         2 ( 0.00%)  {
         .               static const TypeInfo interface_info = {
         .                   .name = TYPE_INTERFACE,
         .                   .class_size = sizeof(InterfaceClass),
         .                   .abstract = true,
         .               };
         .           
         .               static const TypeInfo object_info = {
         .                   .name = TYPE_OBJECT,
         .                   .instance_size = sizeof(Object),
         .                   .class_init = object_class_init,
         .                   .abstract = true,
         .               };
         .           
         1 ( 0.00%)      type_interface = type_register_internal(&interface_info);
         .               type_register_internal(&object_info);
         1 ( 0.00%)  }
         .           
         4 ( 0.00%)  type_init(register_types)
       261 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/module.c:register_module_init (1x)

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/include/qemu/timer.h
--------------------------------------------------------------------------------
Ir                  

-- line 110 ----------------------------------------
         .            *
         .            * Get the millisecond value of a clock with
         .            * type @type
         .            *
         .            * Returns: the clock value in milliseconds
         .            */
         .           static inline int64_t qemu_clock_get_ms(QEMUClockType type)
         .           {
         6 ( 0.00%)      return qemu_clock_get_ns(type) / SCALE_MS;
        77 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:qemu_clock_get_ns (2x)
         .           }
         .           
         .           /**
         .            * qemu_clock_get_us;
         .            * @type: the clock type
         .            *
         .            * Get the microsecond value of a clock with
         .            * type @type
-- line 126 ----------------------------------------
-- line 515 ----------------------------------------
         .            *
         .            * Returns: a pointer to the timer
         .            */
         .           static inline QEMUTimer *timer_new_full(QEMUTimerListGroup *timer_list_group,
         .                                                   QEMUClockType type,
         .                                                   int scale, int attributes,
         .                                                   QEMUTimerCB *cb, void *opaque)
         .           {
        24 ( 0.00%)      QEMUTimer *ts = g_new0(QEMUTimer, 1);
       255 ( 0.00%)  => ???:0x0000000004e3cc20 (1x)
        68 ( 0.00%)      timer_init_full(ts, timer_list_group, type, scale, attributes, cb, opaque);
        16 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-timer.c:timer_init_full (1x)
         .               return ts;
         .           }
         .           
         .           /**
         .            * timer_new:
         .            * @type: the clock type to use
         .            * @scale: the scale value for the timer
         .            * @cb: the callback to be called when the timer expires
-- line 532 ----------------------------------------
-- line 773 ----------------------------------------
         .            * Returns: soonest timeout value in nanoseconds (or -1 for infinite)
         .            */
         .           static inline int64_t qemu_soonest_timeout(int64_t timeout1, int64_t timeout2)
         .           {
         .               /* we can abuse the fact that -1 (which means infinite) is a maximal
         .                * value when cast to unsigned. As this is disgusting, it's kept in
         .                * one inline function.
         .                */
12,245,383 ( 0.02%)      return ((uint64_t) timeout1 < (uint64_t) timeout2) ? timeout1 : timeout2;
         .           }
         .           
         .           /**
         .            * initclocks:
         .            *
         .            * Initialise the clock & timer infrastructure
         .            */
         .           void init_clocks(QEMUTimerListNotifyCB *notify_cb);
-- line 789 ----------------------------------------
-- line 801 ----------------------------------------
         .            * Low level clock functions
         .            */
         .           
         .           /* get host real time in nanosecond */
         .           static inline int64_t get_clock_realtime(void)
         .           {
         .               struct timeval tv;
         .           
        24 ( 0.00%)      gettimeofday(&tv, NULL);
        10 ( 0.00%)  => ???:0x0000000004e3ca90 (1x)
        27 ( 0.00%)      return tv.tv_sec * 1000000000LL + (tv.tv_usec * 1000);
         .           }
         .           
         .           extern int64_t clock_start;
         .           
         .           /* Warning: don't insert tracepoints into these functions, they are
         .              also used by simpletrace backend and tracepoints would cause
         .              an infinite recursion! */
         .           #ifdef _WIN32
-- line 818 ----------------------------------------
-- line 826 ----------------------------------------
         .           }
         .           
         .           #else
         .           
         .           extern int use_rt_clock;
         .           
         .           static inline int64_t get_clock(void)
         .           {
         8 ( 0.00%)      if (use_rt_clock) {
         .                   struct timespec ts;
         9 ( 0.00%)          clock_gettime(CLOCK_MONOTONIC, &ts);
        13 ( 0.00%)  => ???:0x0000000004e3bbe0 (1x)
         8 ( 0.00%)          return ts.tv_sec * 1000000000LL + ts.tv_nsec;
         .               } else {
         .                   /* XXX: using gettimeofday leads to problems if the date
         .                      changes, so it should be avoided. */
         .                   return get_clock_realtime();
         .               }
         .           }
         .           #endif
         .           
-- line 845 ----------------------------------------
-- line 882 ----------------------------------------
         .           }
         .           
         .           #elif defined(__x86_64__)
         .           
         .           static inline int64_t cpu_get_host_ticks(void)
         .           {
         .               uint32_t low,high;
         .               int64_t val;
         1 ( 0.00%)      asm volatile("rdtsc" : "=a" (low), "=d" (high));
         .               val = high;
         1 ( 0.00%)      val <<= 32;
         2 ( 0.00%)      val |= low;
         .               return val;
         .           }
         .           
         .           #elif defined(__hppa__)
         .           
         .           static inline int64_t cpu_get_host_ticks(void)
         .           {
         .               int val;
-- line 901 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/memory_ldst.c.inc
--------------------------------------------------------------------------------
Ir                  

-- line 22 ----------------------------------------
         .           /* warning: addr must be aligned */
         .           static inline uint32_t glue(address_space_ldl_internal, SUFFIX)(ARG1_DECL,
         .               hwaddr addr, MemTxAttrs attrs, MemTxResult *result,
         .               enum device_endian endian)
         .           {
         .               uint8_t *ptr;
         .               uint64_t val;
         .               MemoryRegion *mr;
 4,432,396 ( 0.01%)      hwaddr l = 4;
         .               hwaddr addr1;
         .               MemTxResult r;
         .               bool release_lock = false;
         .           
         .               RCU_READ_LOCK();
         .               mr = TRANSLATE(addr, &addr1, &l, false, attrs);
 8,864,792 ( 0.01%)      if (l < 4 || !memory_access_is_direct(mr, false)) {
         .                   release_lock |= prepare_mmio_access(mr);
         .           
         .                   /* I/O case */
         .                   r = memory_region_dispatch_read(mr, addr1, &val,
         .                                                   MO_32 | devend_memop(endian), attrs);
         .               } else {
         .                   /* RAM case */
         .                   fuzz_dma_read_cb(addr, 4, mr);
13,297,188 ( 0.02%)          ptr = qemu_map_ram_ptr(mr->ram_block, addr1);
57,621,148 ( 0.08%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:qemu_map_ram_ptr (4,432,396x)
         .                   switch (endian) {
         .                   case DEVICE_LITTLE_ENDIAN:
         .                       val = ldl_le_p(ptr);
         .                       break;
         .                   case DEVICE_BIG_ENDIAN:
         .                       val = ldl_be_p(ptr);
         .                       break;
         .                   default:
 4,432,396 ( 0.01%)              val = ldl_p(ptr);
         .                       break;
         .                   }
         .                   r = MEMTX_OK;
         .               }
 8,864,792 ( 0.01%)      if (result) {
 4,432,392 ( 0.01%)          *result = r;
         .               }
 4,432,392 ( 0.01%)      if (release_lock) {
         .                   qemu_mutex_unlock_iothread();
         .               }
         .               RCU_READ_UNLOCK();
         .               return val;
         .           }
         .           
         .           uint32_t glue(address_space_ldl, SUFFIX)(ARG1_DECL,
         .               hwaddr addr, MemTxAttrs attrs, MemTxResult *result)
48,756,356 ( 0.07%)  {
         .               return glue(address_space_ldl_internal, SUFFIX)(ARG1, addr, attrs, result,
         .                                                               DEVICE_NATIVE_ENDIAN);
39,891,564 ( 0.05%)  }
         .           
         .           uint32_t glue(address_space_ldl_le, SUFFIX)(ARG1_DECL,
         .               hwaddr addr, MemTxAttrs attrs, MemTxResult *result)
         .           {
         .               return glue(address_space_ldl_internal, SUFFIX)(ARG1, addr, attrs, result,
         .                                                               DEVICE_LITTLE_ENDIAN);
         .           }
         .           
-- line 83 ----------------------------------------
-- line 302 ----------------------------------------
         .           
         .           /* warning: addr must be aligned */
         .           static inline void glue(address_space_stl_internal, SUFFIX)(ARG1_DECL,
         .               hwaddr addr, uint32_t val, MemTxAttrs attrs,
         .               MemTxResult *result, enum device_endian endian)
         .           {
         .               uint8_t *ptr;
         .               MemoryRegion *mr;
 3,988,014 ( 0.01%)      hwaddr l = 4;
         .               hwaddr addr1;
         .               MemTxResult r;
         .               bool release_lock = false;
         .           
         .               RCU_READ_LOCK();
         .               mr = TRANSLATE(addr, &addr1, &l, true, attrs);
 7,976,028 ( 0.01%)      if (l < 4 || !memory_access_is_direct(mr, true)) {
         .                   release_lock |= prepare_mmio_access(mr);
         .                   r = memory_region_dispatch_write(mr, addr1, val,
         .                                                    MO_32 | devend_memop(endian), attrs);
         .               } else {
         .                   /* RAM case */
11,964,042 ( 0.02%)          ptr = qemu_map_ram_ptr(mr->ram_block, addr1);
51,844,182 ( 0.07%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:qemu_map_ram_ptr (3,988,014x)
         .                   switch (endian) {
         .                   case DEVICE_LITTLE_ENDIAN:
         .                       stl_le_p(ptr, val);
         .                       break;
         .                   case DEVICE_BIG_ENDIAN:
         .                       stl_be_p(ptr, val);
         .                       break;
         .                   default:
         .                       stl_p(ptr, val);
         .                       break;
         .                   }
15,952,056 ( 0.02%)          invalidate_and_set_dirty(mr, addr1, 4);
895,279,762 ( 1.23%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:invalidate_and_set_dirty (3,988,014x)
         .                   r = MEMTX_OK;
         .               }
 7,976,028 ( 0.01%)      if (result) {
 3,988,014 ( 0.01%)          *result = r;
         .               }
 3,988,014 ( 0.01%)      if (release_lock) {
         .                   qemu_mutex_unlock_iothread();
         .               }
         .               RCU_READ_UNLOCK();
         .           }
         .           
         .           void glue(address_space_stl, SUFFIX)(ARG1_DECL,
         .               hwaddr addr, uint32_t val, MemTxAttrs attrs, MemTxResult *result)
         .           {
         .               glue(address_space_stl_internal, SUFFIX)(ARG1, addr, val, attrs,
         .                                                        result, DEVICE_NATIVE_ENDIAN);
         .           }
         .           
         .           void glue(address_space_stl_le, SUFFIX)(ARG1_DECL,
         .               hwaddr addr, uint32_t val, MemTxAttrs attrs, MemTxResult *result)
51,844,182 ( 0.07%)  {
         .               glue(address_space_stl_internal, SUFFIX)(ARG1, addr, val, attrs,
         .                                                        result, DEVICE_LITTLE_ENDIAN);
39,880,140 ( 0.05%)  }
         .           
         .           void glue(address_space_stl_be, SUFFIX)(ARG1_DECL,
         .               hwaddr addr, uint32_t val, MemTxAttrs attrs, MemTxResult *result)
         .           {
         .               glue(address_space_stl_internal, SUFFIX)(ARG1, addr, val, attrs,
         .                                                        result, DEVICE_BIG_ENDIAN);
         .           }
         .           
-- line 367 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/include/exec/cpu_ldst.h
--------------------------------------------------------------------------------
Ir                  

-- line 350 ----------------------------------------
         .           /* Needed for TCG_OVERSIZED_GUEST */
         .           #include "tcg/tcg.h"
         .           
         .           static inline target_ulong tlb_addr_write(const CPUTLBEntry *entry)
         .           {
         .           #if TCG_OVERSIZED_GUEST
         .               return entry->addr_write;
         .           #else
11,672,576 ( 0.02%)      return qatomic_read(&entry->addr_write);
         .           #endif
         .           }
         .           
         .           /* Find the TLB index corresponding to the mmu_idx + address pair.  */
         .           static inline uintptr_t tlb_index(CPUArchState *env, uintptr_t mmu_idx,
         .                                             target_ulong addr)
         .           {
41,605,373 ( 0.06%)      uintptr_t size_mask = env_tlb(env)->f[mmu_idx].mask >> CPU_TLB_ENTRY_BITS;
         .           
80,552,881 ( 0.11%)      return (addr >> TARGET_PAGE_BITS) & size_mask;
         .           }
         .           
         .           /* Find the TLB entry corresponding to the mmu_idx + address pair.  */
         .           static inline CPUTLBEntry *tlb_entry(CPUArchState *env, uintptr_t mmu_idx,
         .                                                target_ulong addr)
         .           {
52,293,474 ( 0.07%)      return &env_tlb(env)->f[mmu_idx].table[tlb_index(env, mmu_idx, addr)];
         .           }
         .           
         .           #endif /* defined(CONFIG_USER_ONLY) */
         .           
         .           #if TARGET_BIG_ENDIAN
         .           # define cpu_lduw_data        cpu_lduw_be_data
         .           # define cpu_ldsw_data        cpu_ldsw_be_data
         .           # define cpu_ldl_data         cpu_ldl_be_data
-- line 383 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/bitmap.c
--------------------------------------------------------------------------------
Ir                 

-- line 175 ----------------------------------------
        .               }
        .               if (nr) {
        .                   mask_to_set &= BITMAP_LAST_WORD_MASK(size);
        .                   *p |= mask_to_set;
        .               }
        .           }
        .           
        .           void bitmap_set_atomic(unsigned long *map, long start, long nr)
  359,858 ( 0.00%)  {
1,079,574 ( 0.00%)      unsigned long *p = map + BIT_WORD(start);
  359,843 ( 0.00%)      const long size = start + nr;
1,439,432 ( 0.00%)      int bits_to_set = BITS_PER_LONG - (start % BITS_PER_LONG);
  757,348 ( 0.00%)      unsigned long mask_to_set = BITMAP_FIRST_WORD_MASK(start);
        .           
1,079,574 ( 0.00%)      assert(start >= 0 && nr >= 0);
        .           
        .               /* First word */
1,799,290 ( 0.00%)      if (nr - bits_to_set > 0) {
       15 ( 0.00%)          qatomic_or(p, mask_to_set);
        .                   nr -= bits_to_set;
        .                   bits_to_set = BITS_PER_LONG;
       15 ( 0.00%)          mask_to_set = ~0UL;
       15 ( 0.00%)          p++;
        .               }
        .           
        .               /* Full words */
1,079,529 ( 0.00%)      if (bits_to_set == BITS_PER_LONG) {
  468,507 ( 0.00%)          while (nr >= BITS_PER_LONG) {
  196,629 ( 0.00%)              *p = ~0UL;
  393,258 ( 0.00%)              nr -= BITS_PER_LONG;
  196,629 ( 0.00%)              p++;
        .                   }
        .               }
        .           
        .               /* Last word */
  719,716 ( 0.00%)      if (nr) {
1,439,372 ( 0.00%)          mask_to_set &= BITMAP_LAST_WORD_MASK(size);
  719,686 ( 0.00%)          qatomic_or(p, mask_to_set);
        .               } else {
        .                   /* If we avoided the full barrier in qatomic_or(), issue a
        .                    * barrier to account for the assignments in the while loop.
        .                    */
       30 ( 0.00%)          smp_mb();
        .               }
        .           }
        .           
        .           void bitmap_clear(unsigned long *map, long start, long nr)
        .           {
        .               unsigned long *p = map + BIT_WORD(start);
        .               const long size = start + nr;
        .               int bits_to_clear = BITS_PER_LONG - (start % BITS_PER_LONG);
-- line 225 ----------------------------------------
-- line 281 ----------------------------------------
        .                   }
        .                   *p &= ~mask_to_clear;
        .               }
        .           
        .               return dirty;
        .           }
        .           
        .           bool bitmap_test_and_clear_atomic(unsigned long *map, long start, long nr)
       87 ( 0.00%)  {
       87 ( 0.00%)      unsigned long *p = map + BIT_WORD(start);
       26 ( 0.00%)      const long size = start + nr;
      116 ( 0.00%)      int bits_to_clear = BITS_PER_LONG - (start % BITS_PER_LONG);
       60 ( 0.00%)      unsigned long mask_to_clear = BITMAP_FIRST_WORD_MASK(start);
       28 ( 0.00%)      unsigned long dirty = 0;
        .               unsigned long old_bits;
        .           
       58 ( 0.00%)      assert(start >= 0 && nr >= 0);
        .           
        .               /* First word */
      145 ( 0.00%)      if (nr - bits_to_clear > 0) {
       24 ( 0.00%)          old_bits = qatomic_fetch_and(p, ~mask_to_clear);
        3 ( 0.00%)          dirty |= old_bits & mask_to_clear;
        .                   nr -= bits_to_clear;
        .                   bits_to_clear = BITS_PER_LONG;
        .                   mask_to_clear = ~0UL;
        3 ( 0.00%)          p++;
        .               }
        .           
        .               /* Full words */
       52 ( 0.00%)      if (bits_to_clear == BITS_PER_LONG) {
       33 ( 0.00%)          while (nr >= BITS_PER_LONG) {
       18 ( 0.00%)              if (*p) {
       24 ( 0.00%)                  old_bits = qatomic_xchg(p, 0);
        9 ( 0.00%)                  dirty |= old_bits;
        .                       }
        9 ( 0.00%)              nr -= BITS_PER_LONG;
        9 ( 0.00%)              p++;
        .                   }
        .               }
        .           
        .               /* Last word */
       58 ( 0.00%)      if (nr) {
      130 ( 0.00%)          mask_to_clear &= BITMAP_LAST_WORD_MASK(size);
      208 ( 0.00%)          old_bits = qatomic_fetch_and(p, ~mask_to_clear);
       52 ( 0.00%)          dirty |= old_bits & mask_to_clear;
        .               } else {
        9 ( 0.00%)          if (!dirty) {
        .                       smp_mb();
        .                   }
        .               }
        .           
       78 ( 0.00%)      return dirty != 0;
        3 ( 0.00%)  }
        .           
        .           void bitmap_copy_and_clear_atomic(unsigned long *dst, unsigned long *src,
        .                                             long nr)
   79,996 ( 0.00%)  {
  919,954 ( 0.00%)      while (nr > 0) {
  939,953 ( 0.00%)          *dst = qatomic_xchg(src, 0);
  259,987 ( 0.00%)          dst++;
  259,987 ( 0.00%)          src++;
        .                   nr -= BITS_PER_LONG;
        .               }
   79,996 ( 0.00%)  }
        .           
        .           #define ALIGN_MASK(x,mask)      (((x)+(mask))&~(mask))
        .           
        .           /**
        .            * bitmap_find_next_zero_area - find a contiguous aligned zero area
        .            * @map: The address to base the search on
        .            * @size: The bitmap size in bits
        .            * @start: The bitnumber to start searching at
-- line 352 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c
--------------------------------------------------------------------------------
Ir                     

-- line 78 ----------------------------------------
            .           
            .           /* We currently can't handle more than 16 bits in the MMUIDX bitmask.
            .            */
            .           QEMU_BUILD_BUG_ON(NB_MMU_MODES > 16);
            .           #define ALL_MMUIDX_BITS ((1 << NB_MMU_MODES) - 1)
            .           
            .           static inline size_t tlb_n_entries(CPUTLBDescFast *fast)
            .           {
    5,760,612 ( 0.01%)      return (fast->mask >> CPU_TLB_ENTRY_BITS) + 1;
            .           }
            .           
            .           static inline size_t sizeof_tlb(CPUTLBDescFast *fast)
            .           {
           24 ( 0.00%)      return fast->mask + (1 << CPU_TLB_ENTRY_BITS);
            .           }
            .           
            .           static void tlb_window_reset(CPUTLBDesc *desc, int64_t ns,
            .                                        size_t max_entries)
            .           {
           12 ( 0.00%)      desc->window_begin_ns = ns;
           12 ( 0.00%)      desc->window_max_entries = max_entries;
            .           }
            .           
            .           static void tb_jmp_cache_clear_page(CPUState *cpu, target_ulong page_addr)
            .           {
            .               int i, i0 = tb_jmp_cache_hash_page(page_addr);
            .               CPUJumpCache *jc = cpu->tb_jmp_cache;
            .           
            .               for (i = 0; i < TB_JMP_PAGE_SIZE; i++) {
-- line 106 ----------------------------------------
-- line 220 ----------------------------------------
            .                   g_free(desc->fulltlb);
            .                   fast->table = g_try_new(CPUTLBEntry, new_size);
            .                   desc->fulltlb = g_try_new(CPUTLBEntryFull, new_size);
            .               }
            .           }
            .           
            .           static void tlb_mmu_flush_locked(CPUTLBDesc *desc, CPUTLBDescFast *fast)
            .           {
           12 ( 0.00%)      desc->n_used_entries = 0;
           12 ( 0.00%)      desc->large_page_addr = -1;
           12 ( 0.00%)      desc->large_page_mask = -1;
           12 ( 0.00%)      desc->vindex = 0;
            .               memset(fast->table, -1, sizeof_tlb(fast));
            .               memset(desc->vtable, -1, sizeof(desc->vtable));
            .           }
            .           
            .           static void tlb_flush_one_mmuidx_locked(CPUArchState *env, int mmu_idx,
            .                                                   int64_t now)
            .           {
            .               CPUTLBDesc *desc = &env_tlb(env)->d[mmu_idx];
-- line 239 ----------------------------------------
-- line 243 ----------------------------------------
            .               tlb_mmu_flush_locked(desc, fast);
            .           }
            .           
            .           static void tlb_mmu_init(CPUTLBDesc *desc, CPUTLBDescFast *fast, int64_t now)
            .           {
            .               size_t n_entries = 1 << CPU_TLB_DYN_DEFAULT_BITS;
            .           
            .               tlb_window_reset(desc, now, 0);
           12 ( 0.00%)      desc->n_used_entries = 0;
           12 ( 0.00%)      fast->mask = (n_entries - 1) << CPU_TLB_ENTRY_BITS;
           36 ( 0.00%)      fast->table = g_new(CPUTLBEntry, n_entries);
        2,580 ( 0.00%)  => ???:0x0000000004e3b870 (12x)
           36 ( 0.00%)      desc->fulltlb = g_new(CPUTLBEntryFull, n_entries);
        2,739 ( 0.00%)  => ???:0x0000000004e3b870 (12x)
            .               tlb_mmu_flush_locked(desc, fast);
            .           }
            .           
            .           static inline void tlb_n_used_entries_inc(CPUArchState *env, uintptr_t mmu_idx)
            .           {
      354,690 ( 0.00%)      env_tlb(env)->d[mmu_idx].n_used_entries++;
            .           }
            .           
            .           static inline void tlb_n_used_entries_dec(CPUArchState *env, uintptr_t mmu_idx)
            .           {
      444,829 ( 0.00%)      env_tlb(env)->d[mmu_idx].n_used_entries--;
      118,197 ( 0.00%)  }
            .           
            .           void tlb_init(CPUState *cpu)
            9 ( 0.00%)  {
            1 ( 0.00%)      CPUArchState *env = cpu->env_ptr;
            .               int64_t now = get_clock_realtime();
            .               int i;
            .           
            .               qemu_spin_init(&env_tlb(env)->c.lock);
            .           
            .               /* All tlbs are initialized flushed. */
            2 ( 0.00%)      env_tlb(env)->c.dirty = 0;
            .           
           49 ( 0.00%)      for (i = 0; i < NB_MMU_MODES; i++) {
            .                   tlb_mmu_init(&env_tlb(env)->d[i], &env_tlb(env)->f[i], now);
            .               }
            9 ( 0.00%)  }
            .           
            .           void tlb_destroy(CPUState *cpu)
            .           {
            .               CPUArchState *env = cpu->env_ptr;
            .               int i;
            .           
            .               qemu_spin_destroy(&env_tlb(env)->c.lock);
            .               for (i = 0; i < NB_MMU_MODES; i++) {
-- line 290 ----------------------------------------
-- line 328 ----------------------------------------
            .                   elide += qatomic_read(&env_tlb(env)->c.elide_flush_count);
            .               }
            .               *pfull = full;
            .               *ppart = part;
            .               *pelide = elide;
            .           }
            .           
            .           static void tlb_flush_by_mmuidx_async_work(CPUState *cpu, run_on_cpu_data data)
           84 ( 0.00%)  {
            6 ( 0.00%)      CPUArchState *env = cpu->env_ptr;
            .               uint16_t asked = data.host_int;
            .               uint16_t all_dirty, work, to_clean;
            .               int64_t now = get_clock_realtime();
            .           
            .               assert_cpu_is_self(cpu);
            .           
            .               tlb_debug("mmu_idx:0x%04" PRIx16 "\n", asked);
            .           
            .               qemu_spin_lock(&env_tlb(env)->c.lock);
            .           
            .               all_dirty = env_tlb(env)->c.dirty;
           18 ( 0.00%)      to_clean = asked & all_dirty;
           30 ( 0.00%)      all_dirty &= ~to_clean;
            .               env_tlb(env)->c.dirty = all_dirty;
            .           
           12 ( 0.00%)      for (work = to_clean; work != 0; work &= work - 1) {
            .                   int mmu_idx = ctz32(work);
            .                   tlb_flush_one_mmuidx_locked(env, mmu_idx, now);
            .               }
            .           
            .               qemu_spin_unlock(&env_tlb(env)->c.lock);
            .           
           12 ( 0.00%)      tcg_flush_jmp_cache(cpu);
       98,346 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/translate-all.c:tcg_flush_jmp_cache (6x)
            .           
            6 ( 0.00%)      if (to_clean == ALL_MMUIDX_BITS) {
            .                   qatomic_set(&env_tlb(env)->c.full_flush_count,
            .                              env_tlb(env)->c.full_flush_count + 1);
            .               } else {
           18 ( 0.00%)          qatomic_set(&env_tlb(env)->c.part_flush_count,
            .                              env_tlb(env)->c.part_flush_count + ctpop16(to_clean));
           18 ( 0.00%)          if (to_clean != asked) {
           30 ( 0.00%)              qatomic_set(&env_tlb(env)->c.elide_flush_count,
            .                                  env_tlb(env)->c.elide_flush_count +
            .                                  ctpop16(asked & ~to_clean));
            .                   }
            .               }
           72 ( 0.00%)  }
            .           
            .           void tlb_flush_by_mmuidx(CPUState *cpu, uint16_t idxmap)
           36 ( 0.00%)  {
            .               tlb_debug("mmu_idx: 0x%" PRIx16 "\n", idxmap);
            .           
           27 ( 0.00%)      if (cpu->created && !qemu_cpu_is_self(cpu)) {
           80 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:qemu_cpu_is_self (5x)
            .                   async_run_on_cpu(cpu, tlb_flush_by_mmuidx_async_work,
            .                                    RUN_ON_CPU_HOST_INT(idxmap));
            .               } else {
           18 ( 0.00%)          tlb_flush_by_mmuidx_async_work(cpu, RUN_ON_CPU_HOST_INT(idxmap));
       99,054 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:tlb_flush_by_mmuidx_async_work (6x)
            .               }
           18 ( 0.00%)  }
            .           
            .           void tlb_flush(CPUState *cpu)
            6 ( 0.00%)  {
           12 ( 0.00%)      tlb_flush_by_mmuidx(cpu, ALL_MMUIDX_BITS);
       99,233 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:tlb_flush_by_mmuidx (6x)
            .           }
            .           
            .           void tlb_flush_by_mmuidx_all_cpus(CPUState *src_cpu, uint16_t idxmap)
            .           {
            .               const run_on_cpu_func fn = tlb_flush_by_mmuidx_async_work;
            .           
            .               tlb_debug("mmu_idx: 0x%"PRIx16"\n", idxmap);
            .           
-- line 398 ----------------------------------------
-- line 418 ----------------------------------------
            .           void tlb_flush_all_cpus_synced(CPUState *src_cpu)
            .           {
            .               tlb_flush_by_mmuidx_all_cpus_synced(src_cpu, ALL_MMUIDX_BITS);
            .           }
            .           
            .           static bool tlb_hit_page_mask_anyprot(CPUTLBEntry *tlb_entry,
            .                                                 target_ulong page, target_ulong mask)
            .           {
      118,230 ( 0.00%)      page &= mask;
    1,348,552 ( 0.00%)      mask &= TARGET_PAGE_MASK | TLB_INVALID_MASK;
            .           
    4,075,936 ( 0.01%)      return (page == (tlb_entry->addr_read & mask) ||
    5,168,064 ( 0.01%)              page == (tlb_addr_write(tlb_entry) & mask) ||
    1,947,796 ( 0.00%)              page == (tlb_entry->addr_code & mask));
            .           }
            .           
            .           static inline bool tlb_hit_page_anyprot(CPUTLBEntry *tlb_entry,
            .                                                   target_ulong page)
            .           {
            .               return tlb_hit_page_mask_anyprot(tlb_entry, page, -1);
            .           }
            .           
            .           /**
            .            * tlb_entry_is_empty - return true if the entry is not in use
            .            * @te: pointer to CPUTLBEntry
            .            */
            .           static inline bool tlb_entry_is_empty(const CPUTLBEntry *te)
            .           {
      236,559 ( 0.00%)      return te->addr_read == -1 && te->addr_write == -1 && te->addr_code == -1;
            .           }
            .           
            .           /* Called with tlb_c.lock held */
            .           static bool tlb_flush_entry_mask_locked(CPUTLBEntry *tlb_entry,
            .                                                   target_ulong page,
            .                                                   target_ulong mask)
            .           {
            .               if (tlb_hit_page_mask_anyprot(tlb_entry, page, mask)) {
-- line 454 ----------------------------------------
-- line 463 ----------------------------------------
            .           {
            .               return tlb_flush_entry_mask_locked(tlb_entry, page, -1);
            .           }
            .           
            .           /* Called with tlb_c.lock held */
            .           static void tlb_flush_vtlb_page_mask_locked(CPUArchState *env, int mmu_idx,
            .                                                       target_ulong page,
            .                                                       target_ulong mask)
      472,920 ( 0.00%)  {
            .               CPUTLBDesc *d = &env_tlb(env)->d[mmu_idx];
            .               int k;
            .           
            .               assert_cpu_is_self(env_cpu(env));
    4,650,292 ( 0.01%)      for (k = 0; k < CPU_VTLB_SIZE; k++) {
            .                   if (tlb_flush_entry_mask_locked(&d->vtable[k], page, mask)) {
            .                       tlb_n_used_entries_dec(env, mmu_idx);
            .                   }
            .               }
            .           }
            .           
            .           static inline void tlb_flush_vtlb_page_locked(CPUArchState *env, int mmu_idx,
            .                                                         target_ulong page)
            .           {
      354,690 ( 0.00%)      tlb_flush_vtlb_page_mask_locked(env, mmu_idx, page, -1);
   17,413,134 ( 0.02%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:tlb_flush_vtlb_page_mask_locked (118,230x)
            .           }
            .           
            .           static void tlb_flush_page_locked(CPUArchState *env, int midx,
            .                                             target_ulong page)
            .           {
            .               target_ulong lp_addr = env_tlb(env)->d[midx].large_page_addr;
            .               target_ulong lp_mask = env_tlb(env)->d[midx].large_page_mask;
            .           
-- line 494 ----------------------------------------
-- line 949 ----------------------------------------
            .           {
            .               tlb_flush_range_by_mmuidx_all_cpus_synced(src_cpu, addr, TARGET_PAGE_SIZE,
            .                                                         idxmap, bits);
            .           }
            .           
            .           /* update the TLBs so that writes to code in the virtual page 'addr'
            .              can be detected */
            .           void tlb_protect_code(ram_addr_t ram_addr)
           50 ( 0.00%)  {
          125 ( 0.00%)      cpu_physical_memory_test_and_clear_dirty(ram_addr & TARGET_PAGE_MASK,
      644,720 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:cpu_physical_memory_test_and_clear_dirty (25x)
          100 ( 0.00%)                                               TARGET_PAGE_SIZE,
            .                                                        DIRTY_MEMORY_CODE);
            .           }
            .           
            .           /* update the TLB so that writes in physical page 'phys_addr' are no longer
            .              tested for self modifying code */
            .           void tlb_unprotect_code(ram_addr_t ram_addr)
            .           {
            .               cpu_physical_memory_set_dirty_flag(ram_addr, DIRTY_MEMORY_CODE);
-- line 967 ----------------------------------------
-- line 982 ----------------------------------------
            .            * te->addr_write with qatomic_set. We don't need to worry about this for
            .            * oversized guests as MTTCG is disabled for them.
            .            *
            .            * Called with tlb_c.lock held.
            .            */
            .           static void tlb_reset_dirty_range_locked(CPUTLBEntry *tlb_entry,
            .                                                    uintptr_t start, uintptr_t length)
            .           {
  506,933,856 ( 0.70%)      uintptr_t addr = tlb_entry->addr_write;
            .           
1,013,867,712 ( 1.39%)      if ((addr & (TLB_INVALID_MASK | TLB_MMIO |
            .                            TLB_DISCARD_WRITE | TLB_NOTDIRTY)) == 0) {
    2,106,516 ( 0.00%)          addr &= TARGET_PAGE_MASK;
            .                   addr += tlb_entry->addend;
    2,633,145 ( 0.00%)          if ((addr - start) < length) {
            .           #if TCG_OVERSIZED_GUEST
            .                       tlb_entry->addr_write |= TLB_NOTDIRTY;
            .           #else
      337,618 ( 0.00%)              qatomic_set(&tlb_entry->addr_write,
            .                                  tlb_entry->addr_write | TLB_NOTDIRTY);
            .           #endif
            .                   }
            .               }
            .           }
            .           
            .           /*
            .            * Called with tlb_c.lock held.
            .            * Called only from the vCPU context, i.e. the TLB's owner thread.
            .            */
            .           static inline void copy_tlb_helper_locked(CPUTLBEntry *d, const CPUTLBEntry *s)
            .           {
   96,839,553 ( 0.13%)      *d = *s;
            .           }
            .           
            .           /* This is a cross vCPU call (i.e. another vCPU resetting the flags of
            .            * the target vCPU).
            .            * We must take tlb_c.lock to avoid racing with another vCPU update. The only
            .            * thing actually updated is the target TLB entry ->addr_write flags.
            .            */
            .           void tlb_reset_dirty(CPUState *cpu, ram_addr_t start1, ram_addr_t length)
      800,085 ( 0.00%)  {
            .               CPUArchState *env;
            .           
            .               int mmu_idx;
            .           
      160,017 ( 0.00%)      env = cpu->env_ptr;
            .               qemu_spin_lock(&env_tlb(env)->c.lock);
    8,320,884 ( 0.01%)      for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {
            .                   unsigned int i;
            .                   unsigned int n = tlb_n_entries(&env_tlb(env)->f[mmu_idx]);
            .           
1,491,998,508 ( 2.05%)          for (i = 0; i < n; i++) {
  983,144,448 ( 1.35%)              tlb_reset_dirty_range_locked(&env_tlb(env)->f[mmu_idx].table[i],
            .                                                    start1, length);
            .                   }
            .           
   61,453,139 ( 0.08%)          for (i = 0; i < CPU_VTLB_SIZE; i++) {
            .                       tlb_reset_dirty_range_locked(&env_tlb(env)->d[mmu_idx].vtable[i],
            .                                                    start1, length);
            .                   }
            .               }
            .               qemu_spin_unlock(&env_tlb(env)->c.lock);
      480,051 ( 0.00%)  }
            .           
            .           /* Called with tlb_c.lock held */
            .           static inline void tlb_set_dirty1_locked(CPUTLBEntry *tlb_entry,
            .                                                    target_ulong vaddr)
            .           {
   21,380,970 ( 0.03%)      if (tlb_entry->addr_write == (vaddr | TLB_NOTDIRTY)) {
       97,630 ( 0.00%)          tlb_entry->addr_write = vaddr;
            .               }
            .           }
            .           
            .           /* update the TLB corresponding to virtual page vaddr
            .              so that it is no longer dirty */
            .           void tlb_set_dirty(CPUState *cpu, target_ulong vaddr)
       97,630 ( 0.00%)  {
       97,630 ( 0.00%)      CPUArchState *env = cpu->env_ptr;
            .               int mmu_idx;
            .           
            .               assert_cpu_is_self(cpu);
            .           
      195,260 ( 0.00%)      vaddr &= TARGET_PAGE_MASK;
            .               qemu_spin_lock(&env_tlb(env)->c.lock);
    4,002,830 ( 0.01%)      for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {
            .                   tlb_set_dirty1_locked(tlb_entry(env, mmu_idx, vaddr), vaddr);
            .               }
            .           
    3,514,680 ( 0.00%)      for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {
            .                   int k;
   30,460,560 ( 0.04%)          for (k = 0; k < CPU_VTLB_SIZE; k++) {
            .                       tlb_set_dirty1_locked(&env_tlb(env)->d[mmu_idx].vtable[k], vaddr);
            .                   }
            .               }
            .               qemu_spin_unlock(&env_tlb(env)->c.lock);
       97,630 ( 0.00%)  }
            .           
            .           /* Our TLB does not support large pages, so remember the area covered by
            .              large pages and trigger a full TLB flush if these are invalidated.  */
            .           static void tlb_add_large_page(CPUArchState *env, int mmu_idx,
            .                                          target_ulong vaddr, target_ulong size)
            .           {
            .               target_ulong lp_addr = env_tlb(env)->d[mmu_idx].large_page_addr;
            .               target_ulong lp_mask = ~(size - 1);
            .           
            .               if (lp_addr == (target_ulong)-1) {
            .                   /* No previous large page.  */
       99,623 ( 0.00%)          lp_addr = vaddr;
            .               } else {
            .                   /* Extend the existing region to include the new page.
            .                      This is a compromise between unnecessary flushes and
            .                      the cost of maintaining a full variable size TLB.  */
            .                   lp_mask &= env_tlb(env)->d[mmu_idx].large_page_mask;
            .                   while (((lp_addr ^ vaddr) & lp_mask) != 0) {
            .                       lp_mask <<= 1;
            .                   }
-- line 1097 ----------------------------------------
-- line 1105 ----------------------------------------
            .            * is permitted. Only a single TARGET_PAGE_SIZE region is mapped, the
            .            * supplied size is only used by tlb_flush_page.
            .            *
            .            * Called from TCG-generated code, which is under an RCU read-side
            .            * critical section.
            .            */
            .           void tlb_set_page_full(CPUState *cpu, int mmu_idx,
            .                                  target_ulong vaddr, CPUTLBEntryFull *full)
    1,536,990 ( 0.00%)  {
      472,920 ( 0.00%)      CPUArchState *env = cpu->env_ptr;
            .               CPUTLB *tlb = env_tlb(env);
            .               CPUTLBDesc *desc = &tlb->d[mmu_idx];
            .               MemoryRegionSection *section;
            .               unsigned int index;
            .               target_ulong address;
            .               target_ulong write_address;
            .               uintptr_t addend;
            .               CPUTLBEntry *te, tn;
            .               hwaddr iotlb, xlat, sz, paddr_page;
            .               target_ulong vaddr_page;
            .               int asidx, wp_flags, prot;
            .               bool is_ram, is_romd;
            .           
            .               assert_cpu_is_self(cpu);
            .           
      709,380 ( 0.00%)      if (full->lg_page_size <= TARGET_PAGE_BITS) {
      827,610 ( 0.00%)          sz = TARGET_PAGE_SIZE;
            .               } else {
            .                   sz = (hwaddr)1 << full->lg_page_size;
            .                   tlb_add_large_page(env, mmu_idx, vaddr, sz);
            .               }
      236,460 ( 0.00%)      vaddr_page = vaddr & TARGET_PAGE_MASK;
      472,920 ( 0.00%)      paddr_page = full->phys_addr & TARGET_PAGE_MASK;
            .           
      236,460 ( 0.00%)      prot = full->prot;
      591,150 ( 0.00%)      asidx = cpu_asidx_from_attrs(cpu, full->attrs);
    2,364,600 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/cpu-sysemu.c:cpu_asidx_from_attrs (118,230x)
    1,182,300 ( 0.00%)      section = address_space_translate_for_iotlb(cpu, asidx, paddr_page,
   18,068,777 ( 0.02%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:address_space_translate_for_iotlb (118,230x)
            .                                                           &xlat, &sz, full->attrs, &prot);
      591,150 ( 0.00%)      assert(sz >= TARGET_PAGE_SIZE);
            .           
            .               tlb_debug("vaddr=" TARGET_FMT_lx " paddr=0x" TARGET_FMT_plx
            .                         " prot=%x idx=%d\n",
            .                         vaddr, full->phys_addr, prot, mmu_idx);
            .           
            .               address = vaddr_page;
      118,230 ( 0.00%)      if (full->lg_page_size < TARGET_PAGE_BITS) {
            .                   /* Repeat the MMU check and TLB fill on every access.  */
      591,150 ( 0.00%)          address |= TLB_INVALID_MASK;
            .               }
            .               if (full->attrs.byte_swap) {
      591,150 ( 0.00%)          address |= TLB_BSWAP;
            .               }
            .           
      118,230 ( 0.00%)      is_ram = memory_region_is_ram(section->mr);
            .               is_romd = memory_region_is_romd(section->mr);
            .           
      236,460 ( 0.00%)      if (is_ram || is_romd) {
            .                   /* RAM and ROMD both have associated host memory. */
      398,492 ( 0.00%)          addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;
    2,390,952 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_get_ram_ptr (99,623x)
            .               } else {
            .                   /* I/O does not; force the host address to NULL. */
       37,214 ( 0.00%)          addend = 0;
            .               }
            .           
      341,668 ( 0.00%)      write_address = address;
       99,623 ( 0.00%)      if (is_ram) {
      498,115 ( 0.00%)          iotlb = memory_region_get_ram_addr(section->mr) + xlat;
      597,738 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_get_ram_addr (99,623x)
            .                   /*
            .                    * Computing is_clean is expensive; avoid all that unless
            .                    * the page is actually writable.
            .                    */
      199,246 ( 0.00%)          if (prot & PAGE_WRITE) {
      498,115 ( 0.00%)              if (section->readonly) {
            .                           write_address |= TLB_DISCARD_WRITE;
            .                       } else if (cpu_physical_memory_is_clean(iotlb)) {
       56,824 ( 0.00%)                  write_address |= TLB_NOTDIRTY;
            .                       }
            .                   }
            .               } else {
            .                   /* I/O or ROMD */
       74,428 ( 0.00%)          iotlb = memory_region_section_get_iotlb(cpu, section) + xlat;
      130,249 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:memory_region_section_get_iotlb (18,607x)
            .                   /*
            .                    * Writes to romd devices must go through MMIO to enable write.
            .                    * Reads to romd devices go through the ram_ptr found above,
            .                    * but of course reads to I/O must go through MMIO.
            .                    */
       37,214 ( 0.00%)          write_address |= TLB_MMIO;
            .                   if (!is_romd) {
            .                       address = write_address;
            .                   }
            .               }
            .           
      945,840 ( 0.00%)      wp_flags = cpu_watchpoint_address_matches(cpu, vaddr_page,
      827,610 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:cpu_watchpoint_address_matches (118,230x)
            .                                                         TARGET_PAGE_SIZE);
            .           
      236,460 ( 0.00%)      index = tlb_index(env, mmu_idx, vaddr_page);
            .               te = tlb_entry(env, mmu_idx, vaddr_page);
            .           
            .               /*
            .                * Hold the TLB lock for the rest of the function. We could acquire/release
            .                * the lock several times in the function, but it is faster to amortize the
            .                * acquisition cost by acquiring it just once. Note that this leads to
            .                * a longer critical section, but this is not a concern since the TLB lock
            .                * is unlikely to be contended.
            .                */
            .               qemu_spin_lock(&tlb->c.lock);
            .           
            .               /* Note that the tlb is no longer clean.  */
      945,840 ( 0.00%)      tlb->c.dirty |= 1 << mmu_idx;
            .           
            .               /* Make sure there's no cached translation for the new page.  */
            .               tlb_flush_vtlb_page_locked(env, mmu_idx, vaddr_page);
            .           
            .               /*
            .                * Only evict the old entry to the victim tlb if it's for a
            .                * different page; otherwise just overwrite the stale data.
            .                */
            .               if (!tlb_hit_page_anyprot(te, vaddr_page) && !tlb_entry_is_empty(te)) {
      709,182 ( 0.00%)          unsigned vidx = desc->vindex++ % CPU_VTLB_SIZE;
            .                   CPUTLBEntry *tv = &desc->vtable[vidx];
            .           
            .                   /* Evict the old entry into the victim tlb.  */
            .                   copy_tlb_helper_locked(tv, te);
    1,063,773 ( 0.00%)          desc->vfulltlb[vidx] = desc->fulltlb[index];
            .                   tlb_n_used_entries_dec(env, mmu_idx);
            .               }
            .           
            .               /* refill the tlb */
            .               /*
            .                * At this point iotlb contains a physical section number in the lower
            .                * TARGET_PAGE_BITS, and either
            .                *  + the ram_addr_t of the page base of the target RAM (RAM)
-- line 1236 ----------------------------------------
-- line 1237 ----------------------------------------
            .                *  + the offset within section->mr of the page base (I/O, ROMD)
            .                * We subtract the vaddr_page (which is page aligned and thus won't
            .                * disturb the low bits) to give an offset which can be added to the
            .                * (non-page-aligned) vaddr of the eventual memory access to get
            .                * the MemoryRegion offset for the access. Note that the vaddr we
            .                * subtract here is that of the page base, and not the same as the
            .                * vaddr we add back in io_readx()/io_writex()/get_page_addr_code().
            .                */
      827,610 ( 0.00%)      desc->fulltlb[index] = *full;
      472,920 ( 0.00%)      desc->fulltlb[index].xlat_section = iotlb - vaddr_page;
      354,690 ( 0.00%)      desc->fulltlb[index].phys_addr = paddr_page;
      354,690 ( 0.00%)      desc->fulltlb[index].prot = prot;
            .           
            .               /* Now calculate the new entry */
      236,460 ( 0.00%)      tn.addend = addend - vaddr_page;
      236,460 ( 0.00%)      if (prot & PAGE_READ) {
            .                   tn.addr_read = address;
            .                   if (wp_flags & BP_MEM_READ) {
      591,150 ( 0.00%)              tn.addr_read |= TLB_WATCHPOINT;
            .                   }
            .               } else {
      118,230 ( 0.00%)          tn.addr_read = -1;
            .               }
            .           
            .               if (prot & PAGE_EXEC) {
            .                   tn.addr_code = address;
            .               } else {
      472,920 ( 0.00%)          tn.addr_code = -1;
            .               }
            .           
            .               tn.addr_write = -1;
      236,460 ( 0.00%)      if (prot & PAGE_WRITE) {
            .                   tn.addr_write = write_address;
            .                   if (prot & PAGE_WRITE_INV) {
      472,920 ( 0.00%)              tn.addr_write |= TLB_INVALID_MASK;
            .                   }
            .                   if (wp_flags & BP_MEM_WRITE) {
      591,150 ( 0.00%)              tn.addr_write |= TLB_WATCHPOINT;
            .                   }
            .               }
            .           
            .               copy_tlb_helper_locked(te, &tn);
            .               tlb_n_used_entries_inc(env, mmu_idx);
            .               qemu_spin_unlock(&tlb->c.lock);
    1,300,530 ( 0.00%)  }
            .           
            .           void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,
            .                                        hwaddr paddr, MemTxAttrs attrs, int prot,
            .                                        int mmu_idx, target_ulong size)
            .           {
            .               CPUTLBEntryFull full = {
            .                   .phys_addr = paddr,
            .                   .attrs = attrs,
-- line 1289 ----------------------------------------
-- line 1312 ----------------------------------------
            .                                MMUAccessType access_type, int mmu_idx, uintptr_t retaddr)
            .           {
            .               bool ok;
            .           
            .               /*
            .                * This is not a probe, so only valid return is success; failure
            .                * should result in exception + longjmp to the cpu loop.
            .                */
    1,288,764 ( 0.00%)      ok = cpu->cc->tcg_ops->tlb_fill(cpu, addr, size,
   76,195,782 ( 0.10%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/tlb_helper.c:arm_cpu_tlb_fill (71,607x)
            .                                               access_type, mmu_idx, false, retaddr);
      644,382 ( 0.00%)      assert(ok);
            .           }
            .           
            .           static inline void cpu_unaligned_access(CPUState *cpu, vaddr addr,
            .                                                   MMUAccessType access_type,
            .                                                   int mmu_idx, uintptr_t retaddr)
            .           {
            .               cpu->cc->tcg_ops->do_unaligned_access(cpu, addr, access_type,
            .                                                     mmu_idx, retaddr);
-- line 1330 ----------------------------------------
-- line 1345 ----------------------------------------
            .                                                      access_type, mmu_idx, attrs,
            .                                                      response, retaddr);
            .               }
            .           }
            .           
            .           static uint64_t io_readx(CPUArchState *env, CPUTLBEntryFull *full,
            .                                    int mmu_idx, target_ulong addr, uintptr_t retaddr,
            .                                    MMUAccessType access_type, MemOp op)
   29,932,032 ( 0.04%)  {
            .               CPUState *cpu = env_cpu(env);
            .               hwaddr mr_offset;
            .               MemoryRegionSection *section;
            .               MemoryRegion *mr;
            .               uint64_t val;
            .               bool locked = false;
            .               MemTxResult r;
            .           
    9,353,760 ( 0.01%)      section = iotlb_to_section(cpu, full->xlat_section, full->attrs);
   84,183,840 ( 0.12%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:iotlb_to_section (1,870,752x)
    1,870,752 ( 0.00%)      mr = section->mr;
    7,483,008 ( 0.01%)      mr_offset = (full->xlat_section & TARGET_PAGE_MASK) + addr;
    3,741,504 ( 0.01%)      cpu->mem_io_pc = retaddr;
    7,483,008 ( 0.01%)      if (!cpu->can_do_io) {
            .                   cpu_io_recompile(cpu, retaddr);
            .               }
            .           
    7,483,008 ( 0.01%)      if (!qemu_mutex_iothread_locked()) {
   41,156,544 ( 0.06%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:qemu_mutex_iothread_locked (1,870,752x)
    5,612,019 ( 0.01%)          qemu_mutex_lock_iothread();
  121,593,745 ( 0.17%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:qemu_mutex_lock_iothread_impl (1,870,673x)
            .                   locked = true;
            .               }
   11,224,512 ( 0.02%)      r = memory_region_dispatch_read(mr, mr_offset, &val, op, full->attrs);
  988,507,149 ( 1.36%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_dispatch_read (1,870,752x)
    3,741,504 ( 0.01%)      if (r != MEMTX_OK) {
            .                   hwaddr physaddr = mr_offset +
            .                       section->offset_within_address_space -
            .                       section->offset_within_region;
            .           
            .                   cpu_transaction_failed(cpu, physaddr, addr, memop_size(op), access_type,
            .                                          mmu_idx, full->attrs, r, retaddr);
            .               }
            .               if (locked) {
    3,741,346 ( 0.01%)          qemu_mutex_unlock_iothread();
  106,628,361 ( 0.15%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:qemu_mutex_unlock_iothread (1,870,673x)
            .               }
            .           
    1,870,752 ( 0.00%)      return val;
   20,578,272 ( 0.03%)  }
            .           
            .           /*
            .            * Save a potentially trashed CPUTLBEntryFull for later lookup by plugin.
            .            * This is read by tlb_plugin_lookup if the fulltlb entry doesn't match
            .            * because of the side effect of io_writex changing memory layout.
            .            */
            .           static void save_iotlb_data(CPUState *cs, MemoryRegionSection *section,
            .                                       hwaddr mr_offset)
            .           {
            .           #ifdef CONFIG_PLUGIN
            .               SavedIOTLB *saved = &cs->saved_iotlb;
    1,341,859 ( 0.00%)      saved->section = section;
    1,341,859 ( 0.00%)      saved->mr_offset = mr_offset;
            .           #endif
            .           }
            .           
            .           static void io_writex(CPUArchState *env, CPUTLBEntryFull *full,
            .                                 int mmu_idx, uint64_t val, target_ulong addr,
            .                                 uintptr_t retaddr, MemOp op)
   20,127,885 ( 0.03%)  {
            .               CPUState *cpu = env_cpu(env);
            .               hwaddr mr_offset;
            .               MemoryRegionSection *section;
            .               MemoryRegion *mr;
            .               bool locked = false;
            .               MemTxResult r;
            .           
    6,709,295 ( 0.01%)      section = iotlb_to_section(cpu, full->xlat_section, full->attrs);
   60,383,655 ( 0.08%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:iotlb_to_section (1,341,859x)
    1,341,859 ( 0.00%)      mr = section->mr;
    8,051,154 ( 0.01%)      mr_offset = (full->xlat_section & TARGET_PAGE_MASK) + addr;
    4,025,577 ( 0.01%)      if (!cpu->can_do_io) {
            .                   cpu_io_recompile(cpu, retaddr);
            .               }
    4,025,577 ( 0.01%)      cpu->mem_io_pc = retaddr;
            .           
            .               /*
            .                * The memory_region_dispatch may trigger a flush/resize
            .                * so for plugins we save the iotlb_data just in case.
            .                */
            .               save_iotlb_data(cpu, section, mr_offset);
            .           
    5,367,436 ( 0.01%)      if (!qemu_mutex_iothread_locked()) {
   29,520,898 ( 0.04%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:qemu_mutex_iothread_locked (1,341,859x)
    4,025,541 ( 0.01%)          qemu_mutex_lock_iothread();
   87,220,055 ( 0.12%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:qemu_mutex_lock_iothread_impl (1,341,847x)
            .                   locked = true;
            .               }
    9,393,013 ( 0.01%)      r = memory_region_dispatch_write(mr, mr_offset, val, op, full->attrs);
  454,050,692 ( 0.62%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_dispatch_write (1,341,859x)
    2,683,718 ( 0.00%)      if (r != MEMTX_OK) {
            .                   hwaddr physaddr = mr_offset +
            .                       section->offset_within_address_space -
            .                       section->offset_within_region;
            .           
            .                   cpu_transaction_failed(cpu, physaddr, addr, memop_size(op),
            .                                          MMU_DATA_STORE, mmu_idx, full->attrs, r,
            .                                          retaddr);
            .               }
            .               if (locked) {
    1,341,847 ( 0.00%)          qemu_mutex_unlock_iothread();
   76,485,279 ( 0.10%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:qemu_mutex_unlock_iothread (1,341,847x)
            .               }
    9,393,025 ( 0.01%)  }
            .           
            .           static inline target_ulong tlb_read_ofs(CPUTLBEntry *entry, size_t ofs)
            .           {
            .           #if TCG_OVERSIZED_GUEST
            .               return *(target_ulong *)((uintptr_t)entry + ofs);
            .           #else
            .               /* ofs might correspond to .addr_write, so use qatomic_read */
   11,297,117 ( 0.02%)      return qatomic_read((target_ulong *)((uintptr_t)entry + ofs));
            .           #endif
            .           }
            .           
            .           /* Return true if ADDR is present in the victim tlb, and has been copied
            .              back to the main tlb.  */
            .           static bool victim_tlb_hit(CPUArchState *env, size_t mmu_idx, size_t index,
            .                                      size_t elt_ofs, target_ulong page)
   45,247,104 ( 0.06%)  {
            .               size_t vidx;
            .           
            .               assert_cpu_is_self(env_cpu(env));
  101,748,282 ( 0.14%)      for (vidx = 0; vidx < CPU_VTLB_SIZE; ++vidx) {
            .                   CPUTLBEntry *vtlb = &env_tlb(env)->d[mmu_idx].vtable[vidx];
            .                   target_ulong cmp;
            .           
            .                   /* elt_ofs might correspond to .addr_write, so use qatomic_read */
            .           #if TCG_OVERSIZED_GUEST
            .                   cmp = *(target_ulong *)((uintptr_t)vtlb + elt_ofs);
            .           #else
   88,465,848 ( 0.12%)          cmp = qatomic_read((target_ulong *)((uintptr_t)vtlb + elt_ofs));
            .           #endif
            .           
   58,977,232 ( 0.08%)          if (cmp == page) {
            .                       /* Found entry in victim tlb, swap tlb and iotlb.  */
   31,728,210 ( 0.04%)              CPUTLBEntry tmptlb, *tlb = &env_tlb(env)->f[mmu_idx].table[index];
            .           
            .                       qemu_spin_lock(&env_tlb(env)->c.lock);
            .                       copy_tlb_helper_locked(&tmptlb, tlb);
            .                       copy_tlb_helper_locked(tlb, vtlb);
            .                       copy_tlb_helper_locked(vtlb, &tmptlb);
            .                       qemu_spin_unlock(&env_tlb(env)->c.lock);
            .           
    6,345,642 ( 0.01%)              CPUTLBEntryFull *f1 = &env_tlb(env)->d[mmu_idx].fulltlb[index];
            .                       CPUTLBEntryFull *f2 = &env_tlb(env)->d[mmu_idx].vfulltlb[vidx];
            .                       CPUTLBEntryFull tmpf;
   88,838,988 ( 0.12%)              tmpf = *f1; *f1 = *f2; *f2 = tmpf;
   12,691,284 ( 0.02%)              return true;
            .                   }
            .               }
      118,230 ( 0.00%)      return false;
   32,319,360 ( 0.04%)  }
            .           
            .           /* Macro to call the above, with local variables from the use context.  */
            .           #define VICTIM_TLB_HIT(TY, ADDR) \
            .             victim_tlb_hit(env, mmu_idx, index, offsetof(CPUTLBEntry, TY), \
            .                            (ADDR) & TARGET_PAGE_MASK)
            .           
    1,366,820 ( 0.00%)  static void notdirty_write(CPUState *cpu, vaddr mem_vaddr, unsigned size,
            .                                      CPUTLBEntryFull *full, uintptr_t retaddr)
            .           {
      292,890 ( 0.00%)      ram_addr_t ram_addr = mem_vaddr + full->xlat_section;
            .           
            .               trace_memory_notdirty_write_access(mem_vaddr, ram_addr, size);
            .           
            .               if (!cpu_physical_memory_get_dirty_flag(ram_addr, DIRTY_MEMORY_CODE)) {
            .                   struct page_collection *pages
      195,260 ( 0.00%)              = page_collection_lock(ram_addr, ram_addr + size);
            .                   tb_invalidate_phys_page_fast(pages, ram_addr, size, retaddr);
            .                   page_collection_unlock(pages);
            .               }
            .           
            .               /*
            .                * Set both VGA and migration bits for simplicity and to remove
            .                * the notdirty callback faster.
            .                */
            .               cpu_physical_memory_set_dirty_range(ram_addr, size, DIRTY_CLIENTS_NOCODE);
            .           
            .               /* We remove the notdirty callback only if the code has been flushed. */
            .               if (!cpu_physical_memory_is_clean(ram_addr)) {
            .                   trace_memory_notdirty_set_dirty(mem_vaddr);
      585,780 ( 0.00%)          tlb_set_dirty(cpu, mem_vaddr);
   66,095,510 ( 0.09%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:tlb_set_dirty (97,630x)
            .               }
      683,410 ( 0.00%)  }
            .           
            .           static int probe_access_internal(CPUArchState *env, target_ulong addr,
            .                                            int fault_size, MMUAccessType access_type,
            .                                            int mmu_idx, bool nonfault,
            .                                            void **phost, CPUTLBEntryFull **pfull,
            .                                            uintptr_t retaddr)
   79,005,615 ( 0.11%)  {
    5,267,041 ( 0.01%)      uintptr_t index = tlb_index(env, mmu_idx, addr);
            .               CPUTLBEntry *entry = tlb_entry(env, mmu_idx, addr);
            .               target_ulong tlb_addr, page_addr;
            .               size_t elt_ofs;
            .               int flags;
            .           
   15,801,123 ( 0.02%)      switch (access_type) {
            .               case MMU_DATA_LOAD:
            .                   elt_ofs = offsetof(CPUTLBEntry, addr_read);
            .                   break;
            .               case MMU_DATA_STORE:
            .                   elt_ofs = offsetof(CPUTLBEntry, addr_write);
            .                   break;
            .               case MMU_INST_FETCH:
            .                   elt_ofs = offsetof(CPUTLBEntry, addr_code);
            .                   break;
            .               default:
            .                   g_assert_not_reached();
            .               }
            .               tlb_addr = tlb_read_ofs(entry, elt_ofs);
            .           
    5,621,476 ( 0.01%)      flags = TLB_FLAGS_MASK;
   26,335,205 ( 0.04%)      page_addr = addr & TARGET_PAGE_MASK;
   10,534,082 ( 0.01%)      if (!tlb_hit_page(tlb_addr, page_addr)) {
    4,137,111 ( 0.01%)          if (!victim_tlb_hit(env, mmu_idx, index, elt_ofs, page_addr)) {
   32,669,526 ( 0.04%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:victim_tlb_hit (376,101x)
            .                       CPUState *cs = env_cpu(env);
            .           
      162,495 ( 0.00%)              if (!cs->cc->tcg_ops->tlb_fill(cs, addr, fault_size, access_type,
   12,174,617 ( 0.02%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../target/arm/tlb_helper.c:arm_cpu_tlb_fill (10,833x)
            .                                                      mmu_idx, nonfault, retaddr)) {
            .                           /* Non-faulting page table read failed.  */
            .                           *phost = NULL;
            .                           *pfull = NULL;
            .                           return TLB_INVALID_MASK;
            .                       }
            .           
            .                       /* TLB resize via tlb_fill may have moved the entry.  */
-- line 1571 ----------------------------------------
-- line 1572 ----------------------------------------
            .                       index = tlb_index(env, mmu_idx, addr);
            .                       entry = tlb_entry(env, mmu_idx, addr);
            .           
            .                       /*
            .                        * With PAGE_WRITE_INV, we set TLB_INVALID_MASK immediately,
            .                        * to force the next access through tlb_fill.  We've just
            .                        * called tlb_fill, so we know that this entry *is* valid.
            .                        */
       10,833 ( 0.00%)              flags &= ~TLB_INVALID_MASK;
            .                   }
            .                   tlb_addr = tlb_read_ofs(entry, elt_ofs);
            .               }
    5,267,041 ( 0.01%)      flags &= tlb_addr;
            .           
   21,068,164 ( 0.03%)      *pfull = &env_tlb(env)->d[mmu_idx].fulltlb[index];
            .           
            .               /* Fold all "mmio-like" bits into TLB_MMIO.  This is not RAM.  */
   10,534,082 ( 0.01%)      if (unlikely(flags & ~(TLB_WATCHPOINT | TLB_NOTDIRTY))) {
            .                   *phost = NULL;
            .                   return TLB_MMIO;
            .               }
            .           
            .               /* Everything else is RAM. */
   15,801,123 ( 0.02%)      *phost = (void *)((uintptr_t)addr + entry->addend);
            .               return flags;
   42,136,328 ( 0.06%)  }
            .           
            .           int probe_access_full(CPUArchState *env, target_ulong addr,
            .                                 MMUAccessType access_type, int mmu_idx,
            .                                 bool nonfault, void **phost, CPUTLBEntryFull **pfull,
            .                                 uintptr_t retaddr)
            .           {
            .               int flags = probe_access_internal(env, addr, 0, access_type, mmu_idx,
            .                                                 nonfault, phost, pfull, retaddr);
-- line 1605 ----------------------------------------
-- line 1679 ----------------------------------------
            .            * of RAM.  This will force us to execute by loading and translating
            .            * one insn at a time, without caching.
            .            *
            .            * NOTE: This function will trigger an exception if the page is
            .            * not executable.
            .            */
            .           tb_page_addr_t get_page_addr_code_hostp(CPUArchState *env, target_ulong addr,
            .                                                   void **hostp)
   36,869,287 ( 0.05%)  {
            .               CPUTLBEntryFull *full;
            .               void *p;
            .           
   52,670,410 ( 0.07%)      (void)probe_access_internal(env, addr, 1, MMU_INST_FETCH,
  371,637,384 ( 0.51%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:probe_access_internal (5,267,041x)
            .                                           cpu_mmu_index(env, true), false, &p, &full, 0);
   21,068,164 ( 0.03%)      if (p == NULL) {
            .                   return -1;
            .               }
   10,534,082 ( 0.01%)      if (hostp) {
          750 ( 0.00%)          *hostp = p;
            .               }
   21,068,164 ( 0.03%)      return qemu_ram_addr_from_host_nofail(p);
  331,797,438 ( 0.45%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:qemu_ram_addr_from_host_nofail (5,267,041x)
   10,534,082 ( 0.01%)  }
            .           
            .           #ifdef CONFIG_PLUGIN
            .           /*
            .            * Perform a TLB lookup and populate the qemu_plugin_hwaddr structure.
            .            * This should be a hot path as we will have just looked this path up
            .            * in the softmmu lookup code (or helper). We don't handle re-fills or
            .            * checking the victim table. This is purely informational.
            .            *
-- line 1708 ----------------------------------------
-- line 1878 ----------------------------------------
            .           typedef uint64_t FullLoadHelper(CPUArchState *env, target_ulong addr,
            .                                           MemOpIdx oi, uintptr_t retaddr);
            .           
            .           static inline uint64_t QEMU_ALWAYS_INLINE
            .           load_memop(const void *haddr, MemOp op)
            .           {
            .               switch (op) {
            .               case MO_UB:
      108,067 ( 0.00%)          return ldub_p(haddr);
            .               case MO_BEUW:
            .                   return lduw_be_p(haddr);
            .               case MO_LEUW:
            .                   return lduw_le_p(haddr);
            .               case MO_BEUL:
            .                   return (uint32_t)ldl_be_p(haddr);
            .               case MO_LEUL:
    6,804,008 ( 0.01%)          return (uint32_t)ldl_le_p(haddr);
            .               case MO_BEUQ:
            .                   return ldq_be_p(haddr);
            .               case MO_LEUQ:
            .                   return ldq_le_p(haddr);
            .               default:
            .                   qemu_build_not_reached();
            .               }
            .           }
-- line 1902 ----------------------------------------
-- line 1907 ----------------------------------------
            .                       FullLoadHelper *full_load)
            .           {
            .               const size_t tlb_off = code_read ?
            .                   offsetof(CPUTLBEntry, addr_code) : offsetof(CPUTLBEntry, addr_read);
            .               const MMUAccessType access_type =
            .                   code_read ? MMU_INST_FETCH : MMU_DATA_LOAD;
            .               const unsigned a_bits = get_alignment_bits(get_memop(oi));
            .               const size_t size = memop_size(op);
    5,380,823 ( 0.01%)      uintptr_t mmu_idx = get_mmuidx(oi);
            .               uintptr_t index;
            .               CPUTLBEntry *entry;
            .               target_ulong tlb_addr;
            .               void *haddr;
            .               uint64_t res;
            .           
            .               tcg_debug_assert(mmu_idx < NB_MMU_MODES);
            .           
            .               /* Handle CPU specific unaligned behaviour */
    1,303,832 ( 0.00%)      if (addr & ((1 << a_bits) - 1)) {
      253,338 ( 0.00%)          cpu_unaligned_access(env_cpu(env), addr, access_type,
            .                                        mmu_idx, retaddr);
            .               }
            .           
            .               index = tlb_index(env, mmu_idx, addr);
            .               entry = tlb_entry(env, mmu_idx, addr);
    5,380,823 ( 0.01%)      tlb_addr = code_read ? entry->addr_code : entry->addr_read;
            .           
            .               /* If the TLB entry is for a different page, reload and try again.  */
   10,761,646 ( 0.01%)      if (!tlb_hit(tlb_addr, addr)) {
   42,344,124 ( 0.06%)          if (!victim_tlb_hit(env, mmu_idx, index, tlb_off,
  297,322,145 ( 0.41%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:victim_tlb_hit (3,420,610x)
            .                                       addr & TARGET_PAGE_MASK)) {
            .                       tlb_fill(env_cpu(env), addr, size,
            .                                access_type, mmu_idx, retaddr);
            .                       index = tlb_index(env, mmu_idx, addr);
            .                       entry = tlb_entry(env, mmu_idx, addr);
            .                   }
            .                   tlb_addr = code_read ? entry->addr_code : entry->addr_read;
   10,586,031 ( 0.01%)          tlb_addr &= ~TLB_INVALID_MASK;
            .               }
            .           
            .               /* Handle anything that isn't just a straight memory access.  */
   21,396,623 ( 0.03%)      if (unlikely(tlb_addr & ~TARGET_PAGE_MASK)) {
            .                   CPUTLBEntryFull *full;
            .                   bool need_swap;
            .           
            .                   /* For anything that is unaligned, recurse through full_load.  */
    7,408,600 ( 0.01%)          if ((addr & (size - 1)) != 0) {
            .                       goto do_unaligned_access;
            .                   }
            .           
    7,483,008 ( 0.01%)          full = &env_tlb(env)->d[mmu_idx].fulltlb[index];
            .           
            .                   /* Handle watchpoints.  */
    3,741,504 ( 0.01%)          if (unlikely(tlb_addr & TLB_WATCHPOINT)) {
            .                       /* On watchpoint hit, this will longjmp out.  */
            .                       cpu_check_watchpoint(env_cpu(env), addr, size,
            .                                            full->attrs, BP_MEM_READ, retaddr);
            .                   }
            .           
    3,704,300 ( 0.01%)          need_swap = size > 1 && (tlb_addr & TLB_BSWAP);
            .           
            .                   /* Handle I/O access.  */
    9,297,954 ( 0.01%)          if (likely(tlb_addr & TLB_MMIO)) {
   22,449,024 ( 0.03%)              return io_readx(env, full, mmu_idx, addr, retaddr,
1,447,936,380 ( 1.99%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:io_readx (1,852,150x)
            .                                       access_type, op ^ (need_swap * MO_BSWAP));
            .                   }
            .           
            .                   haddr = (void *)((uintptr_t)addr + entry->addend);
            .           
            .                   /*
            .                    * Keep these two load_memop separate to ensure that the compiler
            .                    * is able to fold the entire function to a single instruction.
-- line 1978 ----------------------------------------
-- line 1981 ----------------------------------------
            .                   if (unlikely(need_swap)) {
            .                       return load_memop(haddr, op ^ MO_BSWAP);
            .                   }
            .                   return load_memop(haddr, op);
            .               }
            .           
            .               /* Handle slow unaligned access (it spans two pages or IO).  */
            .               if (size > 1
   20,412,024 ( 0.03%)          && unlikely((addr & ~TARGET_PAGE_MASK) + size - 1
            .                               >= TARGET_PAGE_SIZE)) {
            .                   target_ulong addr1, addr2;
            .                   uint64_t r1, r2;
            .                   unsigned shift;
            .               do_unaligned_access:
            .                   addr1 = addr & ~((target_ulong)size - 1);
            .                   addr2 = addr1 + size;
            .                   r1 = full_load(env, addr1, oi, retaddr);
-- line 1997 ----------------------------------------
-- line 2019 ----------------------------------------
            .            * tcg_target_long, except in the case of a 32-bit host and 64-bit
            .            * data, and for that we always have uint64_t.
            .            *
            .            * We don't bother with this widened value for SOFTMMU_CODE_ACCESS.
            .            */
            .           
            .           static uint64_t full_ldub_mmu(CPUArchState *env, target_ulong addr,
            .                                         MemOpIdx oi, uintptr_t retaddr)
    1,266,690 ( 0.00%)  {
            .               validate_memop(oi, MO_UB);
            .               return load_helper(env, addr, oi, retaddr, MO_UB, false, full_ldub_mmu);
    1,013,352 ( 0.00%)  }
            .           
            .           tcg_target_ulong helper_ret_ldub_mmu(CPUArchState *env, target_ulong addr,
            .                                                MemOpIdx oi, uintptr_t retaddr)
      126,669 ( 0.00%)  {
      126,669 ( 0.00%)      return full_ldub_mmu(env, addr, oi, retaddr);
   29,584,858 ( 0.04%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:full_ldub_mmu (126,669x)
            .           }
            .           
            .           static uint64_t full_le_lduw_mmu(CPUArchState *env, target_ulong addr,
            .                                            MemOpIdx oi, uintptr_t retaddr)
            .           {
            .               validate_memop(oi, MO_LEUW);
            .               return load_helper(env, addr, oi, retaddr, MO_LEUW, false,
            .                                  full_le_lduw_mmu);
-- line 2043 ----------------------------------------
-- line 2060 ----------------------------------------
            .           tcg_target_ulong helper_be_lduw_mmu(CPUArchState *env, target_ulong addr,
            .                                               MemOpIdx oi, uintptr_t retaddr)
            .           {
            .               return full_be_lduw_mmu(env, addr, oi, retaddr);
            .           }
            .           
            .           static uint64_t full_le_ldul_mmu(CPUArchState *env, target_ulong addr,
            .                                            MemOpIdx oi, uintptr_t retaddr)
   57,795,694 ( 0.08%)  {
            .               validate_memop(oi, MO_LEUL);
            .               return load_helper(env, addr, oi, retaddr, MO_LEUL, false,
            .                                  full_le_ldul_mmu);
   42,033,232 ( 0.06%)  }
            .           
            .           tcg_target_ulong helper_le_ldul_mmu(CPUArchState *env, target_ulong addr,
            .                                               MemOpIdx oi, uintptr_t retaddr)
    5,254,154 ( 0.01%)  {
    5,254,154 ( 0.01%)      return full_le_ldul_mmu(env, addr, oi, retaddr);
2,202,683,105 ( 3.02%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:full_le_ldul_mmu (5,254,154x)
            .           }
            .           
            .           static uint64_t full_be_ldul_mmu(CPUArchState *env, target_ulong addr,
            .                                            MemOpIdx oi, uintptr_t retaddr)
            .           {
            .               validate_memop(oi, MO_BEUL);
            .               return load_helper(env, addr, oi, retaddr, MO_BEUL, false,
            .                                  full_be_ldul_mmu);
-- line 2085 ----------------------------------------
-- line 2203 ----------------------------------------
            .            * Store Helpers
            .            */
            .           
            .           static inline void QEMU_ALWAYS_INLINE
            .           store_memop(void *haddr, uint64_t val, MemOp op)
            .           {
            .               switch (op) {
            .               case MO_UB:
       74,408 ( 0.00%)          stb_p(haddr, val);
            .                   break;
            .               case MO_BEUW:
            .                   stw_be_p(haddr, val);
            .                   break;
            .               case MO_LEUW:
            .                   stw_le_p(haddr, val);
            .                   break;
            .               case MO_BEUL:
            .                   stl_be_p(haddr, val);
            .                   break;
            .               case MO_LEUL:
    2,521,491 ( 0.00%)          stl_le_p(haddr, val);
            .                   break;
            .               case MO_BEUQ:
            .                   stq_be_p(haddr, val);
            .                   break;
            .               case MO_LEUQ:
            .                   stq_le_p(haddr, val);
            .                   break;
            .               default:
-- line 2231 ----------------------------------------
-- line 2314 ----------------------------------------
            .           
            .           static inline void QEMU_ALWAYS_INLINE
            .           store_helper(CPUArchState *env, target_ulong addr, uint64_t val,
            .                        MemOpIdx oi, uintptr_t retaddr, MemOp op)
            .           {
            .               const size_t tlb_off = offsetof(CPUTLBEntry, addr_write);
            .               const unsigned a_bits = get_alignment_bits(get_memop(oi));
            .               const size_t size = memop_size(op);
    3,998,184 ( 0.01%)      uintptr_t mmu_idx = get_mmuidx(oi);
            .               uintptr_t index;
            .               CPUTLBEntry *entry;
            .               target_ulong tlb_addr;
            .               void *haddr;
            .           
            .               tcg_debug_assert(mmu_idx < NB_MMU_MODES);
            .           
            .               /* Handle CPU specific unaligned behaviour */
      900,988 ( 0.00%)      if (addr & ((1 << a_bits) - 1)) {
      186,020 ( 0.00%)          cpu_unaligned_access(env_cpu(env), addr, MMU_DATA_STORE,
            .                                        mmu_idx, retaddr);
            .               }
            .           
            .               index = tlb_index(env, mmu_idx, addr);
            .               entry = tlb_entry(env, mmu_idx, addr);
            .               tlb_addr = tlb_addr_write(entry);
            .           
            .               /* If the TLB entry is for a different page, reload and try again.  */
    7,996,368 ( 0.01%)      if (!tlb_hit(tlb_addr, addr)) {
   35,827,316 ( 0.05%)          if (!victim_tlb_hit(env, mmu_idx, index, tlb_off,
    3,236,628 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:victim_tlb_hit (37,204x)
            .                       addr & TARGET_PAGE_MASK)) {
            .                       tlb_fill(env_cpu(env), addr, size, MMU_DATA_STORE,
            .                                mmu_idx, retaddr);
            .                       index = tlb_index(env, mmu_idx, addr);
            .                       entry = tlb_entry(env, mmu_idx, addr);
            .                   }
    5,118,188 ( 0.01%)          tlb_addr = tlb_addr_write(entry) & ~TLB_INVALID_MASK;
            .               }
            .           
            .               /* Handle anything that isn't just a straight memory access.  */
   15,899,726 ( 0.02%)      if (unlikely(tlb_addr & ~TARGET_PAGE_MASK)) {
            .                   CPUTLBEntryFull *full;
            .                   bool need_swap;
            .           
            .                   /* For anything that is unaligned, recurse through byte stores.  */
    4,151,049 ( 0.01%)          if ((addr & (size - 1)) != 0) {
            .                       goto do_unaligned_access;
            .                   }
            .           
    5,757,956 ( 0.01%)          full = &env_tlb(env)->d[mmu_idx].fulltlb[index];
            .           
            .                   /* Handle watchpoints.  */
    2,878,978 ( 0.00%)          if (unlikely(tlb_addr & TLB_WATCHPOINT)) {
            .                       /* On watchpoint hit, this will longjmp out.  */
            .                       cpu_check_watchpoint(env_cpu(env), addr, size,
            .                                            full->attrs, BP_MEM_WRITE, retaddr);
            .                   }
            .           
    6,625,525 ( 0.01%)          need_swap = size > 1 && (tlb_addr & TLB_BSWAP);
            .           
            .                   /* Handle I/O access.  */
    2,878,978 ( 0.00%)          if (tlb_addr & TLB_MMIO) {
   12,076,731 ( 0.02%)              io_writex(env, full, mmu_idx, val, addr, retaddr,
   84,118,244 ( 0.12%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:io_writex (55,806x)
    2,572,106 ( 0.00%)                        op ^ (need_swap * MO_BSWAP));
    4,025,577 ( 0.01%)              return;
            .                   }
            .           
            .                   /* Ignore writes to ROM.  */
      195,260 ( 0.00%)          if (unlikely(tlb_addr & TLB_DISCARD_WRITE)) {
            .                       return;
            .                   }
            .           
            .                   /* Handle clean RAM pages.  */
      195,260 ( 0.00%)          if (tlb_addr & TLB_NOTDIRTY) {
      683,410 ( 0.00%)              notdirty_write(env_cpu(env), addr, size, full, retaddr);
  107,758,762 ( 0.15%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:notdirty_write.isra.0 (97,630x)
            .                   }
            .           
       97,630 ( 0.00%)          haddr = (void *)((uintptr_t)addr + entry->addend);
            .           
            .                   /*
            .                    * Keep these two store_memop separate to ensure that the compiler
            .                    * is able to fold the entire function to a single instruction.
            .                    * There is a build-time assert inside to remind you of this.  ;-)
            .                    */
            .                   if (unlikely(need_swap)) {
            .                       store_memop(haddr, val, op ^ MO_BSWAP);
-- line 2398 ----------------------------------------
-- line 2399 ----------------------------------------
            .                   } else {
            .                       store_memop(haddr, val, op);
            .                   }
            .                   return;
            .               }
            .           
            .               /* Handle slow unaligned access (it spans two pages or IO).  */
            .               if (size > 1
   15,128,946 ( 0.02%)          && unlikely((addr & ~TARGET_PAGE_MASK) + size - 1
            .                                >= TARGET_PAGE_SIZE)) {
            .               do_unaligned_access:
            .                   store_helper_unaligned(env, addr, val, retaddr, size,
            .                                          mmu_idx, memop_big_endian(op));
            .                   return;
            .               }
            .           
            .               haddr = (void *)((uintptr_t)addr + entry->addend);
            .               store_memop(haddr, val, op);
            .           }
            .           
            .           static void __attribute__((noinline))
            .           full_stb_mmu(CPUArchState *env, target_ulong addr, uint64_t val,
            .                        MemOpIdx oi, uintptr_t retaddr)
    1,023,110 ( 0.00%)  {
            .               validate_memop(oi, MO_UB);
            .               store_helper(env, addr, val, oi, retaddr, MO_UB);
      744,080 ( 0.00%)  }
   96,730,370 ( 0.13%)  => ???:0x0000000058c773f8 (18,602x)
   27,642,159 ( 0.04%)  => ???:0x0000000058c76768 (18,602x)
    4,799,523 ( 0.01%)  => ???:0x0000000058c9067a (18,602x)
    3,385,564 ( 0.00%)  => ???:0x0000000058c81c97 (18,602x)
    1,395,150 ( 0.00%)  => ???:0x0000000058c76c16 (18,602x)
            .           
            .           void helper_ret_stb_mmu(CPUArchState *env, target_ulong addr, uint8_t val,
            .                                   MemOpIdx oi, uintptr_t retaddr)
       93,010 ( 0.00%)  {
      186,020 ( 0.00%)      full_stb_mmu(env, addr, val, oi, retaddr);
  229,120,478 ( 0.31%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:full_stb_mmu (93,010x)
            .           }
            .           
            .           static void full_le_stw_mmu(CPUArchState *env, target_ulong addr, uint64_t val,
            .                                       MemOpIdx oi, uintptr_t retaddr)
            .           {
            .               validate_memop(oi, MO_LEUW);
            .               store_helper(env, addr, val, oi, retaddr, MO_LEUW);
            .           }
-- line 2438 ----------------------------------------
-- line 2453 ----------------------------------------
            .           void helper_be_stw_mmu(CPUArchState *env, target_ulong addr, uint16_t val,
            .                                  MemOpIdx oi, uintptr_t retaddr)
            .           {
            .               full_be_stw_mmu(env, addr, val, oi, retaddr);
            .           }
            .           
            .           static void full_le_stl_mmu(CPUArchState *env, target_ulong addr, uint64_t val,
            .                                       MemOpIdx oi, uintptr_t retaddr)
   42,956,914 ( 0.06%)  {
            .               validate_memop(oi, MO_LEUL);
            .               store_helper(env, addr, val, oi, retaddr, MO_LEUL);
   31,241,392 ( 0.04%)  }
  721,017,729 ( 0.99%)  => ???:0x0000000058cb96a3 (183,950x)
  292,937,741 ( 0.40%)  => ???:0x0000000058ca0b75 (37,204x)
  241,541,565 ( 0.33%)  => ???:0x0000000058c5f6ae (20,000x)
  103,277,790 ( 0.14%)  => ???:0x0000000058c60d96 (19,161x)
  103,239,468 ( 0.14%)  => ???:0x0000000058c60812 (19,161x)
   65,888,284 ( 0.09%)  => ???:0x0000000058c63e62 (2,195,036x)
   65,206,273 ( 0.09%)  => ???:0x0000000058c6405d (18,602x)
   62,502,720 ( 0.09%)  => ???:0x0000000058c77455 (18,602x)
   48,290,708 ( 0.07%)  => ???:0x0000000058c84599 (74,408x)
   44,990,635 ( 0.06%)  => ???:0x0000000058c5f303 (20,000x)
   39,064,414 ( 0.05%)  => ???:0x0000000058c9d8a8 (186,020x)
   34,338,298 ( 0.05%)  => ???:0x0000000058c9e9b5 (37,204x)
   34,338,296 ( 0.05%)  => ???:0x0000000058c9ef35 (37,204x)
   22,900,339 ( 0.03%)  => ???:0x0000000058ca2877 (3,737x)
   22,341,147 ( 0.03%)  => ???:0x0000000058c639c8 (18,602x)
   21,410,603 ( 0.03%)  => ???:0x0000000058ca0075 (37,204x)
   19,542,211 ( 0.03%)  => ???:0x0000000058c8e699 (24,262x)
   16,619,873 ( 0.02%)  => ???:0x0000000058c5ffc4 (20,000x)
   15,980,659 ( 0.02%)  => ???:0x0000000058c61313 (19,161x)
   15,848,902 ( 0.02%)  => ???:0x0000000058ca05f5 (37,204x)
   14,538,744 ( 0.02%)  => ???:0x0000000058c94bd9 (24,262x)
    9,766,205 ( 0.01%)  => ???:0x0000000058c8c4a0 (55,806x)
    8,445,505 ( 0.01%)  => ???:0x0000000058c9e0e6 (37,204x)
    7,328,227 ( 0.01%)  => ???:0x0000000058ca5161 (6,566x)
    6,380,486 ( 0.01%)  => ???:0x0000000058c62e57 (130,214x)
    6,118,460 ( 0.01%)  => ???:0x0000000058caf799 (8,490x)
    5,390,686 ( 0.01%)  => ???:0x0000000058ca4c7d (6,566x)
    2,548,474 ( 0.00%)  => ???:0x0000000058c6cf3c (18,602x)
    2,278,086 ( 0.00%)  => ???:0x0000000058cb5f2c (2,830x)
    1,153,324 ( 0.00%)  => ???:0x0000000058c622ca (18,602x)
      982,755 ( 0.00%)  => ???:0x0000000058ca58fa (3,736x)
      688,274 ( 0.00%)  => ???:0x0000000058c84114 (18,602x)
      353,438 ( 0.00%)  => ???:0x0000000058c77e8a (18,602x)
      157,584 ( 0.00%)  => ???:0x0000000058ca4f89 (6,566x)
      118,188 ( 0.00%)  => ???:0x0000000058ca4a04 (6,566x)
       53,770 ( 0.00%)  => ???:0x0000000058cb5b94 (2,830x)
       50,958 ( 0.00%)  => ???:0x0000000058c79414 (2,831x)
          566 ( 0.00%)  => ???:0x0000000058c62680 (1x)
          527 ( 0.00%)  => ???:0x0000000058c82c99 (1x)
          526 ( 0.00%)  => ???:0x0000000058c90c99 (1x)
          426 ( 0.00%)  => ???:0x0000000058ca1f01 (1x)
          426 ( 0.00%)  => ???:0x0000000058ca22b1 (1x)
          118 ( 0.00%)  => ???:0x0000000058c7e92d (1x)
           92 ( 0.00%)  => ???:0x0000000058c8a399 (1x)
           63 ( 0.00%)  => ???:0x0000000058c62e1c (1x)
           62 ( 0.00%)  => ???:0x0000000058c62b36 (1x)
           21 ( 0.00%)  => ???:0x0000000058c63c1d (1x)
            .           
            .           void helper_le_stl_mmu(CPUArchState *env, target_ulong addr, uint32_t val,
            .                                  MemOpIdx oi, uintptr_t retaddr)
    3,905,174 ( 0.01%)  {
    7,810,348 ( 0.01%)      full_le_stl_mmu(env, addr, val, oi, retaddr);
3,172,083,720 ( 4.35%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cputlb.c:full_le_stl_mmu (3,395,607x)
            .           }
            .           
            .           static void full_be_stl_mmu(CPUArchState *env, target_ulong addr, uint64_t val,
            .                                       MemOpIdx oi, uintptr_t retaddr)
            .           {
            .               validate_memop(oi, MO_BEUL);
            .               store_helper(env, addr, val, oi, retaddr, MO_BEUL);
            .           }
-- line 2477 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/xx-common-tcgloop.c
--------------------------------------------------------------------------------
Ir                 

-- line 58 ----------------------------------------
        .           int tcg_remove_breakpoint(CPUState *cs, int type, hwaddr addr, hwaddr len);
        .           int tcg_insert_breakpoint(CPUState *cs, int type, hwaddr addr, hwaddr len);
        .           int tcg_gdbstub_supported_sstep_flags(void);
        .           
        .           extern bool tcg_allowed;
        .           
        .           enum XX_CPU_TYPE xx_cpu_type;
        .           enum XX_CPU_TYPE get_xx_cpu_type(){ return xx_cpu_type; }
        4 ( 0.00%)  void set_xx_cpu_type(enum XX_CPU_TYPE type) { xx_cpu_type = type; }
        .           
        .           
        .           
        .           struct XX_RAMRegion
        .           {
        .               char *name;
        .               hwaddr start;
        .               hwaddr size;
-- line 74 ----------------------------------------
-- line 89 ----------------------------------------
        .           struct XX_RAMRegion xx_ram_regions[XX_MEM_REGIONS_MAX];
        .           int xx_num_ram_regions;
        .           struct XX_MMIORegion xx_mmio_regions[XX_MEM_REGIONS_MAX];
        .           int xx_num_mmio_regions;
        .           
        .           
        .           
        .           MemTxResult xx_ram_rw(hwaddr addr,hwaddr len,void *buf, bool is_write)
  329,168 ( 0.00%)  {
  329,168 ( 0.00%)      if (is_write) {
  822,916 ( 0.00%)          return address_space_write(&address_space_memory, addr, MEMTXATTRS_UNSPECIFIED, buf, len);
122,815,466 ( 0.17%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:address_space_write (164,580x)
        .               } else {
        4 ( 0.00%)          return address_space_read_full(&address_space_memory, addr, MEMTXATTRS_UNSPECIFIED, buf, len);
  820,520 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:address_space_read_full (4x)
        .               }
        .           }
        .           
        .           static bool check_mem_overlap(hwaddr start, hwaddr size)
        .           {
        .               int i;
        8 ( 0.00%)      hwaddr end = start + size;
      140 ( 0.00%)      for(i=0; i < xx_num_ram_regions;i++)
        .               {
       44 ( 0.00%)          if(
      154 ( 0.00%)              !(start >= xx_ram_regions[i].start + xx_ram_regions[i].size || end <= xx_ram_regions[i].start)
        .                   )
        .                   return true;
        .               }
       74 ( 0.00%)      for(i=0; i < xx_num_mmio_regions;i++)
        .               {
       12 ( 0.00%)          if(
       42 ( 0.00%)              !(start >= xx_mmio_regions[i].start + xx_mmio_regions[i].size || end <= xx_mmio_regions[i].start)
        .                   )
        .                   return true;
        .               }
        5 ( 0.00%)      return false;
        5 ( 0.00%)  }
        .           static bool check_mem_addr_and_size(hwaddr start, hwaddr size)
        .           {
        .               hwaddr page_size = TARGET_PAGE_BITS == 0 ? 4 << 10 : 1 << TARGET_PAGE_BITS;
  560,004 ( 0.00%)      if(start & (page_size -1) != 0 || size & (page_size - 1) != 0)
        .               {
        .                   return false;
        .               }
        .               return true;
        .           }
        .           static MemoryRegion *find_mr_by_addr(hwaddr start, hwaddr size)
        .           {
   79,996 ( 0.00%)      MemoryRegion *mr = NULL;
        .               int i;
1,439,928 ( 0.00%)      for(i=0; i < xx_num_ram_regions;i++)
        .               {
1,959,902 ( 0.00%)          if(start >= xx_ram_regions[i].start && start + size <= xx_ram_regions[i].start + xx_ram_regions[i].size)
        .                   {
   79,996 ( 0.00%)              mr = xx_ram_regions[i].mr;
        .                   }
        .               }
1,839,908 ( 0.00%)      for(i=0; i < xx_num_mmio_regions;i++)
        .               {
1,119,944 ( 0.00%)          if(start >= xx_mmio_regions[i].start && start + size <= xx_mmio_regions[i].start + xx_mmio_regions[i].size)
        .                   {
        .                       mr = xx_mmio_regions[i].mr;
        .                   }
        .               }
        .               return mr;
        .           }
        .           
        .           void xx_add_ram_regions(char *name,hwaddr start, hwaddr size)
       24 ( 0.00%)  {
       24 ( 0.00%)      if(xx_num_ram_regions >= XX_MEM_REGIONS_MAX)
        .                   return;
       24 ( 0.00%)      if(check_mem_overlap(start,size))
      134 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/xx-common-tcgloop.c:check_mem_overlap (4x)
        .                   return;
        .               if(!check_mem_addr_and_size(start,size))
        .                   return;
       28 ( 0.00%)      xx_ram_regions[xx_num_ram_regions].name = strdup(name);
    1,020 ( 0.00%)  => ???:0x0000000004e3cf20 (4x)
        4 ( 0.00%)      xx_ram_regions[xx_num_ram_regions].start = start;
        4 ( 0.00%)      xx_ram_regions[xx_num_ram_regions].size = size;
        8 ( 0.00%)      xx_num_ram_regions++;
        .           
       24 ( 0.00%)  }
        .           void xx_add_mmio_regions(char *name, hwaddr start, hwaddr size, void *read_cb, void *write_cb)
       32 ( 0.00%)  {
       24 ( 0.00%)      if(xx_num_mmio_regions >= XX_MEM_REGIONS_MAX)
        .                   return;
       32 ( 0.00%)      if(check_mem_overlap(start,size))
      350 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/xx-common-tcgloop.c:check_mem_overlap (4x)
        .                   return;
        .               if(!check_mem_addr_and_size(start,size))
        .                   return;
       32 ( 0.00%)      xx_mmio_regions[xx_num_mmio_regions].name = strdup(name);
    1,008 ( 0.00%)  => ???:0x0000000004e3cf20 (4x)
        4 ( 0.00%)      xx_mmio_regions[xx_num_mmio_regions].start = start;
        4 ( 0.00%)      xx_mmio_regions[xx_num_mmio_regions].size = size;
        4 ( 0.00%)      xx_mmio_regions[xx_num_mmio_regions].read_cb = read_cb;
        4 ( 0.00%)      xx_mmio_regions[xx_num_mmio_regions].write_cb = write_cb;
        8 ( 0.00%)      xx_num_mmio_regions++;
       32 ( 0.00%)  }
        .           
        .           RAMBlock *qemu_get_ram_block(ram_addr_t addr);
        .           void xx_clear_dirty_mem(ram_addr_t addr, ram_addr_t size)
  479,976 ( 0.00%)  {
   79,996 ( 0.00%)      RAMBlock *block = qemu_get_ram_block(addr);
  959,952 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:qemu_get_ram_block (79,996x)
   79,996 ( 0.00%)      MemoryRegion *mr = block->mr;
        .           
  319,984 ( 0.00%)      tlb_reset_dirty_range_all(addr, size);
2,041,977,896 ( 2.80%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:tlb_reset_dirty_range_all (79,996x)
  319,984 ( 0.00%)      memory_region_clear_dirty_bitmap(mr, 0, size);
2,719,864 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_clear_dirty_bitmap (79,996x)
        .               //printf("clear dirty pages %p-%p\n",addr,addr+size);
  239,988 ( 0.00%)  }
        .           int xx_target_pagesize()
   19,999 ( 0.00%)  {
   79,996 ( 0.00%)      return 1 << TARGET_PAGE_BITS;
   19,999 ( 0.00%)  }
        .           void xx_get_dirty_pages(hwaddr addr,hwaddr size, unsigned long dirty[])
  639,968 ( 0.00%)  {
        .               int num_page_in_byte = 0;
  559,972 ( 0.00%)      hwaddr page_size = TARGET_PAGE_BITS == 0 ? 4 << 10 : 1 << TARGET_PAGE_BITS;
        .               if(!check_mem_addr_and_size(addr,size))
        .                   return;
        .               MemoryRegion *mr = find_mr_by_addr(addr,size);
  159,992 ( 0.00%)      if(!mr)
        .                   return;
  559,972 ( 0.00%)      DirtyBitmapSnapshot * snap = memory_region_snapshot_and_clear_dirty(mr,addr - mr->addr , size, DIRTY_MEMORY_VGA);
2,089,081,598 ( 2.86%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_snapshot_and_clear_dirty (79,996x)
  639,968 ( 0.00%)      num_page_in_byte = ((size / page_size) / 8) + (((size / page_size) % 8) ? 1 : 0) ;
        .           
   79,996 ( 0.00%)      memcpy(dirty,snap->dirty,num_page_in_byte);
  159,992 ( 0.00%)      g_free(snap);
9,918,642 ( 0.01%)  => ???:0x0000000004e3a950 (79,996x)
        .               //printf("get dirty pages %p-%p totally :%d byte\n",addr,addr+size,num_page_in_byte);
  399,980 ( 0.00%)  }
        .           
        .           
        .           void xx_init_mem(MachineState *machine)
        8 ( 0.00%)  {
        .           
        .                           
        2 ( 0.00%)      MemoryRegion *ram_space = get_system_memory();
        3 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:get_system_memory (1x)
        1 ( 0.00%)      MemoryRegion *mmio_space = get_system_io();
        3 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:get_system_io (1x)
        .               int i;
       24 ( 0.00%)      for(i=0; i < xx_num_ram_regions;i++)
        .               {
       12 ( 0.00%)          MemoryRegion *mr = g_new0(MemoryRegion, 1);
    1,476 ( 0.00%)  => ???:0x0000000004e3cc20 (4x)
       24 ( 0.00%)          memory_region_init_ram(mr,NULL,xx_ram_regions[i].name,xx_ram_regions[i].size,0);
   73,045 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_init_ram (4x)
       16 ( 0.00%)          memory_region_set_log(mr, true, DIRTY_MEMORY_VGA);
  332,253 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_set_log (4x)
       20 ( 0.00%)          memory_region_reset_dirty(mr, 0, xx_ram_regions[i].size, DIRTY_MEMORY_VGA);
    1,209 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_reset_dirty (4x)
       16 ( 0.00%)          memory_region_add_subregion(ram_space,xx_ram_regions[i].start,mr);
  412,356 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_add_subregion (4x)
        4 ( 0.00%)          xx_ram_regions[i].mr = mr;
       12 ( 0.00%)          printf("add ram %x-%x %s\n",xx_ram_regions[i].start, xx_ram_regions[i].start+xx_ram_regions[i].size, xx_ram_regions[i].name);
        .               }
       26 ( 0.00%)      for(i=0; i < xx_num_mmio_regions;i++)
        .               {
       12 ( 0.00%)          struct MemoryRegionOps *ops = g_new0(MemoryRegionOps, 1);
    1,068 ( 0.00%)  => ???:0x0000000004e3cc20 (4x)
        8 ( 0.00%)          ops->read = xx_mmio_regions[i].read_cb;
        8 ( 0.00%)          ops->write = xx_mmio_regions[i].write_cb;
        4 ( 0.00%)          ops->read_with_attrs = 0;
        4 ( 0.00%)          ops->write_with_attrs = 0;
        4 ( 0.00%)          ops->endianness = DEVICE_NATIVE_ENDIAN;
        6 ( 0.00%)          ops->valid.min_access_size = 1;
        .                   ops->valid.max_access_size = 8;
        4 ( 0.00%)          ops->valid.unaligned = true;
        4 ( 0.00%)          ops->valid.accepts = NULL;
        4 ( 0.00%)          ops->impl.min_access_size = 1;
        .                   ops->impl.max_access_size = 8;
        4 ( 0.00%)          ops->impl.unaligned = true;
       12 ( 0.00%)          MemoryRegion *mr = g_new0(MemoryRegion, 1);
    1,120 ( 0.00%)  => ???:0x0000000004e3cc20 (4x)
       28 ( 0.00%)          memory_region_init_io(mr,NULL,ops,NULL,xx_mmio_regions[i].name,xx_mmio_regions[i].size);
   66,460 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_init_io (4x)
        .           	    //memory_region_add_subregion(mmio_space,xx_mmio_regions[i].start,mr);
        .                   // memory_region_set_log(mr, true, DIRTY_MEMORY_VGA);
        .                   // memory_region_reset_dirty(mr, 0, xx_ram_regions[i].size, DIRTY_MEMORY_VGA);
       16 ( 0.00%)          memory_region_add_subregion(ram_space,xx_mmio_regions[i].start,mr);
  533,555 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_add_subregion (4x)
        4 ( 0.00%)          xx_mmio_regions[i].mr = mr;
        .           
       12 ( 0.00%)          printf("add mmio %x-%x %s\n",xx_mmio_regions[i].start, xx_mmio_regions[i].start+xx_mmio_regions[i].size, xx_mmio_regions[i].name);
        .               }
        8 ( 0.00%)  }
        .           
        .           void xx_register_exec_bbl_hook(exec_bbl_cb cb)
        1 ( 0.00%)  {
        2 ( 0.00%)      exec_bbl_func = cb;
        1 ( 0.00%)  }
        .           void xx_register_exec_ins_icmp_hook(exec_ins_icmp_cb cb)
        .           {
        .               exec_ins_icmp_func = cb;
        .           }
        .           
        .           
        .           int xx_thread_loop(bool debug)
  905,605 ( 0.00%)  {
        .               int r;
  543,363 ( 0.00%)      CPUState *cpu = qemu_get_cpu(0);
1,448,968 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../cpus-common.c:qemu_get_cpu (181,121x)
        .               static bool init = false; 
  362,242 ( 0.00%)      if(!init)
        .               {
        2 ( 0.00%)  		cpu->thread_id = qemu_get_thread_id();
       21 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/oslib-posix.c:qemu_get_thread_id (1x)
        1 ( 0.00%)          cpu->can_do_io = 1;
        1 ( 0.00%)          cpu->created = true;
        1 ( 0.00%)          cpu->exit_request = false;
        .                   
        1 ( 0.00%)          tcg_register_thread();
   40,068 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../tcg/tcg.c:tcg_register_thread (1x)
        2 ( 0.00%)          qemu_guest_random_seed_thread_part2(0);
       27 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/guest-random.c:qemu_guest_random_seed_thread_part2 (1x)
        .           		CPUClass *cc = CPU_GET_CLASS(cpu);
        .           
        2 ( 0.00%)          init = true;
        .               }
        .               //qemu_mutex_unlock_iothread();
  724,484 ( 0.00%)      if(!cpu->stop && !cpu->exit_request)
        .               {
  724,484 ( 0.00%)          if(!cpu_work_list_empty(cpu))
  905,605 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:cpu_work_list_empty (181,121x)
        .           	        process_queued_cpu_work(cpu);
  362,242 ( 0.00%)  		if(debug)
        .           			main_loop_wait(true);
  724,484 ( 0.00%)  		if(cpu_can_run(cpu))
4,346,904 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:cpu_can_run (181,121x)
        .           		{
  362,242 ( 0.00%)  			cpu_exec_start(cpu);
1,267,847 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../cpus-common.c:cpu_exec_start (181,121x)
        .           			//CPUClass *cc = CPU_GET_CLASS(cpu);
  543,362 ( 0.00%)  			r = cpu_exec(cpu);
72,061,320,395 (98.80%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/cpu-exec.c:cpu_exec (181,121x)
  362,240 ( 0.00%)  			cpu_exec_end(cpu);
1,267,840 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../cpus-common.c:cpu_exec_end (181,120x)
1,267,840 ( 0.00%)  			switch (r)
        .           			{
        .           				case EXCP_INTERRUPT:
        .                           break;
        .                           case EXCP_HLT:
        .                           break;
        .                           case EXCP_DEBUG:
        .                           cpu_handle_guest_debug(cpu);
        .                           runstate_set(RUN_STATE_DEBUG);
-- line 310 ----------------------------------------
-- line 321 ----------------------------------------
        .                           exit(0);
        .                           break;
        .           			}
        .           		} else if(debug)
        .                   {
        .                       main_loop_wait(true);
        .                   }
        .              }
  181,120 ( 0.00%)      cpu->exit_request = false;
        .               return r;
  905,600 ( 0.00%)  }
        .           
        .           
        .           static void tcg_cpu_init_cflags(CPUState *cpu, bool parallel)
        .           {
        2 ( 0.00%)      uint32_t cflags = cpu->cluster_index << CF_CLUSTER_SHIFT;
        .               cflags |= parallel ? CF_PARALLEL : 0;
        7 ( 0.00%)      cflags |= icount_enabled() ? CF_USE_ICOUNT : 0;
        2 ( 0.00%)      cflags |= CF_SINGLE_STEP;
        .               cpu->tcg_cflags = cflags;
        .           }
        .           
        .           static void xx_start_vcpu_thread(CPUState *cpu)
        3 ( 0.00%)  {
        .               tcg_cpu_init_cflags(cpu, false);
        .               static QemuCond *single_tcg_halt_cond = 0;
        .               static QemuThread *thread_self = 0;
        .               
        2 ( 0.00%)      if(thread_self == 0)
        3 ( 0.00%)          thread_self = g_malloc0(sizeof(QemuThread));
      247 ( 0.00%)  => ???:0x0000000004e3cc20 (1x)
        3 ( 0.00%)      if(single_tcg_halt_cond == 0)
        4 ( 0.00%)          single_tcg_halt_cond = g_malloc0(sizeof(QemuCond));
      255 ( 0.00%)  => ???:0x0000000004e3cc20 (1x)
        2 ( 0.00%)      qemu_thread_get_self(thread_self);
       12 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_thread_get_self (1x)
        2 ( 0.00%)      qemu_cond_init(single_tcg_halt_cond);
       59 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/qemu-thread-posix.c:qemu_cond_init (1x)
        2 ( 0.00%)      cpu->thread = thread_self;
        2 ( 0.00%)      cpu->halt_cond = single_tcg_halt_cond;
        .               //cpu->thread_id = first_cpu->thread_id;
        1 ( 0.00%)      cpu->can_do_io = 1;
        1 ( 0.00%)      cpu->created = true;
        .               
        2 ( 0.00%)  }
        .           
        .           
        .           static void xx_icount_handle_interrupt(CPUState *cpu, int mask)
  492,488 ( 0.00%)  {
  492,488 ( 0.00%)      cpu->interrupt_request |= mask;
  984,976 ( 0.00%)      qatomic_set(&cpu->icount_decr_ptr->u16.high, -1);
  492,488 ( 0.00%)  }
        .           static void xx_kick_vcpu_thread(CPUState *unused)
        1 ( 0.00%)  {
        1 ( 0.00%)  }
        .           static int64_t xx_icount_get(void)
  380,842 ( 0.00%)  {
        .           	return 0;
  761,684 ( 0.00%)  }
        .           
        .           
        .           static int xx_init_machine(MachineState *ms)
        2 ( 0.00%)  {
        2 ( 0.00%)      tcg_allowed = true;
        2 ( 0.00%)      page_init();
       64 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/translate-all.c:page_init (1x)
        2 ( 0.00%)      tb_htable_init();
  108,701 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/tb-maint.c:tb_htable_init (1x)
        4 ( 0.00%)      tcg_init(0, -1, 1);
  588,178 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../tcg/tcg.c:tcg_init (1x)
        .               #if defined(CONFIG_SOFTMMU)
        .               /*
        .                * There's no guest base to take into account, so go ahead and
        .                * initialize the prologue now.
        .                */
        4 ( 0.00%)      tcg_prologue_init(tcg_ctx);
    3,614 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../tcg/tcg.c:tcg_prologue_init (1x)
       14 ( 0.00%)  => ???:0x0000000004e3cc50 (1x)
        .               #endif
        .               return 0;
        3 ( 0.00%)  }
        .           
        .           static void xx_accel_class_init(ObjectClass *oc, void *data)
        2 ( 0.00%)  {
        5 ( 0.00%)      AccelClass *ac = ACCEL_CLASS(oc);
       18 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_class_dynamic_cast_assert (1x)
        2 ( 0.00%)      ac->name = "xx";
        2 ( 0.00%)      ac->init_machine = xx_init_machine;
        2 ( 0.00%)      ac->allowed = &tcg_allowed;
        .               //ac->gdbstub_supported_sstep_flags = tcg_gdbstub_supported_sstep_flags;
        2 ( 0.00%)  }
        .           
        .           static void xx_accel_ops_init(AccelOpsClass *ops)
        1 ( 0.00%)  {
        2 ( 0.00%)      ops->create_vcpu_thread = xx_start_vcpu_thread;
        2 ( 0.00%)      ops->kick_vcpu_thread = xx_kick_vcpu_thread;
        2 ( 0.00%)      ops->handle_interrupt = xx_icount_handle_interrupt;
        2 ( 0.00%)      ops->get_virtual_clock = xx_icount_get;
        1 ( 0.00%)      ops->get_elapsed_ticks = xx_icount_get;
        .           
        2 ( 0.00%)      ops->supports_guest_debug = tcg_supports_guest_debug;
        2 ( 0.00%)      ops->insert_breakpoint = tcg_insert_breakpoint;
        2 ( 0.00%)      ops->remove_breakpoint = tcg_remove_breakpoint;
        2 ( 0.00%)      ops->remove_all_breakpoints = tcg_remove_all_breakpoints;
        1 ( 0.00%)  }
        .           
        .           static void xx_accel_ops_class_init(ObjectClass *oc, void *data)
        2 ( 0.00%)  {
        .               AccelOpsClass *ops = ACCEL_OPS_CLASS(oc);
        2 ( 0.00%)      ops->ops_init = xx_accel_ops_init;
        2 ( 0.00%)  }
        .           
        .           static const TypeInfo xx_accel_type = {
        .               .name = ACCEL_CLASS_NAME("xx"),
        .               .parent = TYPE_ACCEL,
        .               .class_init = xx_accel_class_init,
        .           };
        .           
        .           static const TypeInfo xx_accel_ops_type = {
-- line 429 ----------------------------------------
-- line 430 ----------------------------------------
        .               .name = ACCEL_OPS_NAME("xx"),
        .               .parent = TYPE_ACCEL_OPS,
        .               .class_init = xx_accel_ops_class_init,
        .               .abstract = true,
        .           };
        .           
        .           
        .           static void xx_type_init(void)
        1 ( 0.00%)  {
        2 ( 0.00%)      type_register_static(&xx_accel_type);
    1,244 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_register_static (1x)
        .           }
        .           static void xx_accel_ops_register_types(void)
        1 ( 0.00%)  {
        2 ( 0.00%)      type_register_static(&xx_accel_ops_type);
    1,381 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_register_static (1x)
        .           }
        .           
        .           
        4 ( 0.00%)  type_init(xx_accel_ops_register_types);
      261 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/module.c:register_module_init (1x)
        4 ( 0.00%)  type_init(xx_type_init);
      261 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/module.c:register_module_init (1x)

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/bitops.c
--------------------------------------------------------------------------------
Ir                  

-- line 14 ----------------------------------------
         .           #include "qemu/osdep.h"
         .           #include "qemu/bitops.h"
         .           
         .           /*
         .            * Find the next set bit in a memory region.
         .            */
         .           unsigned long find_next_bit(const unsigned long *addr, unsigned long size,
         .                                       unsigned long offset)
 2,068,167 ( 0.00%)  {
 2,068,167 ( 0.00%)      const unsigned long *p = addr + BIT_WORD(offset);
 1,378,778 ( 0.00%)      unsigned long result = offset & ~(BITS_PER_LONG-1);
         .               unsigned long tmp;
         .           
 1,378,778 ( 0.00%)      if (offset >= size) {
         .                   return size;
         .               }
   689,389 ( 0.00%)      size -= result;
         .               offset %= BITS_PER_LONG;
 1,378,778 ( 0.00%)      if (offset) {
         1 ( 0.00%)          tmp = *(p++);
 1,899,546 ( 0.00%)          tmp &= (~0UL << offset);
 1,266,364 ( 0.00%)          if (size < BITS_PER_LONG) {
         .                       goto found_first;
         .                   }
   160,006 ( 0.00%)          if (tmp) {
         .                       goto found_middle;
         .                   }
         1 ( 0.00%)          size -= BITS_PER_LONG;
         2 ( 0.00%)          result += BITS_PER_LONG;
         .               }
   168,624 ( 0.00%)      while (size >= 4*BITS_PER_LONG) {
         .                   unsigned long d1, d2, d3;
         .                   tmp = *p;
         .                   d1 = *(p+1);
         .                   d2 = *(p+2);
         .                   d3 = *(p+3);
         .                   if (tmp) {
         .                       goto found_middle;
         .                   }
         .                   if (d1 | d2 | d3) {
         .                       break;
         .                   }
         .                   p += 4;
         .                   result += 4*BITS_PER_LONG;
         .                   size -= 4*BITS_PER_LONG;
         .               }
   112,416 ( 0.00%)      while (size >= BITS_PER_LONG) {
         .                   if ((tmp = *(p++))) {
         .                       goto found_middle;
         .                   }
         .                   result += BITS_PER_LONG;
         .                   size -= BITS_PER_LONG;
         .               }
   112,416 ( 0.00%)      if (!size) {
         .                   return result;
         .               }
    56,207 ( 0.00%)      tmp = *p;
         .           
         .           found_first:
 2,437,544 ( 0.00%)      tmp &= (~0UL >> (BITS_PER_LONG - size));
 1,218,772 ( 0.00%)      if (tmp == 0UL) {		/* Are any bits set? */
   112,800 ( 0.00%)          return result + size;	/* Nope. */
         .               }
         .           found_middle:
 1,265,976 ( 0.00%)      return result + ctzl(tmp);
 1,378,778 ( 0.00%)  }
         .           
         .           /*
         .            * This implementation of find_{first,next}_zero_bit was stolen from
         .            * Linus' asm-alpha/bitops.h.
         .            */
         .           unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,
         .                                            unsigned long offset)
 8,305,188 ( 0.01%)  {
24,915,564 ( 0.03%)      const unsigned long *p = addr + BIT_WORD(offset);
16,610,376 ( 0.02%)      unsigned long result = offset & ~(BITS_PER_LONG-1);
         .               unsigned long tmp;
         .           
24,915,564 ( 0.03%)      if (offset >= size) {
         .                   return size;
         .               }
 8,305,188 ( 0.01%)      size -= result;
         .               offset %= BITS_PER_LONG;
16,610,376 ( 0.02%)      if (offset) {
 1,206,299 ( 0.00%)          tmp = *(p++);
41,339,920 ( 0.06%)          tmp |= ~0UL >> (BITS_PER_LONG - offset);
16,535,968 ( 0.02%)          if (size < BITS_PER_LONG) {
         .                       goto found_first;
         .                   }
 2,444,140 ( 0.00%)          if (~tmp) {
         .                       goto found_middle;
         .                   }
 1,206,299 ( 0.00%)          size -= BITS_PER_LONG;
 2,412,598 ( 0.00%)          result += BITS_PER_LONG;
         .               }
 4,974,012 ( 0.01%)      while (size & ~(BITS_PER_LONG-1)) {
         .                   if (~(tmp = *(p++))) {
         .                       goto found_middle;
         .                   }
         .                   result += BITS_PER_LONG;
         .                   size -= BITS_PER_LONG;
         .               }
 2,487,006 ( 0.00%)      if (!size) {
         .                   return result;
         .               }
    74,408 ( 0.00%)      tmp = *p;
         .           
         .           found_first:
28,332,472 ( 0.04%)      tmp |= ~0UL << size;
14,166,236 ( 0.02%)      if (tmp == ~0UL) {	/* Are any bits zero? */
13,868,618 ( 0.02%)          return result + size;	/* Nope. */
         .               }
         .           found_middle:
   493,740 ( 0.00%)      return result + ctzl(~tmp);
 1,370,879 ( 0.00%)  }
         .           
         .           unsigned long find_last_bit(const unsigned long *addr, unsigned long size)
         .           {
         .               unsigned long words;
         .               unsigned long tmp;
         .           
         .               /* Start at final word. */
         .               words = size / BITS_PER_LONG;
-- line 136 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../accel/tcg/tb-hash.h
--------------------------------------------------------------------------------
Ir                     

-- line 40 ----------------------------------------
            .               target_ulong tmp;
            .               tmp = pc ^ (pc >> (TARGET_PAGE_BITS - TB_JMP_PAGE_BITS));
            .               return (tmp >> (TARGET_PAGE_BITS - TB_JMP_PAGE_BITS)) & TB_JMP_PAGE_MASK;
            .           }
            .           
            .           static inline unsigned int tb_jmp_cache_hash_func(target_ulong pc)
            .           {
            .               target_ulong tmp;
1,237,334,050 ( 1.70%)      tmp = pc ^ (pc >> (TARGET_PAGE_BITS - TB_JMP_PAGE_BITS));
  536,583,072 ( 0.74%)      return (((tmp >> (TARGET_PAGE_BITS - TB_JMP_PAGE_BITS)) & TB_JMP_PAGE_MASK)
  357,722,048 ( 0.49%)             | (tmp & TB_JMP_ADDR_MASK));
            .           }
            .           
            .           #else
            .           
            .           /* In user-mode we can get better hashing because we do not have a TLB */
            .           static inline unsigned int tb_jmp_cache_hash_func(target_ulong pc)
            .           {
            .               return (pc ^ (pc >> TB_JMP_CACHE_BITS)) & (TB_JMP_CACHE_SIZE - 1);
-- line 58 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/include/tcg/tcg.h
--------------------------------------------------------------------------------
Ir                   

-- line 323 ----------------------------------------
          .            * @memop: MemOp value
          .            *
          .            * Extract the alignment size from the memop.
          .            */
          .           static inline unsigned get_alignment_bits(MemOp memop)
          .           {
          .               unsigned a = memop & MO_AMASK;
          .           
 28,143,341 ( 0.04%)      if (a == MO_UNALN) {
          .                   /* No alignment required.  */
          .                   a = 0;
      4,464 ( 0.00%)      } else if (a == MO_ALIGN) {
          .                   /* A natural alignment requirement.  */
  5,521,846 ( 0.01%)          a = memop & MO_SIZE;
          .               } else {
          .                   /* A specific alignment requirement.  */
          .                   a = a >> MO_ASHIFT;
          .               }
          .           #if defined(CONFIG_SOFTMMU)
          .               /* The requested alignment cannot overlap the TLB flags.  */
  3,309,228 ( 0.00%)      tcg_debug_assert((TLB_FLAGS_MASK & ((1 << a) - 1)) == 0);
          .           #endif
          .               return a;
          .           }
          .           
          .           typedef tcg_target_ulong TCGArg;
          .           
          .           /* Define type and accessor macros for TCG variables.
          .           
-- line 351 ----------------------------------------
-- line 623 ----------------------------------------
          .               target_ulong gen_insn_data[TCG_MAX_INSNS][TARGET_INSN_START_WORDS];
          .           
          .               /* Exit to translator on overflow. */
          .               sigjmp_buf jmp_trans;
          .           };
          .           
          .           static inline bool temp_readonly(TCGTemp *ts)
          .           {
     65,265 ( 0.00%)      return ts->kind >= TEMP_FIXED;
          .           }
          .           
          .           extern __thread TCGContext *tcg_ctx;
          .           extern const void *tcg_code_gen_epilogue;
          .           extern uintptr_t tcg_splitwx_diff;
          .           extern TCGv_env cpu_env;
          .           
          .           bool in_code_gen_buffer(const void *p);
          .           
          .           #ifdef CONFIG_DEBUG_TCG
          .           const void *tcg_splitwx_to_rx(void *rw);
          .           void *tcg_splitwx_to_rw(const void *rx);
          .           #else
          .           static inline const void *tcg_splitwx_to_rx(void *rw)
          .           {
     55,141 ( 0.00%)      return rw ? rw + tcg_splitwx_diff : NULL;
          .           }
          .           
          .           static inline void *tcg_splitwx_to_rw(const void *rx)
          .           {
815,821,364 ( 1.12%)      return rx ? (void *)rx - tcg_splitwx_diff : NULL;
          .           }
          .           #endif
          .           
          .           static inline size_t temp_idx(TCGTemp *ts)
          .           {
    477,482 ( 0.00%)      ptrdiff_t n = ts - tcg_ctx->temps;
     10,472 ( 0.00%)  => ???:0x0000000004e3cc50 (748x)
         22 ( 0.00%)      tcg_debug_assert(n >= 0 && n < tcg_ctx->nb_temps);
          .               return n;
          .           }
          .           
          .           static inline TCGArg temp_arg(TCGTemp *ts)
          .           {
     14,008 ( 0.00%)      return (uintptr_t)ts;
          .           }
          .           
          .           static inline TCGTemp *arg_temp(TCGArg a)
          .           {
     87,556 ( 0.00%)      return (TCGTemp *)(uintptr_t)a;
          .           }
          .           
          .           /* Using the offset of a temporary, relative to TCGContext, rather than
          .              its index means that we don't use 0.  That leaves offset 0 free for
          .              a NULL representation without having to leave index 0 unused.  */
          .           static inline TCGTemp *tcgv_i32_temp(TCGv_i32 v)
     16,480 ( 0.00%)  {
        425 ( 0.00%)      uintptr_t o = (uintptr_t)v;
    147,451 ( 0.00%)      TCGTemp *t = (void *)tcg_ctx + o;
      5,950 ( 0.00%)  => ???:0x0000000004e3cc50 (425x)
          .               tcg_debug_assert(offsetof(TCGContext, temps[temp_idx(t)]) == o);
          .               return t;
     16,480 ( 0.00%)  }
          .           
          .           static inline TCGTemp *tcgv_i64_temp(TCGv_i64 v)
          .           {
          .               return tcgv_i32_temp((TCGv_i32)v);
          .           }
          .           
          .           static inline TCGTemp *tcgv_ptr_temp(TCGv_ptr v)
          .           {
      2,970 ( 0.00%)      return tcgv_i32_temp((TCGv_i32)v);
        132 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/include/tcg/tcg.h:tcgv_i32_temp (6x)
          .           }
          .           
          .           static inline TCGTemp *tcgv_vec_temp(TCGv_vec v)
          .           {
          .               return tcgv_i32_temp((TCGv_i32)v);
          .           }
          .           
          .           static inline TCGArg tcgv_i32_arg(TCGv_i32 v)
          .           {
     19,978 ( 0.00%)      return temp_arg(tcgv_i32_temp(v));
        770 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/include/tcg/tcg.h:tcgv_i32_temp (35x)
          .           }
          .           
          .           static inline TCGArg tcgv_i64_arg(TCGv_i64 v)
          .           {
          .               return temp_arg(tcgv_i64_temp(v));
          .           }
          .           
          .           static inline TCGArg tcgv_ptr_arg(TCGv_ptr v)
-- line 709 ----------------------------------------
-- line 714 ----------------------------------------
          .           static inline TCGArg tcgv_vec_arg(TCGv_vec v)
          .           {
          .               return temp_arg(tcgv_vec_temp(v));
          .           }
          .           
          .           static inline TCGv_i32 temp_tcgv_i32(TCGTemp *t)
          .           {
          .               (void)temp_idx(t); /* trigger embedded assert */
     28,096 ( 0.00%)      return (TCGv_i32)((void *)t - (void *)tcg_ctx);
          .           }
          .           
          .           static inline TCGv_i64 temp_tcgv_i64(TCGTemp *t)
          .           {
          .               return (TCGv_i64)temp_tcgv_i32(t);
          .           }
          .           
          .           static inline TCGv_ptr temp_tcgv_ptr(TCGTemp *t)
-- line 730 ----------------------------------------
-- line 767 ----------------------------------------
          .               return tcg_get_insn_param(op, arg * 2) |
          .                      ((uint64_t)tcg_get_insn_param(op, arg * 2 + 1) << 32);
          .           #endif
          .           }
          .           
          .           static inline void tcg_set_insn_start_param(TCGOp *op, int arg, target_ulong v)
          .           {
          .           #if TARGET_LONG_BITS <= TCG_TARGET_REG_BITS
        982 ( 0.00%)      tcg_set_insn_param(op, arg, v);
          .           #else
          .               tcg_set_insn_param(op, arg * 2, v);
          .               tcg_set_insn_param(op, arg * 2 + 1, v >> 32);
          .           #endif
          .           }
          .           
          .           /* The last op that was emitted.  */
          .           static inline TCGOp *tcg_last_op(void)
          .           {
     17,652 ( 0.00%)      return QTAILQ_LAST(&tcg_ctx->ops);
     41,188 ( 0.00%)  => ???:0x0000000004e3cc50 (2,942x)
          .           }
          .           
          .           /* Test for whether to terminate the TB for using too many opcodes.  */
          .           static inline bool tcg_op_buf_full(void)
          .           {
          .               /* This is not a hard limit, it merely stops translation when
          .                * we have produced "enough" opcodes.  We want to limit TB size
          .                * such that a RISC host can reasonably use a 16-bit signed
          .                * branch within the TB.  We also need to be mindful of the
          .                * 16-bit unsigned offsets, TranslationBlock.jmp_reset_offset[]
          .                * and TCGContext.gen_insn_end_off[].
          .                */
      6,588 ( 0.00%)      return tcg_ctx->nb_ops >= 4000;
     30,744 ( 0.00%)  => ???:0x0000000004e3cc50 (2,196x)
          .           }
          .           
          .           /* pool based memory allocation */
          .           
          .           /* user-mode: mmap_lock must be held for tcg_malloc_internal. */
          .           void *tcg_malloc_internal(TCGContext *s, int size);
          .           void tcg_pool_reset(TCGContext *s);
          .           TranslationBlock *tcg_tb_alloc(TCGContext *s);
-- line 806 ----------------------------------------
-- line 814 ----------------------------------------
          .           void tcg_tb_remove(TranslationBlock *tb);
          .           TranslationBlock *tcg_tb_lookup(uintptr_t tc_ptr);
          .           void tcg_tb_foreach(GTraverseFunc func, gpointer user_data);
          .           size_t tcg_nb_tbs(void);
          .           
          .           /* user-mode: Called with mmap_lock held.  */
          .           static inline void *tcg_malloc(int size)
          .           {
     25,957 ( 0.00%)      TCGContext *s = tcg_ctx;
     10,444 ( 0.00%)  => ???:0x0000000004e3cc50 (746x)
          .               uint8_t *ptr, *ptr_end;
          .           
          .               /* ??? This is a weak placeholder for minimum malloc alignment.  */
      2,984 ( 0.00%)      size = QEMU_ALIGN_UP(size, 8);
          .           
     46,794 ( 0.00%)      ptr = s->pool_cur;
     47,540 ( 0.00%)      ptr_end = ptr + size;
     93,588 ( 0.00%)      if (unlikely(ptr_end > s->pool_end)) {
      2,992 ( 0.00%)          return tcg_malloc_internal(tcg_ctx, size);
     46,510 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../tcg/tcg.c:tcg_malloc_internal (748x)
          .               } else {
     46,046 ( 0.00%)          s->pool_cur = ptr_end;
          .                   return ptr;
          .               }
          .           }
          .           
          .           void tcg_init(size_t tb_size, int splitwx, unsigned max_cpus);
          .           void tcg_register_thread(void);
          .           void tcg_prologue_init(TCGContext *s);
          .           void tcg_func_start(TCGContext *s);
-- line 841 ----------------------------------------
-- line 847 ----------------------------------------
          .           TCGTemp *tcg_global_mem_new_internal(TCGType, TCGv_ptr,
          .                                                intptr_t, const char *);
          .           TCGTemp *tcg_temp_new_internal(TCGType, bool);
          .           void tcg_temp_free_internal(TCGTemp *);
          .           TCGv_vec tcg_temp_new_vec(TCGType type);
          .           TCGv_vec tcg_temp_new_vec_matching(TCGv_vec match);
          .           
          .           static inline void tcg_temp_free_i32(TCGv_i32 arg)
      1,824 ( 0.00%)  {
     11,402 ( 0.00%)      tcg_temp_free_internal(tcgv_i32_temp(arg));
        200 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../tcg/tcg.c:tcg_temp_free_internal (4x)
        912 ( 0.00%)  }
          .           
          .           static inline void tcg_temp_free_i64(TCGv_i64 arg)
          .           {
          .               tcg_temp_free_internal(tcgv_i64_temp(arg));
          .           }
          .           
          .           static inline void tcg_temp_free_ptr(TCGv_ptr arg)
          .           {
-- line 865 ----------------------------------------
-- line 869 ----------------------------------------
          .           static inline void tcg_temp_free_vec(TCGv_vec arg)
          .           {
          .               tcg_temp_free_internal(tcgv_vec_temp(arg));
          .           }
          .           
          .           static inline TCGv_i32 tcg_global_mem_new_i32(TCGv_ptr reg, intptr_t offset,
          .                                                         const char *name)
          .           {
        100 ( 0.00%)      TCGTemp *t = tcg_global_mem_new_internal(TCG_TYPE_I32, reg, offset, name);
      1,420 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../tcg/tcg.c:tcg_global_mem_new_internal (20x)
          .               return temp_tcgv_i32(t);
          .           }
          .           
          .           static inline TCGv_i32 tcg_temp_new_i32(void)
        183 ( 0.00%)  {
     29,407 ( 0.00%)      TCGTemp *t = tcg_temp_new_internal(TCG_TYPE_I32, false);
     85,160 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../tcg/tcg.c:tcg_temp_new_internal (748x)
          .               return temp_tcgv_i32(t);
        366 ( 0.00%)  }
          .           
          .           static inline TCGv_i32 tcg_temp_local_new_i32(void)
          .           {
        766 ( 0.00%)      TCGTemp *t = tcg_temp_new_internal(TCG_TYPE_I32, true);
        118 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../tcg/tcg.c:tcg_temp_new_internal (2x)
          .               return temp_tcgv_i32(t);
          .           }
          .           
          .           static inline TCGv_i64 tcg_global_mem_new_i64(TCGv_ptr reg, intptr_t offset,
          .                                                         const char *name)
          .           {
         10 ( 0.00%)      TCGTemp *t = tcg_global_mem_new_internal(TCG_TYPE_I64, reg, offset, name);
        142 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../tcg/tcg.c:tcg_global_mem_new_internal (2x)
          .               return temp_tcgv_i64(t);
          .           }
          .           
          .           static inline TCGv_i64 tcg_temp_new_i64(void)
        347 ( 0.00%)  {
     14,822 ( 0.00%)      TCGTemp *t = tcg_temp_new_internal(TCG_TYPE_I64, false);
    170,088 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../tcg/tcg.c:tcg_temp_new_internal (1,492x)
          .               return temp_tcgv_i64(t);
        694 ( 0.00%)  }
          .           
          .           static inline TCGv_i64 tcg_temp_local_new_i64(void)
          .           {
          .               TCGTemp *t = tcg_temp_new_internal(TCG_TYPE_I64, true);
          .               return temp_tcgv_i64(t);
          .           }
          .           
          .           static inline TCGv_ptr tcg_global_mem_new_ptr(TCGv_ptr reg, intptr_t offset,
-- line 912 ----------------------------------------
-- line 1036 ----------------------------------------
          .           /*
          .            * Locate or create a read-only temporary that is a constant.
          .            * This kind of temporary need not be freed, but for convenience
          .            * will be silently ignored by tcg_temp_free_*.
          .            */
          .           TCGTemp *tcg_constant_internal(TCGType type, int64_t val);
          .           
          .           static inline TCGv_i32 tcg_constant_i32(int32_t val)
      2,421 ( 0.00%)  {
     25,046 ( 0.00%)      return temp_tcgv_i32(tcg_constant_internal(TCG_TYPE_I32, val));
     11,641 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../tcg/tcg.c:tcg_constant_internal (34x)
      4,842 ( 0.00%)  }
          .           
          .           static inline TCGv_i64 tcg_constant_i64(int64_t val)
          .           {
      4,485 ( 0.00%)      return temp_tcgv_i64(tcg_constant_internal(TCG_TYPE_I64, val));
    378,335 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../tcg/tcg.c:tcg_constant_internal (1,495x)
          .           }
          .           
          .           TCGv_vec tcg_constant_vec(TCGType type, unsigned vece, int64_t val);
          .           TCGv_vec tcg_constant_vec_matching(TCGv_vec match, unsigned vece, int64_t val);
          .           
          .           #if UINTPTR_MAX == UINT32_MAX
          .           # define tcg_const_ptr(x)        ((TCGv_ptr)tcg_const_i32((intptr_t)(x)))
          .           # define tcg_const_local_ptr(x)  ((TCGv_ptr)tcg_const_local_i32((intptr_t)(x)))
-- line 1058 ----------------------------------------
-- line 1082 ----------------------------------------
          .            * @i: value
          .            *
          .            * The opposite of label_arg.  Retrieve a label from the
          .            * encoding of the TCG opcode stream.
          .            */
          .           
          .           static inline TCGLabel *arg_label(TCGArg i)
          .           {
      3,777 ( 0.00%)      return (TCGLabel *)(uintptr_t)i;
          .           }
          .           
          .           /**
          .            * tcg_ptr_byte_diff
          .            * @a, @b: addresses to be differenced
          .            *
          .            * There are many places within the TCG backends where we need a byte
          .            * difference between two pointers.  While this can be accomplished
-- line 1098 ----------------------------------------
-- line 1100 ----------------------------------------
          .            * concerned with the signedness of the result.
          .            *
          .            * This version relies on GCC's void pointer arithmetic to get the
          .            * correct result.
          .            */
          .           
          .           static inline ptrdiff_t tcg_ptr_byte_diff(const void *a, const void *b)
          .           {
     57,624 ( 0.00%)      return a - b;
          .           }
          .           
          .           /**
          .            * tcg_pcrel_diff
          .            * @s: the tcg context
          .            * @target: address of the target
          .            *
          .            * Produce a pc-relative difference, from the current code_ptr
          .            * to the destination address.
          .            */
          .           
          .           static inline ptrdiff_t tcg_pcrel_diff(TCGContext *s, const void *target)
          .           {
      5,098 ( 0.00%)      return tcg_ptr_byte_diff(target, tcg_splitwx_to_rx(s->code_ptr));
          .           }
          .           
          .           /**
          .            * tcg_tbrel_diff
          .            * @s: the tcg context
          .            * @target: address of the target
          .            *
          .            * Produce a difference, from the beginning of the current TB code
-- line 1130 ----------------------------------------
-- line 1140 ----------------------------------------
          .            * @s: the tcg context
          .            *
          .            * Compute the current code size within the translation block.
          .            * This is used to fill in qemu's data structures for goto_tb.
          .            */
          .           
          .           static inline size_t tcg_current_code_size(TCGContext *s)
          .           {
      2,942 ( 0.00%)      return tcg_ptr_byte_diff(s->code_ptr, s->code_buf);
          .           }
          .           
          .           /**
          .            * tcg_qemu_tb_exec:
          .            * @env: pointer to CPUArchState for the CPU
          .            * @tb_ptr: address of generated code for the TB to execute
          .            *
          .            * Start executing code from a given translation block.
-- line 1156 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c
--------------------------------------------------------------------------------
Ir                  

-- line 58 ----------------------------------------
         .            */
         .           struct AddrRange {
         .               Int128 start;
         .               Int128 size;
         .           };
         .           
         .           static AddrRange addrrange_make(Int128 start, Int128 size)
         .           {
 3,018,729 ( 0.00%)      return (AddrRange) { start, size };
         .           }
         .           
         .           static bool addrrange_equal(AddrRange r1, AddrRange r2)
         .           {
       784 ( 0.00%)      return int128_eq(r1.start, r2.start) && int128_eq(r1.size, r2.size);
         .           }
         .           
         .           static Int128 addrrange_end(AddrRange r)
         .           {
         .               return int128_add(r.start, r.size);
         .           }
         .           
         .           static AddrRange addrrange_shift(AddrRange range, Int128 delta)
-- line 79 ----------------------------------------
-- line 80 ----------------------------------------
         .           {
         .               int128_addto(&range.start, delta);
         .               return range;
         .           }
         .           
         .           static bool addrrange_contains(AddrRange range, Int128 addr)
         .           {
         .               return int128_ge(addr, range.start)
     1,260 ( 0.00%)          && int128_lt(addr, addrrange_end(range));
         .           }
         .           
         .           static bool addrrange_intersects(AddrRange r1, AddrRange r2)
         .           {
         .               return addrrange_contains(r1, r2.start)
         .                   || addrrange_contains(r2, r1.start);
         .           }
         .           
-- line 96 ----------------------------------------
-- line 227 ----------------------------------------
         .           };
         .           
         .           #define FOR_EACH_FLAT_RANGE(var, view)          \
         .               for (var = (view)->ranges; var < (view)->ranges + (view)->nr; ++var)
         .           
         .           static inline MemoryRegionSection
         .           section_from_flat_range(FlatRange *fr, FlatView *fv)
         .           {
     1,010 ( 0.00%)      return (MemoryRegionSection) {
       167 ( 0.00%)          .mr = fr->mr,
         .                   .fv = fv,
       167 ( 0.00%)          .offset_within_region = fr->offset_in_region,
       167 ( 0.00%)          .size = fr->addr.size,
       167 ( 0.00%)          .offset_within_address_space = int128_get64(fr->addr.start),
       167 ( 0.00%)          .readonly = fr->readonly,
         8 ( 0.00%)          .nonvolatile = fr->nonvolatile,
         .               };
         .           }
         .           
         .           static bool flatrange_equal(FlatRange *a, FlatRange *b)
       124 ( 0.00%)  {
         .               return a->mr == b->mr
         .                   && addrrange_equal(a->addr, b->addr)
       156 ( 0.00%)          && a->offset_in_region == b->offset_in_region
         .                   && a->romd_mode == b->romd_mode
         .                   && a->readonly == b->readonly
       508 ( 0.00%)          && a->nonvolatile == b->nonvolatile;
        10 ( 0.00%)  }
         .           
         .           static FlatView *flatview_new(MemoryRegion *mr_root)
         .           {
         .               FlatView *view;
         .           
       108 ( 0.00%)      view = g_new0(FlatView, 1);
     9,509 ( 0.00%)  => ???:0x0000000004e3cc20 (36x)
        36 ( 0.00%)      view->ref = 1;
        36 ( 0.00%)      view->root = mr_root;
        72 ( 0.00%)      memory_region_ref(mr_root);
       276 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_ref (36x)
         .               trace_flatview_new(view, mr_root);
         .           
         .               return view;
         .           }
         .           
         .           /* Insert a range into a given position.  Caller is responsible for maintaining
         .            * sorting order.
         .            */
         .           static void flatview_insert(FlatView *view, unsigned pos, FlatRange *range)
       992 ( 0.00%)  {
       372 ( 0.00%)      if (view->nr == view->nr_allocated) {
       185 ( 0.00%)          view->nr_allocated = MAX(2 * view->nr, 10);
       309 ( 0.00%)          view->ranges = g_realloc(view->ranges,
     9,372 ( 0.00%)  => ???:0x0000000004e3cb60 (37x)
        37 ( 0.00%)                                      view->nr_allocated * sizeof(*view->ranges));
         .               }
       620 ( 0.00%)      memmove(view->ranges + pos + 1, view->ranges + pos,
       161 ( 0.00%)              (view->nr - pos) * sizeof(FlatRange));
     1,116 ( 0.00%)      view->ranges[pos] = *range;
       248 ( 0.00%)      memory_region_ref(range->mr);
       949 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_ref (124x)
       124 ( 0.00%)      ++view->nr;
       744 ( 0.00%)  }
         .           
         .           static void flatview_destroy(FlatView *view)
       160 ( 0.00%)  {
         .               int i;
         .           
         .               trace_flatview_destroy(view, view->root);
        96 ( 0.00%)      if (view->dispatch) {
        32 ( 0.00%)          address_space_dispatch_free(view->dispatch);
    22,535 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:address_space_dispatch_free (32x)
         .               }
       466 ( 0.00%)      for (i = 0; i < view->nr; i++) {
       510 ( 0.00%)          memory_region_unref(view->ranges[i].mr);
       826 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_unref (102x)
         .               }
        64 ( 0.00%)      g_free(view->ranges);
     4,577 ( 0.00%)  => ???:0x0000000004e3a950 (32x)
        64 ( 0.00%)      memory_region_unref(view->root);
       280 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_unref (32x)
        64 ( 0.00%)      g_free(view);
     3,756 ( 0.00%)  => ???:0x0000000004e3a950 (32x)
        96 ( 0.00%)  }
         .           
         .           static bool flatview_ref(FlatView *view)
         .           {
     1,083 ( 0.00%)      return qatomic_fetch_inc_nonzero(&view->ref) > 0;
         .           }
         .           
         .           void flatview_unref(FlatView *view)
       155 ( 0.00%)  {
       433 ( 0.00%)      if (qatomic_fetch_dec(&view->ref) == 1) {
         .                   trace_flatview_destroy_rcu(view, view->root);
        64 ( 0.00%)          assert(view->root);
        64 ( 0.00%)          call_rcu(view, flatview_destroy, rcu);
       608 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/rcu.c:call_rcu1 (32x)
         .               }
         .           }
         .           
         .           static bool can_merge(FlatRange *r1, FlatRange *r2)
         .           {
       178 ( 0.00%)      return int128_eq(addrrange_end(r1->addr), r2->addr.start)
        45 ( 0.00%)          && r1->mr == r2->mr
         .                   && int128_eq(int128_add(int128_make64(r1->offset_in_region),
         .                                           r1->addr.size),
         .                                int128_make64(r2->offset_in_region))
         .                   && r1->dirty_log_mask == r2->dirty_log_mask
         .                   && r1->romd_mode == r2->romd_mode
         .                   && r1->readonly == r2->readonly
       712 ( 0.00%)          && r1->nonvolatile == r2->nonvolatile;
         .           }
         .           
         .           /* Attempt to simplify a view by merging adjacent ranges */
         .           static void flatview_simplify(FlatView *view)
         .           {
         .               unsigned i, j, k;
         .           
         .               i = 0;
       427 ( 0.00%)      while (i < view->nr) {
       372 ( 0.00%)          j = i + 1;
         .                   while (j < view->nr
       887 ( 0.00%)                 && can_merge(&view->ranges[j-1], &view->ranges[j])) {
       356 ( 0.00%)              int128_addto(&view->ranges[i].addr.size, view->ranges[j].addr.size);
         .                       ++j;
         .                   }
         .                   ++i;
       178 ( 0.00%)          for (k = i; k < j; k++) {
         .                       memory_region_unref(view->ranges[k].mr);
         .                   }
       992 ( 0.00%)          memmove(&view->ranges[i], &view->ranges[j],
       302 ( 0.00%)                  (view->nr - j) * sizeof(view->ranges[j]));
       496 ( 0.00%)          view->nr -= j - i;
         .               }
         .           }
         .           
         .           static bool memory_region_big_endian(MemoryRegion *mr)
         .           {
         .           #if TARGET_BIG_ENDIAN
         .               return mr->ops->endianness != DEVICE_LITTLE_ENDIAN;
         .           #else
 3,798,075 ( 0.01%)      return mr->ops->endianness == DEVICE_BIG_ENDIAN;
         .           #endif
         .           }
         .           
 3,798,075 ( 0.01%)  static void adjust_endianness(MemoryRegion *mr, uint64_t *data, MemOp op)
         .           {
15,192,300 ( 0.02%)      if ((op & MO_BSWAP) != devend_memop(mr->ops->endianness)) {
         .                   switch (op & MO_SIZE) {
         .                   case MO_8:
         .                       break;
         .                   case MO_16:
         .                       *data = bswap16(*data);
 3,798,075 ( 0.01%)              break;
         .                   case MO_32:
         .                       *data = bswap32(*data);
         .                       break;
         .                   case MO_64:
         .                       *data = bswap64(*data);
         .                       break;
         .                   default:
         .                       g_assert_not_reached();
-- line 377 ----------------------------------------
-- line 379 ----------------------------------------
         .               }
         .           }
         .           
         .           static inline void memory_region_shift_read_access(uint64_t *value,
         .                                                              signed shift,
         .                                                              uint64_t mask,
         .                                                              uint64_t tmp)
         .           {
 4,577,596 ( 0.01%)      if (shift >= 0) {
12,156,166 ( 0.02%)          *value |= (tmp & mask) << shift;
         .               } else {
         .                   *value |= (tmp & mask) >> -shift;
         .               }
         .           }
         .           
         .           static inline uint64_t memory_region_shift_write_access(uint64_t *value,
         .                                                                   signed shift,
         .                                                                   uint64_t mask)
         .           {
         .               uint64_t tmp;
         .           
 3,018,554 ( 0.00%)      if (shift >= 0) {
 4,527,831 ( 0.01%)          tmp = (*value >> shift) & mask;
         .               } else {
         .                   tmp = (*value << -shift) & mask;
         .               }
         .           
         .               return tmp;
         .           }
         .           
         .           static hwaddr memory_region_to_absolute_addr(MemoryRegion *mr, hwaddr offset)
-- line 409 ----------------------------------------
-- line 430 ----------------------------------------
         .           
         .           static MemTxResult  memory_region_read_accessor(MemoryRegion *mr,
         .                                                           hwaddr addr,
         .                                                           uint64_t *value,
         .                                                           unsigned size,
         .                                                           signed shift,
         .                                                           uint64_t mask,
         .                                                           MemTxAttrs attrs)
17,342,842 ( 0.02%)  {
         .               uint64_t tmp;
         .           
 6,306,488 ( 0.01%)      tmp = mr->ops->read(mr->opaque, addr, size);
363,946,002 ( 0.50%)  => ???:mmio_read (1,576,622x)
 3,153,244 ( 0.00%)      if (mr->subpage) {
         .                   trace_memory_region_subpage_read(get_cpu_index(), mr, addr, tmp, size);
 6,306,488 ( 0.01%)      } else if (trace_event_get_state_backends(TRACE_MEMORY_REGION_OPS_READ)) {
         .                   hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);
         .                   trace_memory_region_ops_read(get_cpu_index(), mr, abs_addr, tmp, size,
         .                                                memory_region_name(mr));
         .               }
         .               memory_region_shift_read_access(value, shift, mask, tmp);
         .               return MEMTX_OK;
12,612,976 ( 0.02%)  }
         .           
         .           static MemTxResult memory_region_read_with_attrs_accessor(MemoryRegion *mr,
         .                                                                     hwaddr addr,
         .                                                                     uint64_t *value,
         .                                                                     unsigned size,
         .                                                                     signed shift,
         .                                                                     uint64_t mask,
         .                                                                     MemTxAttrs attrs)
 9,970,464 ( 0.01%)  {
   712,176 ( 0.00%)      uint64_t tmp = 0;
         .               MemTxResult r;
         .           
 4,273,056 ( 0.01%)      r = mr->ops->read_with_attrs(mr->opaque, addr, &tmp, size, attrs);
176,661,230 ( 0.24%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:subpage_read (218,324x)
 5,220,828 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:nvic_sysreg_read (75,806x)
 1,424,352 ( 0.00%)      if (mr->subpage) {
         .                   trace_memory_region_subpage_read(get_cpu_index(), mr, addr, tmp, size);
 1,975,408 ( 0.00%)      } else if (trace_event_get_state_backends(TRACE_MEMORY_REGION_OPS_READ)) {
         .                   hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);
         .                   trace_memory_region_ops_read(get_cpu_index(), mr, abs_addr, tmp, size,
         .                                                memory_region_name(mr));
         .               }
         .               memory_region_shift_read_access(value, shift, mask, tmp);
         .               return r;
 7,833,936 ( 0.01%)  }
         .           
         .           static MemTxResult memory_region_write_accessor(MemoryRegion *mr,
         .                                                           hwaddr addr,
         .                                                           uint64_t *value,
         .                                                           unsigned size,
         .                                                           signed shift,
         .                                                           uint64_t mask,
         .                                                           MemTxAttrs attrs)
10,389,969 ( 0.01%)  {
         .               uint64_t tmp = memory_region_shift_write_access(value, shift, mask);
         .           
 2,308,882 ( 0.00%)      if (mr->subpage) {
         .                   trace_memory_region_subpage_write(get_cpu_index(), mr, addr, tmp, size);
 4,617,764 ( 0.01%)      } else if (trace_event_get_state_backends(TRACE_MEMORY_REGION_OPS_WRITE)) {
         .                   hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);
         .                   trace_memory_region_ops_write(get_cpu_index(), mr, abs_addr, tmp, size,
         .                                                 memory_region_name(mr));
         .               }
 4,617,764 ( 0.01%)      mr->ops->write(mr->opaque, addr, tmp, size);
 2,308,882 ( 0.00%)  => ???:mmio_write (1,154,441x)
         .               return MEMTX_OK;
 5,772,205 ( 0.01%)  }
         .           
         .           static MemTxResult memory_region_write_with_attrs_accessor(MemoryRegion *mr,
         .                                                                      hwaddr addr,
         .                                                                      uint64_t *value,
         .                                                                      unsigned size,
         .                                                                      signed shift,
         .                                                                      uint64_t mask,
         .                                                                      MemTxAttrs attrs)
 3,548,360 ( 0.00%)  {
         .               uint64_t tmp = memory_region_shift_write_access(value, shift, mask);
         .           
   709,672 ( 0.00%)      if (mr->subpage) {
         .                   trace_memory_region_subpage_write(get_cpu_index(), mr, addr, tmp, size);
 1,047,304 ( 0.00%)      } else if (trace_event_get_state_backends(TRACE_MEMORY_REGION_OPS_WRITE)) {
         .                   hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);
         .                   trace_memory_region_ops_write(get_cpu_index(), mr, abs_addr, tmp, size,
         .                                                 memory_region_name(mr));
         .               }
 1,774,180 ( 0.00%)      return mr->ops->write_with_attrs(mr->opaque, addr, tmp, size, attrs);
82,742,874 ( 0.11%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:subpage_write (93,010x)
68,640,238 ( 0.09%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/intc/armv7m_nvic.c:nvic_sysreg_write (94,408x)
 1,064,508 ( 0.00%)  }
         .           
         .           static MemTxResult access_with_adjusted_size(hwaddr addr,
         .                                                 uint64_t *value,
         .                                                 unsigned size,
         .                                                 unsigned access_size_min,
         .                                                 unsigned access_size_max,
         .                                                 MemTxResult (*access_fn)
         .                                                             (MemoryRegion *mr,
-- line 523 ----------------------------------------
-- line 524 ----------------------------------------
         .                                                              hwaddr addr,
         .                                                              uint64_t *value,
         .                                                              unsigned size,
         .                                                              signed shift,
         .                                                              uint64_t mask,
         .                                                              MemTxAttrs attrs),
         .                                                 MemoryRegion *mr,
         .                                                 MemTxAttrs attrs)
56,971,125 ( 0.08%)  {
         .               uint64_t access_mask;
         .               unsigned access_size;
         .               unsigned i;
 3,798,075 ( 0.01%)      MemTxResult r = MEMTX_OK;
         .           
         .               if (!access_size_min) {
         .                   access_size_min = 1;
         .               }
         .               if (!access_size_max) {
11,394,225 ( 0.02%)          access_size_max = 4;
         .               }
         .           
         .               /* FIXME: support unaligned access? */
18,990,375 ( 0.03%)      access_size = MAX(MIN(size, access_size_max), access_size_min);
18,990,375 ( 0.03%)      access_mask = MAKE_64BIT_MASK(0, access_size * 8);
26,586,525 ( 0.04%)      if (memory_region_big_endian(mr)) {
         .                   for (i = 0; i < size; i += access_size) {
         .                       r |= access_fn(mr, addr + i, value, access_size,
         .                                   (size - access_size - i) * 8, access_mask, attrs);
         .                   }
         .               } else {
18,990,375 ( 0.03%)          for (i = 0; i < size; i += access_size) {
49,374,975 ( 0.07%)              r |= access_fn(mr, addr + i, value, access_size, i * 8,
420,704,394 ( 0.58%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_read_accessor (1,576,622x)
194,538,742 ( 0.27%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_read_with_attrs_accessor (294,130x)
156,446,194 ( 0.21%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_write_with_attrs_accessor (187,418x)
35,787,671 ( 0.05%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_write_accessor (1,154,441x)
         .                                   access_mask, attrs);
         .                   }
         .               }
         .               return r;
34,182,675 ( 0.05%)  }
         .           
         .           static AddressSpace *memory_region_to_address_space(MemoryRegion *mr)
         .           {
         .               AddressSpace *as;
         .           
         .               while (mr->container) {
         .                   mr = mr->container;
         .               }
-- line 568 ----------------------------------------
-- line 578 ----------------------------------------
         .            * ranges in @mr.
         .            */
         .           static void render_memory_region(FlatView *view,
         .                                            MemoryRegion *mr,
         .                                            Int128 base,
         .                                            AddrRange clip,
         .                                            bool readonly,
         .                                            bool nonvolatile)
     1,820 ( 0.00%)  {
         .               MemoryRegion *subregion;
         .               unsigned i;
         .               hwaddr offset_in_region;
         .               Int128 remain;
         .               Int128 now;
         .               FlatRange fr;
         .               AddrRange tmp;
         .           
       700 ( 0.00%)      if (!mr->enabled) {
         .                   return;
         .               }
         .           
         .               int128_addto(&base, int128_make64(mr->addr));
       980 ( 0.00%)      readonly |= mr->readonly;
       840 ( 0.00%)      nonvolatile |= mr->nonvolatile;
         .           
       280 ( 0.00%)      tmp = addrrange_make(base, mr->size);
         .           
         .               if (!addrrange_intersects(tmp, clip)) {
         .                   return;
         .               }
         .           
         .               clip = addrrange_intersection(tmp, clip);
         .           
       420 ( 0.00%)      if (mr->alias) {
         .                   int128_subfrom(&base, int128_make64(mr->alias->addr));
         .                   int128_subfrom(&base, int128_make64(mr->alias_offset));
         .                   render_memory_region(view, mr->alias, base, clip,
         .                                        readonly, nonvolatile);
         .                   return;
         .               }
         .           
         .               /* Render subregions in priority order. */
     1,126 ( 0.00%)      QTAILQ_FOREACH(subregion, &mr->subregions, subregions_link) {
     1,785 ( 0.00%)          render_memory_region(view, subregion, base, clip,
    37,252 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:render_memory_region'2 (81x)
         .                                        readonly, nonvolatile);
         .               }
         .           
       280 ( 0.00%)      if (!mr->terminates) {
         .                   return;
         .               }
         .           
         .               offset_in_region = int128_get64(int128_sub(clip.start, base));
         .               base = clip.start;
         .               remain = clip.size;
         .           
       121 ( 0.00%)      fr.mr = mr;
       605 ( 0.00%)      fr.dirty_log_mask = memory_region_get_dirty_log_mask(mr);
       450 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_get_dirty_log_mask (19x)
       242 ( 0.00%)      fr.romd_mode = mr->romd_mode;
       242 ( 0.00%)      fr.readonly = readonly;
       242 ( 0.00%)      fr.nonvolatile = nonvolatile;
         .           
         .               /* Render the region itself into any gaps left by the current view. */
     1,616 ( 0.00%)      for (i = 0; i < view->nr && int128_nz(remain); ++i) {
       792 ( 0.00%)          if (int128_ge(base, addrrange_end(view->ranges[i].addr))) {
         .                       continue;
         .                   }
       528 ( 0.00%)          if (int128_lt(base, view->ranges[i].addr.start)) {
         .                       now = int128_min(remain,
         .                                        int128_sub(view->ranges[i].addr.start, base));
        86 ( 0.00%)              fr.offset_in_region = offset_in_region;
       344 ( 0.00%)              fr.addr = addrrange_make(base, now);
       774 ( 0.00%)              flatview_insert(view, i, &fr);
     7,785 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:flatview_insert (86x)
        86 ( 0.00%)              ++i;
         .                       int128_addto(&base, now);
        86 ( 0.00%)              offset_in_region += int128_get64(now);
         .                       int128_subfrom(&remain, now);
         .                   }
         .                   now = int128_sub(int128_min(int128_add(base, remain),
       430 ( 0.00%)                                      addrrange_end(view->ranges[i].addr)),
         .                                    base);
         .                   int128_addto(&base, now);
        88 ( 0.00%)          offset_in_region += int128_get64(now);
         .                   int128_subfrom(&remain, now);
         .               }
       156 ( 0.00%)      if (int128_nz(remain)) {
        38 ( 0.00%)          fr.offset_in_region = offset_in_region;
       152 ( 0.00%)          fr.addr = addrrange_make(base, remain);
       190 ( 0.00%)          flatview_insert(view, i, &fr);
     6,568 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:flatview_insert (19x)
         .               }
     1,540 ( 0.00%)  }
         .           
         .           void flatview_for_each_range(FlatView *fv, flatview_cb cb , void *opaque)
        12 ( 0.00%)  {
         .               FlatRange *fr;
         .           
         6 ( 0.00%)      assert(fv);
         4 ( 0.00%)      assert(cb);
         .           
       142 ( 0.00%)      FOR_EACH_FLAT_RANGE(fr, fv) {
       315 ( 0.00%)          if (cb(fr->addr.start, fr->addr.size, fr->mr,
       196 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/loader.c:find_rom_cb (21x)
         .                          fr->offset_in_region, opaque)) {
         .                       break;
         .                   }
         .               }
        12 ( 0.00%)  }
         .           
         .           static MemoryRegion *memory_region_get_flatview_root(MemoryRegion *mr)
        76 ( 0.00%)  {
       170 ( 0.00%)      while (mr->enabled) {
       246 ( 0.00%)          if (mr->alias) {
         .                       if (!mr->alias_offset && int128_ge(mr->size, mr->alias->size)) {
         .                           /* The alias is included in its entirety.  Use it as
         .                            * the "real" root, so that we can share more FlatViews.
         .                            */
         .                           mr = mr->alias;
         .                           continue;
         .                       }
       164 ( 0.00%)          } else if (!mr->terminates) {
        80 ( 0.00%)              unsigned int found = 0;
         .                       MemoryRegion *child, *next = NULL;
       252 ( 0.00%)              QTAILQ_FOREACH(child, &mr->subregions, subregions_link) {
       148 ( 0.00%)                  if (child->enabled) {
       148 ( 0.00%)                      if (++found > 1) {
         .                                   next = NULL;
         .                                   break;
         .                               }
       150 ( 0.00%)                      if (!child->addr && int128_ge(mr->size, child->size)) {
         .                                   /* A child is included in its entirety.  If it's the only
         .                                    * enabled one, use it in the hope of finding an alias down the
         .                                    * way. This will also let us share FlatViews.
         .                                    */
         .                                   next = child;
         .                               }
         .                           }
         .                       }
        12 ( 0.00%)              if (found == 0) {
         4 ( 0.00%)                  return NULL;
         .                       }
        12 ( 0.00%)              if (next) {
         .                           mr = next;
         .                           continue;
         .                       }
         .                   }
         .           
         .                   return mr;
         .               }
         .           
         .               return NULL;
        76 ( 0.00%)  }
         .           
         .           /* Render a memory topology into a list of disjoint absolute ranges. */
         .           static FlatView *generate_memory_topology(MemoryRegion *mr)
       432 ( 0.00%)  {
         .               int i;
         .               FlatView *view;
         .           
         .               view = flatview_new(mr);
         .           
        72 ( 0.00%)      if (mr) {
       385 ( 0.00%)          render_memory_region(view, mr, int128_zero(),
    50,209 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:render_memory_region (35x)
         .                                        addrrange_make(int128_zero(), int128_2_64()),
         .                                        false, false);
         .               }
         .               flatview_simplify(view);
         .           
       144 ( 0.00%)      view->dispatch = address_space_dispatch_new(view);
    22,656 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:address_space_dispatch_new (36x)
       551 ( 0.00%)      for (i = 0; i < view->nr; i++) {
         .                   MemoryRegionSection mrs =
       372 ( 0.00%)              section_from_flat_range(&view->ranges[i], view);
       408 ( 0.00%)          flatview_add_to_dispatch(view, &mrs);
   792,529 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:flatview_add_to_dispatch (124x)
         .               }
        71 ( 0.00%)      address_space_dispatch_compact(view->dispatch);
 1,317,221 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:address_space_dispatch_compact (36x)
       144 ( 0.00%)      g_hash_table_replace(flat_views, mr, view);
     5,363 ( 0.00%)  => ???:0x0000000004e3c2a0 (36x)
         .           
         .               return view;
       432 ( 0.00%)  }
         .           
         .           static void address_space_add_del_ioeventfds(AddressSpace *as,
         .                                                        MemoryRegionIoeventfd *fds_new,
         .                                                        unsigned fds_new_nb,
         .                                                        MemoryRegionIoeventfd *fds_old,
         .                                                        unsigned fds_old_nb)
         .           {
         .               unsigned iold, inew;
-- line 761 ----------------------------------------
-- line 762 ----------------------------------------
         .               MemoryRegionIoeventfd *fd;
         .               MemoryRegionSection section;
         .           
         .               /* Generate a symmetric difference of the old and new fd sets, adding
         .                * and deleting as necessary.
         .                */
         .           
         .               iold = inew = 0;
       114 ( 0.00%)      while (iold < fds_old_nb || inew < fds_new_nb) {
         .                   if (iold < fds_old_nb
         .                       && (inew == fds_new_nb
         .                           || memory_region_ioeventfd_before(&fds_old[iold],
         .                                                             &fds_new[inew]))) {
         .                       fd = &fds_old[iold];
         .                       section = (MemoryRegionSection) {
         .                           .fv = address_space_to_flatview(as),
         .                           .offset_within_address_space = int128_get64(fd->addr.start),
-- line 778 ----------------------------------------
-- line 797 ----------------------------------------
         .                   } else {
         .                       ++iold;
         .                       ++inew;
         .                   }
         .               }
         .           }
         .           
         .           FlatView *address_space_get_flatview(AddressSpace *as)
        39 ( 0.00%)  {
         .               FlatView *view;
         .           
         .               RCU_READ_LOCK_GUARD();
         .               do {
         .                   view = address_space_to_flatview(as);
         .                   /* If somebody has replaced as->current_map concurrently,
         .                    * flatview_ref returns false.
         .                    */
         .               } while (!flatview_ref(view));
         .               return view;
        78 ( 0.00%)  }
         .           
         .           static void address_space_update_ioeventfds(AddressSpace *as)
       418 ( 0.00%)  {
         .               FlatView *view;
         .               FlatRange *fr;
        76 ( 0.00%)      unsigned ioeventfd_nb = 0;
         .               unsigned ioeventfd_max;
         .               MemoryRegionIoeventfd *ioeventfds;
         .               AddrRange tmp;
         .               unsigned i;
         .           
         .               /*
         .                * It is likely that the number of ioeventfds hasn't changed much, so use
         .                * the previous size as the starting value, with some headroom to avoid
         .                * gratuitous reallocations.
         .                */
       304 ( 0.00%)      ioeventfd_max = QEMU_ALIGN_UP(as->ioeventfd_nb, 4);
       152 ( 0.00%)      ioeventfds = g_new(MemoryRegionIoeventfd, ioeventfd_max);
       570 ( 0.00%)  => ???:0x0000000004e3aa60 (38x)
         .           
       114 ( 0.00%)      view = address_space_get_flatview(as);
       532 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:address_space_get_flatview (38x)
     1,208 ( 0.00%)      FOR_EACH_FLAT_RANGE(fr, view) {
     1,056 ( 0.00%)          for (i = 0; i < fr->mr->ioeventfd_nb; ++i) {
         .                       tmp = addrrange_shift(fr->mr->ioeventfds[i].addr,
         .                                             int128_sub(fr->addr.start,
         .                                                        int128_make64(fr->offset_in_region)));
         .                       if (addrrange_intersects(fr->addr, tmp)) {
         .                           ++ioeventfd_nb;
         .                           if (ioeventfd_nb > ioeventfd_max) {
         .                               ioeventfd_max = MAX(ioeventfd_max * 2, 4);
         .                               ioeventfds = g_realloc(ioeventfds,
-- line 846 ----------------------------------------
-- line 848 ----------------------------------------
         .                           }
         .                           ioeventfds[ioeventfd_nb-1] = fr->mr->ioeventfds[i];
         .                           ioeventfds[ioeventfd_nb-1].addr = tmp;
         .                       }
         .                   }
         .               }
         .           
         .               address_space_add_del_ioeventfds(as, ioeventfds, ioeventfd_nb,
       152 ( 0.00%)                                       as->ioeventfds, as->ioeventfd_nb);
         .           
        76 ( 0.00%)      g_free(as->ioeventfds);
       380 ( 0.00%)  => ???:0x0000000004e3a950 (38x)
       114 ( 0.00%)      as->ioeventfds = ioeventfds;
        76 ( 0.00%)      as->ioeventfd_nb = ioeventfd_nb;
       190 ( 0.00%)      flatview_unref(view);
       152 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:flatview_unref (38x)
       266 ( 0.00%)  }
         .           
         .           /*
         .            * Notify the memory listeners about the coalesced IO change events of
         .            * range `cmr'.  Only the part that has intersection of the specified
         .            * FlatRange will be sent.
         .            */
         .           static void flat_range_coalesced_io_notify(FlatRange *fr, AddressSpace *as,
         .                                                      CoalescedMemoryRange *cmr, bool add)
-- line 870 ----------------------------------------
-- line 889 ----------------------------------------
         .                                                 int128_get64(tmp.size));
         .               }
         .           }
         .           
         .           static void flat_range_coalesced_io_del(FlatRange *fr, AddressSpace *as)
         .           {
         .               CoalescedMemoryRange *cmr;
         .           
         8 ( 0.00%)      QTAILQ_FOREACH(cmr, &fr->mr->coalesced, link) {
         .                   flat_range_coalesced_io_notify(fr, as, cmr, false);
         .               }
         .           }
         .           
         .           static void flat_range_coalesced_io_add(FlatRange *fr, AddressSpace *as)
         .           {
         .               MemoryRegion *mr = fr->mr;
         .               CoalescedMemoryRange *cmr;
         .           
        28 ( 0.00%)      if (QTAILQ_EMPTY(&mr->coalesced)) {
         .                   return;
         .               }
         .           
         .               QTAILQ_FOREACH(cmr, &mr->coalesced, link) {
         .                   flat_range_coalesced_io_notify(fr, as, cmr, true);
         .               }
         .           }
         .           
         .           static void address_space_update_topology_pass(AddressSpace *as,
         .                                                          const FlatView *old_view,
         .                                                          const FlatView *new_view,
         .                                                          bool adding)
        84 ( 0.00%)  {
         .               unsigned iold, inew;
         .               FlatRange *frold, *frnew;
         .           
         .               /* Generate a symmetric difference of the old and new memory maps.
         .                * Kill ranges in the old map, and instantiate ranges in the new map.
         .                */
        12 ( 0.00%)      iold = inew = 0;
       256 ( 0.00%)      while (iold < old_view->nr || inew < new_view->nr) {
         .                   if (iold < old_view->nr) {
       248 ( 0.00%)              frold = &old_view->ranges[iold];
         .                   } else {
         .                       frold = NULL;
         .                   }
       282 ( 0.00%)          if (inew < new_view->nr) {
       280 ( 0.00%)              frnew = &new_view->ranges[inew];
         .                   } else {
         .                       frnew = NULL;
         .                   }
         .           
       124 ( 0.00%)          if (frold
       124 ( 0.00%)              && (!frnew
       558 ( 0.00%)                  || int128_lt(frold->addr.start, frnew->addr.start)
       310 ( 0.00%)                  || (int128_eq(frold->addr.start, frnew->addr.start)
       298 ( 0.00%)                      && !flatrange_equal(frold, frnew)))) {
     1,582 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:flatrange_equal (62x)
         .                       /* In old but not in new, or in both but attributes changed. */
         .           
        10 ( 0.00%)              if (!adding) {
         .                           flat_range_coalesced_io_del(frold, as);
        28 ( 0.00%)                  MEMORY_LISTENER_UPDATE_REGION(frold, as, Reverse, region_del);
         .                       }
         .           
         8 ( 0.00%)              ++iold;
        12 ( 0.00%)          } else if (frold && frnew && flatrange_equal(frold, frnew)) {
         .                       /* In both and unchanged (except logging may have changed) */
         .           
       104 ( 0.00%)              if (adding) {
       338 ( 0.00%)                  MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, region_nop);
       156 ( 0.00%)                  if (frnew->dirty_log_mask & ~frold->dirty_log_mask) {
         .                               MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, log_start,
         .                                                             frold->dirty_log_mask,
         .                                                             frnew->dirty_log_mask);
         .                           }
        78 ( 0.00%)                  if (frold->dirty_log_mask & ~frnew->dirty_log_mask) {
         .                               MEMORY_LISTENER_UPDATE_REGION(frnew, as, Reverse, log_stop,
         .                                                             frold->dirty_log_mask,
         .                                                             frnew->dirty_log_mask);
         .                           }
         .                       }
         .           
        52 ( 0.00%)              ++iold;
       104 ( 0.00%)              ++inew;
         .                   } else {
         .                       /* In new */
         .           
        28 ( 0.00%)              if (adding) {
        76 ( 0.00%)                  MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, region_add);
         .                           flat_range_coalesced_io_add(frnew, as);
         .                       }
         .           
        14 ( 0.00%)              ++inew;
         .                   }
         .               }
        66 ( 0.00%)  }
         .           
         .           static void flatviews_init(void)
        17 ( 0.00%)  {
         .               static FlatView *empty_view;
         .           
        40 ( 0.00%)      if (flat_views) {
         .                   return;
         .               }
         .           
       119 ( 0.00%)      flat_views = g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL,
     9,488 ( 0.00%)  => ???:0x0000000004e3b5d0 (17x)
         .                                                  (GDestroyNotify) flatview_unref);
        51 ( 0.00%)      if (!empty_view) {
         3 ( 0.00%)          empty_view = generate_memory_topology(NULL);
     1,150 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:generate_memory_topology (1x)
         .                   /* We keep it alive forever in the global variable.  */
         .                   flatview_ref(empty_view);
         .               } else {
        32 ( 0.00%)          g_hash_table_replace(flat_views, NULL, empty_view);
     3,760 ( 0.00%)  => ???:0x0000000004e3c2a0 (16x)
         .                   flatview_ref(empty_view);
         .               }
        34 ( 0.00%)  }
         .           
         .           static void flatviews_reset(void)
         .           {
         .               AddressSpace *as;
         .           
        48 ( 0.00%)      if (flat_views) {
        16 ( 0.00%)          g_hash_table_unref(flat_views);
    10,702 ( 0.00%)  => ???:0x0000000004e3c1e0 (16x)
        16 ( 0.00%)          flat_views = NULL;
         .               }
        16 ( 0.00%)      flatviews_init();
    12,968 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:flatviews_init (16x)
         .           
         .               /* Render unique FVs */
       153 ( 0.00%)      QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
       105 ( 0.00%)          MemoryRegion *physmr = memory_region_get_flatview_root(as->root);
       687 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_get_flatview_root (35x)
         .           
       175 ( 0.00%)          if (g_hash_table_lookup(flat_views, physmr)) {
     1,880 ( 0.00%)  => ???:0x0000000004e3bdd0 (35x)
         .                       continue;
         .                   }
         .           
        68 ( 0.00%)          generate_memory_topology(physmr);
 2,166,770 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:generate_memory_topology (34x)
         .               }
         .           }
         .           
         .           static void address_space_set_flatview(AddressSpace *as)
       342 ( 0.00%)  {
         .               FlatView *old_view = address_space_to_flatview(as);
       114 ( 0.00%)      MemoryRegion *physmr = memory_region_get_flatview_root(as->root);
       769 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_get_flatview_root (38x)
        76 ( 0.00%)      FlatView *new_view = g_hash_table_lookup(flat_views, physmr);
     3,016 ( 0.00%)  => ???:0x0000000004e3bdd0 (38x)
         .           
       114 ( 0.00%)      assert(new_view);
         .           
        76 ( 0.00%)      if (old_view == new_view) {
         .                   return;
         .               }
         .           
        74 ( 0.00%)      if (old_view) {
         .                   flatview_ref(old_view);
         .               }
         .           
         .               flatview_ref(new_view);
         .           
        74 ( 0.00%)      if (!QTAILQ_EMPTY(&as->listeners)) {
        15 ( 0.00%)          FlatView tmpview = { .nr = 0 }, *old_view2 = old_view;
         .           
         .                   if (!old_view2) {
         9 ( 0.00%)              old_view2 = &tmpview;
         .                   }
        15 ( 0.00%)          address_space_update_topology_pass(as, old_view2, new_view, false);
     2,253 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:address_space_update_topology_pass (3x)
        15 ( 0.00%)          address_space_update_topology_pass(as, old_view2, new_view, true);
     3,505 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:address_space_update_topology_pass (3x)
         .               }
         .           
         .               /* Writes are protected by the BQL.  */
        37 ( 0.00%)      qatomic_rcu_set(&as->current_map, new_view);
        74 ( 0.00%)      if (old_view) {
        68 ( 0.00%)          flatview_unref(old_view);
       136 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:flatview_unref (34x)
         .               }
         .           
         .               /* Note that all the old MemoryRegions are still alive up to this
         .                * point.  This relieves most MemoryListeners from the need to
         .                * ref/unref the MemoryRegions they get---unless they use them
         .                * outside the iothread mutex, in which case precise reference
         .                * counting is necessary.
         .                */
         .               if (old_view) {
       170 ( 0.00%)          flatview_unref(old_view);
       840 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:flatview_unref (34x)
         .               }
       206 ( 0.00%)  }
         .           
         .           static void address_space_update_topology(AddressSpace *as)
         .           {
         9 ( 0.00%)      MemoryRegion *physmr = memory_region_get_flatview_root(as->root);
        82 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_get_flatview_root (3x)
         .           
         3 ( 0.00%)      flatviews_init();
     1,895 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:flatviews_init (3x)
        15 ( 0.00%)      if (!g_hash_table_lookup(flat_views, physmr)) {
       207 ( 0.00%)  => ???:0x0000000004e3bdd0 (3x)
         3 ( 0.00%)          generate_memory_topology(physmr);
    43,019 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:generate_memory_topology (1x)
         .               }
         6 ( 0.00%)      address_space_set_flatview(as);
       448 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:address_space_set_flatview (3x)
         .           }
         .           
         .           void memory_region_transaction_begin(void)
        36 ( 0.00%)  {
        18 ( 0.00%)      qemu_flush_coalesced_mmio_buffer();
        36 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:qemu_flush_coalesced_mmio_buffer (18x)
        18 ( 0.00%)      ++memory_region_transaction_depth;
        36 ( 0.00%)  }
         .           
         .           void memory_region_transaction_commit(void)
        72 ( 0.00%)  {
         .               AddressSpace *as;
         .           
        54 ( 0.00%)      assert(memory_region_transaction_depth);
        54 ( 0.00%)      assert(qemu_mutex_iothread_locked());
       396 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/cpus.c:qemu_mutex_iothread_locked (18x)
         .           
        18 ( 0.00%)      --memory_region_transaction_depth;
        18 ( 0.00%)      if (!memory_region_transaction_depth) {
        36 ( 0.00%)          if (memory_region_update_pending) {
         .                       flatviews_reset();
         .           
        69 ( 0.00%)              MEMORY_LISTENER_CALL_GLOBAL(begin, Forward);
         .           
       169 ( 0.00%)              QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
        70 ( 0.00%)                  address_space_set_flatview(as);
    12,190 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:address_space_set_flatview (35x)
        70 ( 0.00%)                  address_space_update_ioeventfds(as);
     5,501 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:address_space_update_ioeventfds (35x)
         .                       }
        16 ( 0.00%)              memory_region_update_pending = false;
        16 ( 0.00%)              ioeventfd_update_pending = false;
        75 ( 0.00%)              MEMORY_LISTENER_CALL_GLOBAL(commit, Forward);
    49,755 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:tcg_commit (3x)
         4 ( 0.00%)          } else if (ioeventfd_update_pending) {
         .                       QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
         .                           address_space_update_ioeventfds(as);
         .                       }
         .                       ioeventfd_update_pending = false;
         .                   }
         .              }
        72 ( 0.00%)  }
         .           
         .           static void memory_region_destructor_none(MemoryRegion *mr)
         2 ( 0.00%)  {
         2 ( 0.00%)  }
         .           
         .           static void memory_region_destructor_ram(MemoryRegion *mr)
         .           {
         .               qemu_ram_free(mr->ram_block);
         .           }
         .           
         .           static bool memory_region_need_escape(char c)
         .           {
-- line 1129 ----------------------------------------
-- line 1130 ----------------------------------------
         .               return c == '/' || c == '[' || c == '\\' || c == ']';
         .           }
         .           
         .           static char *memory_region_escape_name(const char *name)
         .           {
         .               const char *p;
         .               char *escaped, *q;
         .               uint8_t c;
     1,132 ( 0.00%)      size_t bytes = 0;
         .           
       620 ( 0.00%)      for (p = name; *p; p++) {
       137 ( 0.00%)          bytes += memory_region_need_escape(*p) ? 4 : 1;
         .               }
        54 ( 0.00%)      if (bytes == p - name) {
        90 ( 0.00%)         return g_memdup(name, bytes + 1);
     4,288 ( 0.00%)  => ???:0x0000000004e3b500 (18x)
         .               }
         .           
         .               escaped = g_malloc(bytes + 1);
         .               for (p = name, q = escaped; *p; p++) {
         .                   c = *p;
         .                   if (unlikely(memory_region_need_escape(c))) {
         .                       *q++ = '\\';
         .                       *q++ = 'x';
-- line 1152 ----------------------------------------
-- line 1154 ----------------------------------------
         .                       c = "0123456789abcdef"[c & 15];
         .                   }
         .                   *q++ = c;
         .               }
         .               *q = 0;
         .               return escaped;
         .           }
         .           
       144 ( 0.00%)  static void memory_region_do_init(MemoryRegion *mr,
         .                                             Object *owner,
         .                                             const char *name,
         .                                             uint64_t size)
         .           {
         .               mr->size = int128_make64(size);
         .               if (size == UINT64_MAX) {
         .                   mr->size = int128_2_64();
         .               }
        60 ( 0.00%)      mr->name = g_strdup(name);
     4,137 ( 0.00%)  => ???:0x0000000004e3b620 (20x)
        20 ( 0.00%)      mr->owner = owner;
        20 ( 0.00%)      mr->ram_block = NULL;
         .           
        40 ( 0.00%)      if (name) {
         .                   char *escaped_name = memory_region_escape_name(name);
        90 ( 0.00%)          char *name_array = g_strdup_printf("%s[*]", escaped_name);
    22,078 ( 0.00%)  => ???:0x0000000004e3b7e0 (18x)
         .           
        36 ( 0.00%)          if (!owner) {
        60 ( 0.00%)              owner = container_get(qdev_get_machine(), "/unattached");
    28,572 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/container.c:container_get (10x)
     2,582 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../hw/core/qdev.c:qdev_get_machine (10x)
         .                   }
         .           
        72 ( 0.00%)          object_property_add_child(owner, name_array, OBJECT(mr));
    88,729 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_add_child (18x)
        36 ( 0.00%)          object_unref(OBJECT(mr));
       504 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_unref (18x)
        36 ( 0.00%)          g_free(name_array);
     1,710 ( 0.00%)  => ???:0x0000000004e3a950 (18x)
        36 ( 0.00%)          g_free(escaped_name);
     1,738 ( 0.00%)  => ???:0x0000000004e3a950 (18x)
         .               }
        90 ( 0.00%)  }
         .           
         .           void memory_region_init(MemoryRegion *mr,
         .                                   Object *owner,
         .                                   const char *name,
         .                                   uint64_t size)
       200 ( 0.00%)  {
        60 ( 0.00%)      object_initialize(mr, sizeof(*mr), TYPE_MEMORY_REGION);
   108,252 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_initialize (16x)
    30,056 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_initialize'2 (4x)
         .               memory_region_do_init(mr, owner, name, size);
       174 ( 0.00%)  }
   152,834 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_do_init.part.0.constprop.0 (18x)
         .           
         .           static void memory_region_get_container(Object *obj, Visitor *v,
         .                                                   const char *name, void *opaque,
         .                                                   Error **errp)
         .           {
         .               MemoryRegion *mr = MEMORY_REGION(obj);
         .               char *path = (char *)"";
         .           
-- line 1205 ----------------------------------------
-- line 1235 ----------------------------------------
         .           {
         .               MemoryRegion *mr = MEMORY_REGION(obj);
         .               uint64_t value = memory_region_size(mr);
         .           
         .               visit_type_uint64(v, name, &value, errp);
         .           }
         .           
         .           static void memory_region_initfn(Object *obj)
        40 ( 0.00%)  {
         .               MemoryRegion *mr = MEMORY_REGION(obj);
         .               ObjectProperty *op;
         .           
        40 ( 0.00%)      mr->ops = &unassigned_mem_ops;
        20 ( 0.00%)      mr->enabled = true;
        20 ( 0.00%)      mr->romd_mode = true;
        40 ( 0.00%)      mr->destructor = memory_region_destructor_none;
        60 ( 0.00%)      QTAILQ_INIT(&mr->subregions);
        60 ( 0.00%)      QTAILQ_INIT(&mr->coalesced);
         .           
       180 ( 0.00%)      op = object_property_add(OBJECT(mr), "container",
    29,498 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_add (20x)
         .                                        "link<" TYPE_MEMORY_REGION ">",
         .                                        memory_region_get_container,
         .                                        NULL, /* memory_region_set_container */
         .                                        NULL, NULL);
        40 ( 0.00%)      op->resolve = memory_region_resolve_container;
         .           
        80 ( 0.00%)      object_property_add_uint64_ptr(OBJECT(mr), "addr",
    23,539 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_add_uint64_ptr (20x)
        20 ( 0.00%)                                     &mr->addr, OBJ_PROP_FLAG_READ);
       160 ( 0.00%)      object_property_add(OBJECT(mr), "priority", "uint32",
    27,669 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_add (20x)
         .                                   memory_region_get_priority,
         .                                   NULL, /* memory_region_set_priority */
         .                                   NULL, NULL);
       160 ( 0.00%)      object_property_add(OBJECT(mr), "size", "uint64",
    25,910 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_property_add (20x)
         .                                   memory_region_get_size,
         .                                   NULL, /* memory_region_set_size, */
         .                                   NULL, NULL);
        80 ( 0.00%)  }
         .           
         .           static void iommu_memory_region_initfn(Object *obj)
         .           {
         .               MemoryRegion *mr = MEMORY_REGION(obj);
         .           
         .               mr->is_iommu = true;
         .           }
         .           
-- line 1279 ----------------------------------------
-- line 1371 ----------------------------------------
         .               },
         .           };
         .           
         .           bool memory_region_access_valid(MemoryRegion *mr,
         .                                           hwaddr addr,
         .                                           unsigned size,
         .                                           bool is_write,
         .                                           MemTxAttrs attrs)
24,656,454 ( 0.03%)  {
16,748,970 ( 0.02%)      if (mr->ops->valid.accepts
 1,556,670 ( 0.00%)          && !mr->ops->valid.accepts(mr->opaque, addr, size, is_write, attrs)) {
103,122,777 ( 0.14%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:subpage_accepts (311,334x)
         .                   qemu_log_mask(LOG_GUEST_ERROR, "Invalid %s at addr 0x%" HWADDR_PRIX
         .                                 ", size %u, region '%s', reason: rejected\n",
         .                                 is_write ? "write" : "read",
         .                                 addr, size, memory_region_name(mr));
         .                   return false;
         .               }
         .           
12,665,190 ( 0.02%)      if (!mr->ops->valid.unaligned && (addr & (size - 1))) {
         .                   qemu_log_mask(LOG_GUEST_ERROR, "Invalid %s at addr 0x%" HWADDR_PRIX
         .                                 ", size %u, region '%s', reason: unaligned\n",
         .                                 is_write ? "write" : "read",
         .                                 addr, size, memory_region_name(mr));
         .                   return false;
         .               }
         .           
         .               /* Treat zero as compatibility all valid */
12,328,227 ( 0.02%)      if (!mr->ops->valid.max_access_size) {
         .                   return true;
         .               }
         .           
 6,633,054 ( 0.01%)      if (size > mr->ops->valid.max_access_size
 6,633,054 ( 0.01%)          || size < mr->ops->valid.min_access_size) {
         .                   qemu_log_mask(LOG_GUEST_ERROR, "Invalid %s at addr 0x%" HWADDR_PRIX
         .                                 ", size %u, region '%s', reason: invalid size "
         .                                 "(min:%u max:%u)\n",
         .                                 is_write ? "write" : "read",
         .                                 addr, size, memory_region_name(mr),
         .                                 mr->ops->valid.min_access_size,
         .                                 mr->ops->valid.max_access_size);
         .                   return false;
         .               }
 4,109,409 ( 0.01%)      return true;
20,547,045 ( 0.03%)  }
         .           
         .           static MemTxResult memory_region_dispatch_read1(MemoryRegion *mr,
         .                                                           hwaddr addr,
         .                                                           uint64_t *pval,
         .                                                           unsigned size,
         .                                                           MemTxAttrs attrs)
         .           {
         .               *pval = 0;
         .           
 6,866,394 ( 0.01%)      if (mr->ops->read) {
 9,307,462 ( 0.01%)          return access_with_adjusted_size(addr, pval, size,
         .                                                    mr->ops->impl.min_access_size,
         .                                                    mr->ops->impl.max_access_size,
         .                                                    memory_region_read_accessor,
         .                                                    mr, attrs);
         .               } else {
18,870,290 ( 0.03%)          return access_with_adjusted_size(addr, pval, size,
734,971,264 ( 1.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:access_with_adjusted_size (1,870,752x)
         .                                                    mr->ops->impl.min_access_size,
         .                                                    mr->ops->impl.max_access_size,
         .                                                    memory_region_read_with_attrs_accessor,
         .                                                    mr, attrs);
         .               }
         .           }
         .           
         .           MemTxResult memory_region_dispatch_read(MemoryRegion *mr,
         .                                                   hwaddr addr,
         .                                                   uint64_t *pval,
         .                                                   MemOp op,
         .                                                   MemTxAttrs attrs)
27,465,576 ( 0.04%)  {
         .               unsigned size = memop_size(op);
         .               MemTxResult r;
         .           
13,732,788 ( 0.02%)      if (mr->alias) {
         .                   return memory_region_dispatch_read(mr->alias,
         .                                                      mr->alias_offset + addr,
         .                                                      pval, op, attrs);
         .               }
18,310,384 ( 0.03%)      if (!memory_region_access_valid(mr, addr, size, false, attrs)) {
126,030,619 ( 0.17%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_access_valid (1,870,752x)
 2,288,798 ( 0.00%)          *pval = unassigned_mem_read(mr, addr, size);
         .                   return MEMTX_DECODE_ERROR;
         .               }
         .           
         .               r = memory_region_dispatch_read1(mr, addr, pval, size, attrs);
 9,155,192 ( 0.01%)      adjust_endianness(mr, pval, op);
18,707,520 ( 0.03%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:adjust_endianness.isra.0 (1,870,752x)
         .               return r;
20,599,182 ( 0.03%)  }
         .           
         .           /* Return true if an eventfd was signalled */
         .           static bool memory_region_dispatch_write_eventfds(MemoryRegion *mr,
         .                                                               hwaddr addr,
         .                                                               uint64_t data,
         .                                                               unsigned size,
         .                                                               MemTxAttrs attrs)
         .           {
 7,546,385 ( 0.01%)      MemoryRegionIoeventfd ioeventfd = {
         .                   .addr = addrrange_make(int128_make64(addr), int128_make64(size)),
         .                   .data = data,
         .               };
         .               unsigned i;
         .           
 4,527,831 ( 0.01%)      for (i = 0; i < mr->ioeventfd_nb; i++) {
         .                   ioeventfd.match_data = mr->ioeventfds[i].match_data;
         .                   ioeventfd.e = mr->ioeventfds[i].e;
         .           
         .                   if (memory_region_ioeventfd_equal(&ioeventfd, &mr->ioeventfds[i])) {
         .                       event_notifier_set(ioeventfd.e);
         .                       return true;
         .                   }
         .               }
-- line 1484 ----------------------------------------
-- line 1486 ----------------------------------------
         .               return false;
         .           }
         .           
         .           MemTxResult memory_region_dispatch_write(MemoryRegion *mr,
         .                                                    hwaddr addr,
         .                                                    uint64_t data,
         .                                                    MemOp op,
         .                                                    MemTxAttrs attrs)
24,148,432 ( 0.03%)  {
         .               unsigned size = memop_size(op);
         .           
 4,527,831 ( 0.01%)      if (mr->alias) {
         .                   return memory_region_dispatch_write(mr->alias,
         .                                                       mr->alias_offset + addr,
         .                                                       data, op, attrs);
         .               }
10,564,939 ( 0.01%)      if (!memory_region_access_valid(mr, addr, size, true, attrs)) {
60,350,559 ( 0.08%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_access_valid (1,341,859x)
         .                   unassigned_mem_write(mr, addr, data, size);
 1,509,277 ( 0.00%)          return MEMTX_DECODE_ERROR;
         .               }
         .           
10,564,939 ( 0.01%)      adjust_endianness(mr, &data, op);
13,418,590 ( 0.02%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:adjust_endianness.isra.0 (1,341,859x)
         .           
         .               if ((!kvm_eventfds_enabled()) &&
         .                   memory_region_dispatch_write_eventfds(mr, addr, data, size, attrs)) {
         .                   return MEMTX_OK;
         .               }
         .           
 3,018,554 ( 0.00%)      if (mr->ops->write) {
 3,463,323 ( 0.00%)          return access_with_adjusted_size(addr, &data, size,
 1,509,277 ( 0.00%)                                           mr->ops->impl.min_access_size,
 1,509,277 ( 0.00%)                                           mr->ops->impl.max_access_size,
         .                                                    memory_region_write_accessor, mr,
         .                                                    attrs);
         .               } else {
         .                   return
11,984,283 ( 0.02%)              access_with_adjusted_size(addr, &data, size,
278,112,841 ( 0.38%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:access_with_adjusted_size (1,341,859x)
         .                                                 mr->ops->impl.min_access_size,
         .                                                 mr->ops->impl.max_access_size,
         .                                                 memory_region_write_with_attrs_accessor,
         .                                                 mr, attrs);
         .               }
16,602,047 ( 0.02%)  }
         .           
         .           void memory_region_init_io(MemoryRegion *mr,
         .                                      Object *owner,
         .                                      const MemoryRegionOps *ops,
         .                                      void *opaque,
         .                                      const char *name,
         .                                      uint64_t size)
       117 ( 0.00%)  {
        13 ( 0.00%)      memory_region_init(mr, owner, name, size);
   183,775 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_init (13x)
        39 ( 0.00%)      mr->ops = ops ? ops : &unassigned_mem_ops;
        13 ( 0.00%)      mr->opaque = opaque;
        13 ( 0.00%)      mr->terminates = true;
        52 ( 0.00%)  }
         .           
         .           void memory_region_init_ram_nomigrate(MemoryRegion *mr,
         .                                                 Object *owner,
         .                                                 const char *name,
         .                                                 uint64_t size,
         .                                                 Error **errp)
         4 ( 0.00%)  {
        12 ( 0.00%)      memory_region_init_ram_flags_nomigrate(mr, owner, name, size, 0, errp);
    71,827 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_init_ram_flags_nomigrate (4x)
         .           }
         .           
         .           void memory_region_init_ram_flags_nomigrate(MemoryRegion *mr,
         .                                                       Object *owner,
         .                                                       const char *name,
         .                                                       uint64_t size,
         .                                                       uint32_t ram_flags,
         .                                                       Error **errp)
        65 ( 0.00%)  {
         5 ( 0.00%)      Error *err = NULL;
         5 ( 0.00%)      memory_region_init(mr, owner, name, size);
    78,937 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_init (5x)
         5 ( 0.00%)      mr->ram = true;
         5 ( 0.00%)      mr->terminates = true;
        10 ( 0.00%)      mr->destructor = memory_region_destructor_ram;
        30 ( 0.00%)      mr->ram_block = qemu_ram_alloc(size, ram_flags, mr, &err);
 1,189,643 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:qemu_ram_alloc (5x)
        10 ( 0.00%)      if (err) {
         .                   mr->size = int128_zero();
         .                   object_unparent(OBJECT(mr));
         .                   error_propagate(errp, err);
         .               }
        45 ( 0.00%)  }
         .           
         .           void memory_region_init_resizeable_ram(MemoryRegion *mr,
         .                                                  Object *owner,
         .                                                  const char *name,
         .                                                  uint64_t size,
         .                                                  uint64_t max_size,
         .                                                  void (*resized)(const char*,
         .                                                                  uint64_t length,
-- line 1578 ----------------------------------------
-- line 1740 ----------------------------------------
         .               memory_region_do_init(mr, owner, name, size);
         .               iommu_mr = IOMMU_MEMORY_REGION(mr);
         .               mr->terminates = true;  /* then re-forwards */
         .               QLIST_INIT(&iommu_mr->iommu_notify);
         .               iommu_mr->iommu_notify_flags = IOMMU_NOTIFIER_NONE;
         .           }
         .           
         .           static void memory_region_finalize(Object *obj)
         4 ( 0.00%)  {
         .               MemoryRegion *mr = MEMORY_REGION(obj);
         .           
         4 ( 0.00%)      assert(!mr->container);
         .           
         .               /* We know the region is not visible in any address space (it
         .                * does not have a container and cannot be a root either because
         .                * it has no references, so we can blindly clear mr->enabled.
         .                * memory_region_set_enabled instead could trigger a transaction
         .                * and cause an infinite loop.
         .                */
         4 ( 0.00%)      mr->enabled = false;
         2 ( 0.00%)      memory_region_transaction_begin();
        16 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_transaction_begin (2x)
         6 ( 0.00%)      while (!QTAILQ_EMPTY(&mr->subregions)) {
         .                   MemoryRegion *subregion = QTAILQ_FIRST(&mr->subregions);
         .                   memory_region_del_subregion(mr, subregion);
         .               }
         2 ( 0.00%)      memory_region_transaction_commit();
        84 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_transaction_commit (2x)
         .           
         4 ( 0.00%)      mr->destructor(mr);
         4 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_destructor_none (2x)
         4 ( 0.00%)      memory_region_clear_coalescing(mr);
         8 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_clear_coalescing (2x)
         4 ( 0.00%)      g_free((char *)mr->name);
       250 ( 0.00%)  => ???:0x0000000004e3a950 (2x)
         4 ( 0.00%)      g_free(mr->ioeventfds);
        20 ( 0.00%)  => ???:0x0000000004e3a950 (2x)
         2 ( 0.00%)  }
         .           
         .           Object *memory_region_owner(MemoryRegion *mr)
         .           {
         .               Object *obj = OBJECT(mr);
         .               return obj->parent;
         .           }
         .           
         .           void memory_region_ref(MemoryRegion *mr)
       337 ( 0.00%)  {
         .               /* MMIO callbacks most likely will access data that belongs
         .                * to the owner, hence the need to ref/unref the owner whenever
         .                * the memory region is in use.
         .                *
         .                * The memory region is a child of its owner.  As long as the
         .                * owner doesn't call unparent itself on the memory region,
         .                * ref-ing the owner will also keep the memory region alive.
         .                * Memory regions without an owner are supposed to never go away;
         .                * we do not ref/unref them because it slows down DMA sensibly.
         .                */
     1,682 ( 0.00%)      if (mr && mr->owner) {
        26 ( 0.00%)          object_ref(mr->owner);
       234 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_ref (26x)
         .               }
       311 ( 0.00%)  }
         .           
         .           void memory_region_unref(MemoryRegion *mr)
       268 ( 0.00%)  {
     1,340 ( 0.00%)      if (mr && mr->owner) {
        10 ( 0.00%)          object_unref(mr->owner);
       280 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:object_unref (10x)
         .               }
       258 ( 0.00%)  }
         .           
         .           uint64_t memory_region_size(MemoryRegion *mr)
         3 ( 0.00%)  {
        18 ( 0.00%)      if (int128_eq(mr->size, int128_2_64())) {
         .                   return UINT64_MAX;
         .               }
         .               return int128_get64(mr->size);
         3 ( 0.00%)  }
         .           
         .           const char *memory_region_name(const MemoryRegion *mr)
         5 ( 0.00%)  {
        15 ( 0.00%)      if (!mr->name) {
         .                   ((MemoryRegion *)mr)->name =
         .                       g_strdup(object_get_canonical_path_component(OBJECT(mr)));
         .               }
         .               return mr->name;
         5 ( 0.00%)  }
         .           
         .           bool memory_region_is_ram_device(MemoryRegion *mr)
 8,584,994 ( 0.01%)  {
 8,584,994 ( 0.01%)      return mr->ram_device;
 8,584,994 ( 0.01%)  }
         .           
         .           bool memory_region_is_protected(MemoryRegion *mr)
         .           {
         .               return mr->ram && (mr->ram_block->flags & RAM_PROTECTED);
         .           }
         .           
         .           uint8_t memory_region_get_dirty_log_mask(MemoryRegion *mr)
16,610,860 ( 0.02%)  {
 4,152,715 ( 0.01%)      uint8_t mask = mr->dirty_log_mask;
 4,152,715 ( 0.01%)      RAMBlock *rb = mr->ram_block;
         .           
16,610,860 ( 0.02%)      if (global_dirty_tracking && ((rb && qemu_ram_is_migratable(rb)) ||
         .                                        memory_region_is_iommu(mr))) {
         .                   mask |= (1 << DIRTY_MEMORY_MIGRATION);
         .               }
         .           
20,763,573 ( 0.03%)      if (tcg_enabled() && rb) {
         .                   /* TCG only cares about dirty memory logging for RAM, not IOMMU.  */
16,610,856 ( 0.02%)          mask |= (1 << DIRTY_MEMORY_CODE);
         .               }
         .               return mask;
20,763,575 ( 0.03%)  }
         .           
         .           bool memory_region_is_logging(MemoryRegion *mr, uint8_t client)
         .           {
         .               return memory_region_get_dirty_log_mask(mr) & (1 << client);
         .           }
         .           
         .           static int memory_region_update_iommu_notify_flags(IOMMUMemoryRegion *iommu_mr,
         .                                                              Error **errp)
-- line 1853 ----------------------------------------
-- line 2189 ----------------------------------------
         .               if (read_only) {
         .                   *read_only = !writable || mr->readonly;
         .               }
         .           
         .               return true;
         .           }
         .           
         .           void memory_region_set_log(MemoryRegion *mr, bool log, unsigned client)
        16 ( 0.00%)  {
         .               uint8_t mask = 1 << client;
         .               uint8_t old_logging;
         .           
         8 ( 0.00%)      assert(client == DIRTY_MEMORY_VGA);
        12 ( 0.00%)      old_logging = mr->vga_logging_count;
        20 ( 0.00%)      mr->vga_logging_count += log ? 1 : -1;
        24 ( 0.00%)      if (!!old_logging == !!mr->vga_logging_count) {
         .                   return;
         .               }
         .           
         4 ( 0.00%)      memory_region_transaction_begin();
        32 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_transaction_begin (4x)
        16 ( 0.00%)      mr->dirty_log_mask = (mr->dirty_log_mask & ~mask) | (log * mask);
         8 ( 0.00%)      memory_region_update_pending |= mr->enabled;
         4 ( 0.00%)      memory_region_transaction_commit();
   332,097 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_transaction_commit (4x)
        12 ( 0.00%)  }
         .           
         .           void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,
         .                                        hwaddr size)
         .           {
         .               assert(mr->ram_block);
         .               cpu_physical_memory_set_dirty_range(memory_region_get_ram_addr(mr) + addr,
         .                                                   size,
         .                                                   memory_region_get_dirty_log_mask(mr));
         .           }
         .           
         .           /*
         .            * If memory region `mr' is NULL, do global sync.  Otherwise, sync
         .            * dirty bitmap for the specified memory region.
         .            */
         .           static void memory_region_sync_dirty_bitmap(MemoryRegion *mr)
   719,964 ( 0.00%)  {
         .               MemoryListener *listener;
         .               AddressSpace *as;
         .               FlatView *view;
         .               FlatRange *fr;
         .           
         .               /* If the same address space has multiple log_sync listeners, we
         .                * visit that address space's FlatView multiple times.  But because
         .                * log_sync listeners are rare, it's still cheaper than walking each
         .                * address space once.
         .                */
   719,964 ( 0.00%)      QTAILQ_FOREACH(listener, &memory_listeners, link) {
   159,992 ( 0.00%)          if (listener->log_sync) {
         .                       as = listener->address_space;
         .                       view = address_space_get_flatview(as);
         .                       FOR_EACH_FLAT_RANGE(fr, view) {
         .                           if (fr->dirty_log_mask && (!mr || fr->mr == mr)) {
         .                               MemoryRegionSection mrs = section_from_flat_range(fr, view);
         .                               listener->log_sync(listener, &mrs);
         .                           }
         .                       }
         .                       flatview_unref(view);
         .                       trace_memory_region_sync_dirty(mr ? mr->name : "(all)", listener->name, 0);
   239,988 ( 0.00%)          } else if (listener->log_sync_global) {
         .                       /*
         .                        * No matter whether MR is specified, what we can do here
         .                        * is to do a global sync, because we are not capable to
         .                        * sync in a finer granularity.
         .                        */
         .                       listener->log_sync_global(listener);
         .                       trace_memory_region_sync_dirty(mr ? mr->name : "(all)", listener->name, 1);
         .                   }
         .               }
   799,960 ( 0.00%)  }
         .           
         .           void memory_region_clear_dirty_bitmap(MemoryRegion *mr, hwaddr start,
         .                                                 hwaddr len)
 1,760,231 ( 0.00%)  {
         .               MemoryRegionSection mrs;
         .               MemoryListener *listener;
         .               AddressSpace *as;
         .               FlatView *view;
         .               FlatRange *fr;
         .               hwaddr sec_start, sec_end, sec_size;
         .           
 1,280,148 ( 0.00%)      QTAILQ_FOREACH(listener, &memory_listeners, link) {
   320,034 ( 0.00%)          if (!listener->log_clear) {
         .                       continue;
         .                   }
         .                   as = listener->address_space;
         .                   view = address_space_get_flatview(as);
         .                   FOR_EACH_FLAT_RANGE(fr, view) {
         .                       if (!fr->dirty_log_mask || fr->mr != mr) {
         .                           /*
         .                            * Clear dirty bitmap operation only applies to those
-- line 2282 ----------------------------------------
-- line 2284 ----------------------------------------
         .                            */
         .                           continue;
         .                       }
         .           
         .                       mrs = section_from_flat_range(fr, view);
         .           
         .                       sec_start = MAX(mrs.offset_within_region, start);
         .                       sec_end = mrs.offset_within_region + int128_get64(mrs.size);
   320,034 ( 0.00%)              sec_end = MIN(sec_end, start + len);
         .           
         .                       if (sec_start >= sec_end) {
         .                           /*
         .                            * If this memory region section has no intersection
         .                            * with the requested range, skip.
         .                            */
         .                           continue;
         .                       }
-- line 2300 ----------------------------------------
-- line 2304 ----------------------------------------
         .                           sec_start - mrs.offset_within_region;
         .                       mrs.offset_within_region = sec_start;
         .                       sec_size = sec_end - sec_start;
         .                       mrs.size = int128_make64(sec_size);
         .                       listener->log_clear(listener, &mrs);
         .                   }
         .                   flatview_unref(view);
         .               }
 1,760,231 ( 0.00%)  }
         .           
         .           DirtyBitmapSnapshot *memory_region_snapshot_and_clear_dirty(MemoryRegion *mr,
         .                                                                       hwaddr addr,
         .                                                                       hwaddr size,
         .                                                                       unsigned client)
   479,976 ( 0.00%)  {
         .               DirtyBitmapSnapshot *snapshot;
   479,976 ( 0.00%)      assert(mr->ram_block);
    79,996 ( 0.00%)      memory_region_sync_dirty_bitmap(mr);
 2,639,868 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_sync_dirty_bitmap (79,996x)
   479,976 ( 0.00%)      snapshot = cpu_physical_memory_snapshot_and_clear_dirty(mr, addr, size, client);
2,078,202,142 ( 2.85%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:cpu_physical_memory_snapshot_and_clear_dirty (79,996x)
    79,996 ( 0.00%)      memory_global_after_dirty_log_sync();
 6,079,696 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_global_after_dirty_log_sync (79,996x)
         .               return snapshot;
   559,972 ( 0.00%)  }
         .           
         .           bool memory_region_snapshot_get_dirty(MemoryRegion *mr, DirtyBitmapSnapshot *snap,
         .                                                 hwaddr addr, hwaddr size)
         .           {
         .               assert(mr->ram_block);
         .               return cpu_physical_memory_snapshot_get_dirty(snap,
         .                           memory_region_get_ram_addr(mr) + addr, size);
         .           }
-- line 2333 ----------------------------------------
-- line 2359 ----------------------------------------
         .                   mr->romd_mode = romd_mode;
         .                   memory_region_update_pending |= mr->enabled;
         .                   memory_region_transaction_commit();
         .               }
         .           }
         .           
         .           void memory_region_reset_dirty(MemoryRegion *mr, hwaddr addr,
         .                                          hwaddr size, unsigned client)
        16 ( 0.00%)  {
        20 ( 0.00%)      assert(mr->ram_block);
        16 ( 0.00%)      cpu_physical_memory_test_and_clear_dirty(
     1,117 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:cpu_physical_memory_test_and_clear_dirty (4x)
         4 ( 0.00%)          memory_region_get_ram_addr(mr) + addr, size, client);
        24 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_get_ram_addr (4x)
        12 ( 0.00%)  }
         .           
         .           int memory_region_get_fd(MemoryRegion *mr)
         .           {
         .               int fd;
         .           
         .               RCU_READ_LOCK_GUARD();
         .               while (mr->alias) {
         .                   mr = mr->alias;
         .               }
         .               fd = mr->ram_block->fd;
         .           
         .               return fd;
         .           }
         .           
         .           void *memory_region_get_ram_ptr(MemoryRegion *mr)
    99,624 ( 0.00%)  {
         .               void *ptr;
   199,248 ( 0.00%)      uint64_t offset = 0;
         .           
         .               RCU_READ_LOCK_GUARD();
   398,496 ( 0.00%)      while (mr->alias) {
         .                   offset += mr->alias_offset;
         .                   mr = mr->alias;
         .               }
   298,872 ( 0.00%)      assert(mr->ram_block);
    99,624 ( 0.00%)      ptr = qemu_map_ram_ptr(mr->ram_block, offset);
 1,295,112 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:qemu_map_ram_ptr (99,624x)
         .           
         .               return ptr;
         .           }
         .           
         .           MemoryRegion *memory_region_from_host(void *ptr, ram_addr_t *offset)
         .           {
         .               RAMBlock *block;
         .           
-- line 2405 ----------------------------------------
-- line 2407 ----------------------------------------
         .               if (!block) {
         .                   return NULL;
         .               }
         .           
         .               return block->mr;
         .           }
         .           
         .           ram_addr_t memory_region_get_ram_addr(MemoryRegion *mr)
 4,332,217 ( 0.01%)  {
21,661,085 ( 0.03%)      return mr->ram_block ? mr->ram_block->offset : RAM_ADDR_INVALID;
         .           }
         .           
         .           void memory_region_ram_resize(MemoryRegion *mr, ram_addr_t newsize, Error **errp)
         .           {
         .               assert(mr->ram_block);
         .           
         .               qemu_ram_resize(mr->ram_block, newsize, errp);
         .           }
-- line 2424 ----------------------------------------
-- line 2478 ----------------------------------------
         .           
         .               cmr->addr = addrrange_make(int128_make64(offset), int128_make64(size));
         .               QTAILQ_INSERT_TAIL(&mr->coalesced, cmr, link);
         .               memory_region_update_coalesced_range(mr, cmr, true);
         .               memory_region_set_flush_coalesced(mr);
         .           }
         .           
         .           void memory_region_clear_coalescing(MemoryRegion *mr)
         2 ( 0.00%)  {
         .               CoalescedMemoryRange *cmr;
         .           
         4 ( 0.00%)      if (QTAILQ_EMPTY(&mr->coalesced)) {
         .                   return;
         .               }
         .           
         .               qemu_flush_coalesced_mmio_buffer();
         .               mr->flush_coalesced_mmio = false;
         .           
         .               while (!QTAILQ_EMPTY(&mr->coalesced)) {
         .                   cmr = QTAILQ_FIRST(&mr->coalesced);
         .                   QTAILQ_REMOVE(&mr->coalesced, cmr, link);
         .                   memory_region_update_coalesced_range(mr, cmr, false);
         .                   g_free(cmr);
         .               }
         2 ( 0.00%)  }
         .           
         .           void memory_region_set_flush_coalesced(MemoryRegion *mr)
         .           {
         .               mr->flush_coalesced_mmio = true;
         .           }
         .           
         .           void memory_region_clear_flush_coalesced(MemoryRegion *mr)
         .           {
-- line 2510 ----------------------------------------
-- line 2593 ----------------------------------------
         .               memory_region_transaction_commit();
         .           }
         .           
         .           static void memory_region_update_container_subregions(MemoryRegion *subregion)
         .           {
         .               MemoryRegion *mr = subregion->container;
         .               MemoryRegion *other;
         .           
        12 ( 0.00%)      memory_region_transaction_begin();
        96 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_transaction_begin (12x)
         .           
        24 ( 0.00%)      memory_region_ref(subregion);
       111 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_ref (12x)
        36 ( 0.00%)      QTAILQ_FOREACH(other, &mr->subregions, subregions_link) {
        40 ( 0.00%)          if (subregion->priority >= other->priority) {
        70 ( 0.00%)              QTAILQ_INSERT_BEFORE(other, subregion, subregions_link);
         .                       goto done;
         .                   }
         .               }
        12 ( 0.00%)      QTAILQ_INSERT_TAIL(&mr->subregions, subregion, subregions_link);
         .           done:
        86 ( 0.00%)      memory_region_update_pending |= mr->enabled && subregion->enabled;
        12 ( 0.00%)      memory_region_transaction_commit();
 1,930,078 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_transaction_commit (12x)
         .           }
         .           
         .           static void memory_region_add_subregion_common(MemoryRegion *mr,
         .                                                          hwaddr offset,
         .                                                          MemoryRegion *subregion)
        36 ( 0.00%)  {
         .               MemoryRegion *alias;
         .           
        24 ( 0.00%)      assert(!subregion->container);
        36 ( 0.00%)      subregion->container = mr;
        36 ( 0.00%)      for (alias = subregion->alias; alias; alias = alias->alias) {
         .                   alias->mapped_via_alias++;
         .               }
        12 ( 0.00%)      subregion->addr = offset;
         .               memory_region_update_container_subregions(subregion);
        36 ( 0.00%)  }
         .           
         .           void memory_region_add_subregion(MemoryRegion *mr,
         .                                            hwaddr offset,
         .                                            MemoryRegion *subregion)
         9 ( 0.00%)  {
         9 ( 0.00%)      subregion->priority = 0;
         9 ( 0.00%)      memory_region_add_subregion_common(mr, offset, subregion);
 1,228,188 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_add_subregion_common (9x)
         .           }
         .           
         .           void memory_region_add_subregion_overlap(MemoryRegion *mr,
         .                                                    hwaddr offset,
         .                                                    MemoryRegion *subregion,
         .                                                    int priority)
         3 ( 0.00%)  {
         3 ( 0.00%)      subregion->priority = priority;
         3 ( 0.00%)      memory_region_add_subregion_common(mr, offset, subregion);
   702,569 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_add_subregion_common (3x)
         .           }
         .           
         .           void memory_region_del_subregion(MemoryRegion *mr,
         .                                            MemoryRegion *subregion)
         .           {
         .               MemoryRegion *alias;
         .           
         .               memory_region_transaction_begin();
-- line 2653 ----------------------------------------
-- line 2852 ----------------------------------------
         .           }
         .           
         .           void memory_global_dirty_log_sync(void)
         .           {
         .               memory_region_sync_dirty_bitmap(NULL);
         .           }
         .           
         .           void memory_global_after_dirty_log_sync(void)
   159,992 ( 0.00%)  {
   959,952 ( 0.00%)      MEMORY_LISTENER_CALL_GLOBAL(log_global_after_sync, Forward);
 4,799,760 ( 0.01%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:tcg_log_global_after_sync (79,996x)
   159,992 ( 0.00%)  }
         .           
         .           /*
         .            * Dirty track stop flags that are postponed due to VM being stopped.  Should
         .            * only be used within vmstate_change hook.
         .            */
         .           static unsigned int postponed_stop_flags;
         .           static VMChangeStateEntry *vmstate_change;
         .           static void memory_global_dirty_log_stop_postponed_run(void);
-- line 2870 ----------------------------------------
-- line 2960 ----------------------------------------
         .           }
         .           
         .           static void listener_add_address_space(MemoryListener *listener,
         .                                                  AddressSpace *as)
         .           {
         .               FlatView *view;
         .               FlatRange *fr;
         .           
         3 ( 0.00%)      if (listener->begin) {
         .                   listener->begin(listener);
         .               }
         4 ( 0.00%)      if (global_dirty_tracking) {
         .                   if (listener->log_global_start) {
         .                       listener->log_global_start(listener);
         .                   }
         .               }
         .           
         3 ( 0.00%)      view = address_space_get_flatview(as);
        14 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:address_space_get_flatview (1x)
        55 ( 0.00%)      FOR_EACH_FLAT_RANGE(fr, view) {
         .                   MemoryRegionSection section = section_from_flat_range(fr, view);
         .           
        24 ( 0.00%)          if (listener->region_add) {
         1 ( 0.00%)              listener->region_add(listener, &section);
         .                   }
        36 ( 0.00%)          if (fr->dirty_log_mask && listener->log_start) {
         .                       listener->log_start(listener, &section, 0, fr->dirty_log_mask);
         .                   }
         .               }
         3 ( 0.00%)      if (listener->commit) {
         2 ( 0.00%)          listener->commit(listener);
    16,566 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/physmem.c:tcg_commit (1x)
         .               }
         5 ( 0.00%)      flatview_unref(view);
         4 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:flatview_unref (1x)
         .           }
         .           
         .           static void listener_del_address_space(MemoryListener *listener,
         .                                                  AddressSpace *as)
         .           {
         .               FlatView *view;
         .               FlatRange *fr;
         .           
-- line 2999 ----------------------------------------
-- line 3013 ----------------------------------------
         .               }
         .               if (listener->commit) {
         .                   listener->commit(listener);
         .               }
         .               flatview_unref(view);
         .           }
         .           
         .           void memory_listener_register(MemoryListener *listener, AddressSpace *as)
        11 ( 0.00%)  {
         .               MemoryListener *other = NULL;
         .           
         .               /* Only one of them can be defined for a listener */
         2 ( 0.00%)      assert(!(listener->log_sync && listener->log_sync_global));
         .           
         1 ( 0.00%)      listener->address_space = as;
         3 ( 0.00%)      if (QTAILQ_EMPTY(&memory_listeners)
         1 ( 0.00%)          || listener->priority >= QTAILQ_LAST(&memory_listeners)->priority) {
         5 ( 0.00%)          QTAILQ_INSERT_TAIL(&memory_listeners, listener, link);
         .               } else {
         .                   QTAILQ_FOREACH(other, &memory_listeners, link) {
         .                       if (listener->priority < other->priority) {
         .                           break;
         .                       }
         .                   }
         .                   QTAILQ_INSERT_BEFORE(other, listener, link);
         .               }
         .           
         3 ( 0.00%)      if (QTAILQ_EMPTY(&as->listeners)
         .                   || listener->priority >= QTAILQ_LAST(&as->listeners)->priority) {
         6 ( 0.00%)          QTAILQ_INSERT_TAIL(&as->listeners, listener, link_as);
         .               } else {
         .                   QTAILQ_FOREACH(other, &as->listeners, link_as) {
         .                       if (listener->priority < other->priority) {
         .                           break;
         .                       }
         .                   }
         .                   QTAILQ_INSERT_BEFORE(other, listener, link_as);
         .               }
         .           
         .               listener_add_address_space(listener, as);
         5 ( 0.00%)  }
         .           
         .           void memory_listener_unregister(MemoryListener *listener)
         .           {
         .               if (!listener->address_space) {
         .                   return;
         .               }
         .           
         .               listener_del_address_space(listener, listener->address_space);
-- line 3061 ----------------------------------------
-- line 3067 ----------------------------------------
         .           void address_space_remove_listeners(AddressSpace *as)
         .           {
         .               while (!QTAILQ_EMPTY(&as->listeners)) {
         .                   memory_listener_unregister(QTAILQ_FIRST(&as->listeners));
         .               }
         .           }
         .           
         .           void address_space_init(AddressSpace *as, MemoryRegion *root, const char *name)
        21 ( 0.00%)  {
         6 ( 0.00%)      memory_region_ref(root);
        30 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_ref (3x)
         3 ( 0.00%)      as->root = root;
         3 ( 0.00%)      as->current_map = NULL;
         3 ( 0.00%)      as->ioeventfd_nb = 0;
         3 ( 0.00%)      as->ioeventfds = NULL;
         9 ( 0.00%)      QTAILQ_INIT(&as->listeners);
        18 ( 0.00%)      QTAILQ_INSERT_TAIL(&address_spaces, as, address_spaces_link);
        18 ( 0.00%)      as->name = g_strdup(name ? name : "anonymous");
       317 ( 0.00%)  => ???:0x0000000004e3b620 (3x)
         .               address_space_update_topology(as);
         6 ( 0.00%)      address_space_update_ioeventfds(as);
       449 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:address_space_update_ioeventfds (3x)
         9 ( 0.00%)  }
         .           
         .           static void do_address_space_destroy(AddressSpace *as)
         .           {
         .               assert(QTAILQ_EMPTY(&as->listeners));
         .           
         .               flatview_unref(as->current_map);
         .               g_free(as->name);
         .               g_free(as->ioeventfds);
-- line 3094 ----------------------------------------
-- line 3526 ----------------------------------------
         .               }
         .           }
         .           
         .           void memory_region_init_ram(MemoryRegion *mr,
         .                                       Object *owner,
         .                                       const char *name,
         .                                       uint64_t size,
         .                                       Error **errp)
        44 ( 0.00%)  {
         .               DeviceState *owner_dev;
         4 ( 0.00%)      Error *err = NULL;
         .           
         8 ( 0.00%)      memory_region_init_ram_nomigrate(mr, owner, name, size, &err);
    71,843 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../softmmu/memory.c:memory_region_init_ram_nomigrate (4x)
        12 ( 0.00%)      if (err) {
         .                   error_propagate(errp, err);
         .                   return;
         .               }
         .               /* This will assert if owner is neither NULL nor a DeviceState.
         .                * We only want the owner here for the purposes of defining a
         .                * unique name for migration. TODO: Ideally we should implement
         .                * a naming scheme for Objects which are not DeviceStates, in
         .                * which case we can relax this restriction.
         .                */
         .               owner_dev = DEVICE(owner);
        12 ( 0.00%)      vmstate_register_ram(mr, owner_dev);
     1,050 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../migration/savevm.c:vmstate_register_ram (4x)
        32 ( 0.00%)  }
         .           
         .           void memory_region_init_rom(MemoryRegion *mr,
         .                                       Object *owner,
         .                                       const char *name,
         .                                       uint64_t size,
         .                                       Error **errp)
         .           {
         .               DeviceState *owner_dev;
-- line 3559 ----------------------------------------
-- line 3633 ----------------------------------------
         .           
         .           static const TypeInfo ram_discard_manager_info = {
         .               .parent             = TYPE_INTERFACE,
         .               .name               = TYPE_RAM_DISCARD_MANAGER,
         .               .class_size         = sizeof(RamDiscardManagerClass),
         .           };
         .           
         .           static void memory_register_types(void)
         2 ( 0.00%)  {
         2 ( 0.00%)      type_register_static(&memory_region_info);
     1,324 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_register_static (1x)
         2 ( 0.00%)      type_register_static(&iommu_memory_region_info);
     1,422 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_register_static (1x)
         2 ( 0.00%)      type_register_static(&ram_discard_manager_info);
     1,411 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../qom/object.c:type_register_static (1x)
         1 ( 0.00%)  }
         .           
         4 ( 0.00%)  type_init(memory_register_types)
       261 ( 0.00%)  => /root/fuzzer/xxfuzzer/qemu-7.2.0/build/../util/module.c:register_module_init (1x)

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  ./debug/../setjmp/longjmp.c
  ./debug/../sysdeps/unix/sysv/linux/x86_64/____longjmp_chk.S
  ./debug/./debug/read_chk.c
  ./elf/../sysdeps/x86_64/tls_get_addr.S
  ./io/../sysdeps/unix/sysv/linux/read.c
  ./io/../sysdeps/unix/sysv/linux/write.c
  ./malloc/./malloc/malloc.c
  ./nptl/./nptl/cancellation.c
  ./nptl/./nptl/pthread_cleanup_upto.c
  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
  ./string/../sysdeps/x86_64/multiarch/strcmp-avx2.S

--------------------------------------------------------------------------------
Ir                      
--------------------------------------------------------------------------------
51,104,339,839 (70.06%)  events annotated

